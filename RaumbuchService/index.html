<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raumbuch Manager - Lokal</title>
    <link rel="stylesheet" href="Content/Site.css">
    <!-- Trimble Workspace API -->
    <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
    <script src="Scripts/app.js"></script>
</head>



<body>
    <!-- =============================== -->
    <!-- TOP TAB NAVIGATION (Trimble Connect style) - FLYTTET HIT FOR FULL BREDDE -->
    <!-- =============================== -->
    <nav class="tc-tabs">

        <div class="tc-tab active" onclick="openTab('tab-raumprogramm')">
            <img src="Img/book.png" class="tc-tab-icon" />
            <span>Raumprogramm</span>
        </div>

        <div class="tc-tab" onclick="openTab('tab-ausgefuehrt')">
            <img src="Img/book.png" class="tc-tab-icon" />
            <span>Ausgef√ºhrt</span>
        </div>

        <div class="tc-tab" onclick="openTab('tab-analyse')">
            <img src="Img/analyse.png" class="tc-tab-icon" />
            <span>Analyse</span>
        </div>

        <div class="tc-tab" onclick="openTab('tab-ausstattung')">
            <img src="Img/material.png" class="tc-tab-icon" />
            <span>Ausstattungen</span>
        </div>

        <div class="tc-tab" onclick="openTab('tab-bcf')">
            <img src="Img/mail.png" class="tc-tab-icon" />
            <span>Nachricht</span>
        </div>

        <div class="tc-tab" onclick="openTab('tab-konfig')">
            <img src="Img/settings.png" class="tc-tab-icon" />
            <span>Einstellungen</span>
        </div>
    </nav>

    <div class="container">
        <main>

            <!-- ========================================================= -->
            <!-- TAB 1 ‚Äì KONFIGURATION + STEP 1 + STEP 3 + STEP 4          -->
            <!-- ========================================================= -->
            <div id="tab-konfig" class="tab-content">

                <!-- BUILDING MANAGEMENT SECTION -->
                <section class="card">
                    <h2>üè¢ Geb√§udeverwaltung</h2>
                    <p>Erstellen und verwalten Sie Geb√§ude f√ºr das Multi-Building-System.</p>

                    <!-- Building Creation -->
                    <div class="form-group">
                        <label>Neues Geb√§ude erstellen:</label>
                        <div style="display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap;">
                            <input type="text" id="newBuildingName" class="form-control" placeholder="Geb√§udename (z.B. 'Hauptgeb√§ude')" style="flex:1; min-width:200px;">
                            <input type="text" id="newBuildingCode" class="form-control" placeholder="Code (z.B. 'HG01')" style="width:120px;">
                            <button class="btn btn-primary" onclick="createBuilding()">üèóÔ∏è Geb√§ude erstellen</button>
                        </div>
                    </div>

                    <!-- Building Selection with Projektdaten laden button -->
                    <div class="form-group">
                        <label for="buildingSelect">Geb√§ude ausw√§hlen:</label>
                        <div style="display:flex; gap:10px; align-items:flex-start;">
                            <select id="buildingSelect" class="form-control" style="flex:1;" onchange="loadBuildingDetails()">
                                <option value="">-- Geb√§ude ausw√§hlen --</option>
                            </select>
                            <button class="btn btn-secondary" onclick="loadBuildingList()">üîÑ Aktualisieren</button>
                            <button class="btn btn-primary" onclick="loadProjectData()">üìÅ Projektdaten laden</button>
                        </div>
                        <small style="color:#666; margin-top:5px; display:block;">
                            "Projektdaten laden" l√§dt alle JSON-Dateien aus Azure und aktualisiert Trimble Connect Daten.
                        </small>
                    </div>

                    <div id="buildingResult" class="result"></div>
                </section>

                <!-- KONFIGURATION ‚Äì With IFC and Logo settings -->
                <section class="card">
                    <h2>Konfiguration</h2>

                    <!-- Predefined Folder -->
                    <div class="form-group">
                        <label for="targetFolder">Vordefinierte Ordner:</label>
                        <div style="display:flex; gap:10px; margin-top:10px;">
                            <select id="targetFolder" class="form-control">
                                <option value="">-- Klicken Sie auf "Projektdaten laden" --</option>
                            </select>
                            <button class="btn btn-secondary" onclick="fetchFiles()">üîÑ Dateien laden</button>
                            <button class="btn btn-secondary" onclick="openPredefinedFolder()">üìÅ Vordefinierte Ordner √∂ffnen</button>
                        </div>
                        <small style="color:#666; margin-top:5px; display:block;">Dieser Ordner wird als Standard f√ºr verschiedene Exports verwendet.</small>
                    </div>

                    <!-- IFC Spaces File -->
                    <div class="form-group">
                        <label for="ifcFile">IfcSpaces Datei (.ifc):</label>
                        <select id="ifcFile" class="form-control">
                            <option value="">-- IFC ausw√§hlen nach "Dateien laden" --</option>
                        </select>
                        <small style="color:#666;">Diese Datei wird als Referenz f√ºr IFC-Spaces in der gesamten Anwendung verwendet.</small>
                    </div>

                    <!-- Logo Upload -->
                    <div class="form-group">
                        <label>Logo:</label>
                        <div style="display:flex; gap:10px; align-items:center;">
                            <input type="file" id="logoFileInput" accept="image/*" style="display:none;" onchange="uploadLogo()">
                            <button class="btn btn-secondary" onclick="document.getElementById('logoFileInput').click()">üì∑ Logo hochladen</button>
                            <input type="text" id="editLogoUrl" class="form-control" placeholder="Logo URL (automatisch nach Upload)" style="flex:1;" readonly>
                            <img id="buildingLogoPreview" src="" alt="" style="height:40px; display:none;">
                        </div>
                    </div>

                    <!-- Hidden IFC fields (populated automatically) -->
                    <input type="hidden" id="editIFCEnabled">
                    <input type="hidden" id="editIFCProjectGUID">
                    <input type="hidden" id="editIFCBuildingGUID">
                    <input type="hidden" id="editIFCFileUrl">

                    <!-- Save Configuration Button -->
                    <div class="form-group" style="margin-top:15px;">
                        <button class="btn btn-primary" onclick="saveConfiguration()">üíæ Konfiguration speichern</button>
                    </div>

                    <div id="connectionResult" class="result"></div>
                </section>


                <section class="card">
                    <h2>üë• Benutzer- & Rechteverwaltung</h2>
                    <p>Verwalten Sie Benutzer, Gruppen und rollenbasierte Zugriffsrechte f√ºr das Raumbuch.</p>

                    <h3>üîê Rollen pro Gruppe & Benutzer</h3>
                    <p>Gruppen von Trimble Connect k√∂nnen erweitert werden, um einzelne Nutzer zu zeigen. Rollen k√∂nnen pro Gruppe gesetzt und bei Bedarf auf Benutzerebene √ºbersteuert werden.</p>

                    <div class="table-responsive">
                        <table class="table table-striped table-bordered" style="min-width:600px;">
                            <thead>
                                <tr>
                                    <th style="width:220px;">Gruppe / Benutzer</th>
                                    <th style="text-align:center;">Admin</th>
                                    <th style="text-align:center;">Editor</th>
                                    <th style="text-align:center;">Leser</th>
                                    <th style="text-align:center;">NoAccess</th>
                                </tr>
                            </thead>
                            <tbody>

                                <tr class="table-secondary expandable-group" data-group-id="group1" onclick="toggleGroup('group1')">
                                    <td><strong id="icon-group1" style="margin-right: 5px;">‚ñ∂</strong> <strong>Gruppe 1</strong></td>
                                    <td style="text-align:center;"><input type="radio" name="grp1role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="grp1role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="grp1role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="grp1role" /></td>
                                </tr>

                                <tr class="user-row group1-user" style="display: none;">
                                    <td style="padding-left:30px;">Bruker 1</td>
                                    <td style="text-align:center;"><input type="radio" name="usr1role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr1role" checked /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr1role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr1role" /></td>
                                </tr>

                                <tr class="user-row group1-user" style="display: none;">
                                    <td style="padding-left:30px;">Bruker 2</td>
                                    <td style="text-align:center;"><input type="radio" name="usr2role" checked /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr2role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr2role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr2role" /></td>
                                </tr>

                                <tr class="user-row group1-user" style="display: none;">
                                    <td style="padding-left:30px;">Bruker 3</td>
                                    <td style="text-align:center;"><input type="radio" name="usr3role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr3role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr3role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr3role" checked /></td>
                                </tr>

                                <tr class="table-secondary expandable-group" data-group-id="group2" onclick="toggleGroup('group2')">
                                    <td><strong id="icon-group2" style="margin-right: 5px;">‚ñ∂</strong> <strong>Gruppe 2</strong></td>
                                    <td style="text-align:center;"><input type="radio" name="grp2role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="grp2role" checked /></td>
                                    <td style="text-align:center;"><input type="radio" name="grp2role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="grp2role" /></td>
                                </tr>

                                <tr class="user-row group2-user" style="display: none;">
                                    <td style="padding-left:30px;">Bruker 4</td>
                                    <td style="text-align:center;"><input type="radio" name="usr4role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr4role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr4role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr4role" /></td>
                                </tr>

                                <tr class="user-row group2-user" style="display: none;">
                                    <td style="padding-left:30px;">Bruker 5</td>
                                    <td style="text-align:center;"><input type="radio" name="usr5role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr5role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr5role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr5role" /></td>
                                </tr>

                                <tr class="user-row group2-user" style="display: none;">
                                    <td style="padding-left:30px;">Bruker 6</td>
                                    <td style="text-align:center;"><input type="radio" name="usr6role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr6role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr6role" /></td>
                                    <td style="text-align:center;"><input type="radio" name="usr6role" /></td>
                                </tr>

                            </tbody>
                        </table>
                    </div>

                    <hr>

                    <h3>‚öôÔ∏è Editor-Rechte (Globale Einstellungen)</h3>
                    <p>Definieren Sie, welche Aktionen Editor-Benutzer durchf√ºhren d√ºrfen.</p>

                    <div class="table-responsive">
                        <table class="table table-bordered table-striped">
                            <thead>
                                <tr>
                                    <th>Funktion</th>
                                    <th style="text-align:center; width: 100px;">Erlaubt</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Raumtyp erstellen</td>
                                    <td style="text-align:center;"><input type="checkbox" /></td>
                                </tr>
                                <tr>
                                    <td>Inventar erstellen</td>
                                    <td style="text-align:center;"><input type="checkbox" /></td>
                                </tr>
                                <tr>
                                    <td>Inventar bearbeiten</td>
                                    <td style="text-align:center;"><input type="checkbox" /></td>
                                </tr>
                                <tr>
                                    <td>IST-Werte bearbeiten</td>
                                    <td style="text-align:center;"><input type="checkbox" /></td>
                                </tr>
                                <tr>
                                    <td>SOLL-Werte bearbeiten</td>
                                    <td style="text-align:center;"><input type="checkbox" /></td>
                                </tr>
                                <tr>
                                    <td>Datenbankobjekte l√∂schen</td>
                                    <td style="text-align:center;"><input type="checkbox" disabled title="Nur Administratoren" /></td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </section>

                <script>
                    /**
                     * Veksler visningen av brukerrader for en gitt gruppe-ID.
                     * Endrer ogs√• utvidelsesikonet (‚ñ∂/‚ñº).
                     */
                    function toggleGroup(groupId) {
                        // Hent alle brukerrader for den spesifikke gruppen
                        const userRows = document.querySelectorAll('.' + groupId + '-user');

                        // Hent ikonet (‚ñ∂) for gruppen
                        const iconElement = document.getElementById('icon-' + groupId);

                        userRows.forEach(row => {
                            // Veksler mellom 'block' (vis) og 'none' (skjul)
                            if (row.style.display === 'none') {
                                row.style.display = 'table-row'; // Vis raden
                                if (iconElement) {
                                    iconElement.innerHTML = '‚ñº'; // Endre til utvidet ikon
                                }
                            } else {
                                row.style.display = 'none'; // Skjul raden
                                if (iconElement) {
                                    iconElement.innerHTML = '‚ñ∂'; // Endre til sammensl√•tt ikon
                                }
                            }
                        });
                    }
                </script>



                <!-- Building Properties Card (always visible) -->
                <section class="card" id="buildingPropertiesSection">
                    <h2>üìã Geb√§udeeigenschaften</h2>

                    <!-- Basic Information -->
                    <div class="form-group">
                        <label>Grundinformationen:</label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px;">
                            <div>
                                <small>Geb√§udename:</small>
                                <input type="text" id="editBuildingName" class="form-control" placeholder="Geb√§udename">
                            </div>
                            <div>
                                <small>Code:</small>
                                <input type="text" id="editBuildingCode" class="form-control" placeholder="Code">
                            </div>
                        </div>
                    </div>

                    <!-- Address Information -->
                    <div class="form-group">
                        <label>Adresse:</label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px;">
                            <div>
                                <small>Adresse ‚Äì Strasse:</small>
                                <input type="text" id="editAddressStreet" class="form-control" placeholder="Strasse">
                            </div>
                            <div>
                                <small>Adresse ‚Äì Ort:</small>
                                <input type="text" id="editAddressCity" class="form-control" placeholder="Ort">
                            </div>
                            <div>
                                <small>Adresse ‚Äì Postleitzahl:</small>
                                <input type="text" id="editAddressPostalCode" class="form-control" placeholder="Postleitzahl">
                            </div>
                            <div>
                                <small>Adresse ‚Äì Land:</small>
                                <input type="text" id="editAddressCountry" class="form-control" placeholder="Land" value="Switzerland">
                            </div>
                        </div>
                    </div>

                    <!-- Owner and Creator -->
                    <div class="form-group">
                        <label>Verantwortlichkeiten:</label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px;">
                            <div>
                                <small>Eigent√ºmer / Bauherr:</small>
                                <input type="text" id="editBuildingOwner" class="form-control" placeholder="Eigent√ºmer / Bauherr">
                            </div>
                            <div>
                                <small>Ersteller / Verantwortliche Person:</small>
                                <input type="text" id="editBuildingCreator" class="form-control" placeholder="Ersteller / Verantwortliche Person">
                            </div>
                        </div>
                    </div>

                    <!-- Coordinate Settings -->
                    <div class="form-group">
                        <label>Koordinaten:</label>
                        <div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap:10px;">
                            <div>
                                <small>Koordinatensystem:</small>
                                <input type="text" id="editCoordinateSystem" class="form-control" placeholder="Koordinatensystem" value="Switzerland/CH1903+ (LV95) ‚Äì EPSG:2056">
                            </div>
                            <div>
                                <small>Lokaler Nullpunkt (X, Y, Z):</small>
                                <div style="display:flex; gap:5px;">
                                    <input type="number" step="0.0001" id="editLocalOriginX" class="form-control" placeholder="X" value="0" style="flex:1;">
                                    <input type="number" step="0.0001" id="editLocalOriginY" class="form-control" placeholder="Y" value="0" style="flex:1;">
                                    <input type="number" step="0.0001" id="editLocalOriginZ" class="form-control" placeholder="Z" value="0" style="flex:1;">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Description -->
                    <div class="form-group">
                        <small>Beschreibung:</small>
                        <textarea id="editBuildingDescription" class="form-control" rows="2" placeholder="Beschreibung des Geb√§udes"></textarea>
                    </div>

                    <!-- Trimble Connect Info (Read-only) -->
                    <div class="form-group">
                        <label>Trimble Connect Informationen:</label>
                        <div id="trimbleConnectInfo" style="background:#f5f5f5; padding:10px; border-radius:4px;">
                            <small style="color:#666;">Dr√ºcken Sie "Projektdaten laden" um Trimble Connect Daten zu aktualisieren.</small>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="form-group">
                        <button class="btn btn-primary" onclick="saveBuilding()">üíæ Geb√§ude speichern</button>
                        <button class="btn btn-danger" onclick="deleteBuilding()">üóëÔ∏è Geb√§ude l√∂schen</button>
                    </div>

                    <div id="buildingDetailsResult" class="result"></div>
                </section>


            </div> <!-- END TAB 1 -->
            <!-- ========================================================= -->
            <!-- TAB - RAUMPROGRAMM (SOLL Data Management)                 -->
            <!-- ========================================================= -->
            <div id="tab-raumprogramm" class="tab-content active">
                <!-- KPI Indicators Widget - Matching Analyse page style -->
                <section class="card kpi-widget">
                    <h2>√úbersicht</h2>
                    <div class="kpi-container">
                        <div class="kpi-item">
                            <span class="kpi-label">Raumtypen</span>
                            <span class="kpi-value" id="sollKpiRoomTypes">0</span>
                        </div>
                        <div class="kpi-item">
                            <span class="kpi-label">R√§ume</span>
                            <span class="kpi-value" id="sollKpiRooms">0</span>
                        </div>
                        <div class="kpi-item">
                            <span class="kpi-label">Inventarobjekte</span>
                            <span class="kpi-value" id="sollKpiInventory">0</span>
                        </div>
                    </div>
                </section>

                <!-- Raumprogramm Overview - Moved to top -->
                <section class="card">
                    <h2>Raumprogramm √úbersicht (SOLL)</h2>
                    <p>Zeigt die geplanten (SOLL) Werte. Felder sind direkt in der Tabelle bearbeitbar. F√ºr IST-Werte nutzen Sie den Tab "Ausgef√ºhrt".</p>

                    <!-- Building Selector -->
                    <div class="form-group" style="margin-bottom:15px; padding:10px; background:#e3f2fd; border-radius:5px; border-left:4px solid var(--tc-primary-blue);">
                        <label for="raumprogram-building" style="font-weight:bold;">üè¢ Geb√§ude ausw√§hlen:</label>
                        <div style="display:flex; gap:10px; align-items:center; margin-top:5px;">
                            <select id="raumprogram-building" class="form-control" style="width:300px;" onchange="onBuildingChange()">
                                <option value="">-- Bitte Geb√§ude ausw√§hlen --</option>
                            </select>
                            <span id="buildingRequiredMessage" style="color:#D64545; display:none;">‚ö†Ô∏è Bitte w√§hlen Sie ein Geb√§ude.</span>
                        </div>
                    </div>

                    <!-- Main Action Button -->
                    <div style="margin-bottom:15px;">
                        <button class="btn btn-primary" onclick="loadAllSollData()">üì• Daten laden</button>
                        <button class="btn btn-success" onclick="saveAllSollChanges()">üíæ √Ñnderungen speichern</button>
                        <button class="btn btn-secondary" onclick="sollUndo()" title="R√ºckg√§ngig (Strg+Z)">‚Ü∂ R√ºckg√§ngig</button>
                        <button class="btn btn-secondary" onclick="sollRedo()" title="Wiederholen (Strg+Y)">‚Ü∑ Wiederholen</button>
                    </div>
                    <div id="raumprogramResult" class="result"></div>

                    <!-- Filters -->
                    <div class="filter-controls">
                        <div class="form-group" style="display:inline-block; margin-right:15px;">
                            <label for="raumprogram-filter-roomtype">Raumtyp:</label>
                            <select id="raumprogram-filter-roomtype" class="form-control" style="width:200px;" onchange="loadRaumprogramData()">
                                <option value="">-- Alle --</option>
                            </select>
                        </div>
                        <div class="form-group" style="display:inline-block; margin-right:15px;">
                            <label for="raumprogram-filter-inventory">Inventar:</label>
                            <select id="raumprogram-filter-inventory" class="form-control" style="width:200px;" multiple onchange="loadRaumprogramData()" title="Strg+Klick f√ºr Mehrfachauswahl">
                                <option value="">-- Alle --</option>
                            </select>
                        </div>
                        <div class="form-group" style="display:inline-block;">
                            <label for="raumprogram-search">Suche:</label>
                            <input type="text" id="raumprogram-search" class="form-control" placeholder="Raum suchen..." style="width:200px;" onkeyup="loadRaumprogramData()">
                        </div>
                    </div>

                    <!-- Column Visibility Controls and Autosave Toggle -->
                    <div style="margin-bottom:10px; padding:10px; background:#f5f5f5; border-radius:5px;">
                        <div style="margin-bottom:8px;">
                            <label style="font-weight:bold; margin-right:15px;">Spalten anzeigen:</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="col-raumtyp" checked onchange="loadRaumprogramData()"> Raumtyp</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="col-raumkategorie" checked onchange="loadRaumprogramData()"> Raumkategorie</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="col-raum" checked onchange="loadRaumprogramData()"> Raum</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="col-netarea" checked onchange="loadRaumprogramData()"> Nettofl√§che</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="col-grossarea" checked onchange="loadRaumprogramData()"> Bruttofl√§che</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="col-description" onchange="loadRaumprogramData()"> Beschreibung</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="col-objecttype" onchange="loadRaumprogramData()"> Objekttyp</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="col-predefinedtype" onchange="loadRaumprogramData()"> Vordefinierter Typ</label>
                        </div>
                        <div style="border-top:1px solid #ddd; padding-top:8px;">
                            <label style="font-weight:bold; margin-right:15px;">Einstellungen:</label>
                            <label style="margin-right:10px; color:#0066cc;"><input type="checkbox" id="soll-autosave" checked> √Ñnderungen automatisch speichern</label>
                        </div>
                    </div>

                    <!-- Data Table - SOLL only, editable columns -->
                    <div class="analyse-table-container" style="max-height:500px; overflow-y:auto; overflow-x:auto;">
                        <table class="analyse-table" id="raumprogramTable">
                            <thead id="raumprogramTableHead">
                                <tr>
                                    <th>Raumtyp</th>
                                    <th>Raumkategorie</th>
                                    <th>Raum</th>
                                    <th>Nettofl√§che (m¬≤)</th>
                                    <th>Bruttofl√§che (m¬≤)</th>
                                    <th>Aktionen</th>
                                </tr>
                            </thead>
                            <tbody id="raumprogramTableBody">
                                <tr>
                                    <td colspan="6" style="text-align:center; color:#666;">
                                        Keine Daten vorhanden. Klicken Sie auf "Daten laden".
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Pagination -->
                    <div style="margin-top:15px; display:flex; justify-content:space-between; align-items:center;">
                        <div>
                            <span id="raumprogramPaginationInfo">Seite 1 von 1</span>
                        </div>
                        <div>
                            <button class="btn btn-secondary" id="raumprogramPrevPage" onclick="loadRaumprogramData(currentRaumprogramPage - 1)" disabled>‚óÄ Zur√ºck</button>
                            <button class="btn btn-secondary" id="raumprogramNextPage" onclick="loadRaumprogramData(currentRaumprogramPage + 1)" disabled>Weiter ‚ñ∂</button>
                        </div>
                    </div>

                </section>


                <!-- Master Data Management -->
                <section class="card">
                    <h2>Stammdaten verwalten</h2>

                    <div id="masterDataResult" class="result"></div>

                    <div class="subsection">
                        <h3>Ausstattungseigenschaften (Inventory Templates)</h3>
                        <div class="form-group">
                            <label for="newInventoryPropertyName">Neue Eigenschaft:</label>
                            <div style="display:flex; gap:10px; align-items:flex-start;">
                                <input type="text" id="newInventoryPropertyName" class="form-control" placeholder="z.B. 'Bodenbelag', 'Beleuchtung'" style="flex:1;">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="newInventoryDataType">Datentyp:</label>
                            <div style="display:flex; gap:10px; align-items:flex-start;">
                                <select id="newInventoryDataType" class="form-control" style="width:200px;">
                                    <option value="Text">Text</option>
                                    <option value="Number">Zahl (Number)</option>
                                    <option value="Integer">Ganzzahl (Integer)</option>
                                    <option value="Decimal">Dezimalzahl (Decimal)</option>
                                    <option value="Boolean">Ja/Nein (Boolean)</option>
                                </select>
                                <input type="text" id="newInventoryUnit" class="form-control" placeholder="Einheit (z.B. m¬≤, kg, St√ºck)" style="width:180px;">
                                <button class="btn btn-primary" onclick="createInventoryTemplate()">‚ûï Hinzuf√ºgen</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Vorhandene Eigenschaften:</label>
                            <select id="existingInventoryTemplates" class="form-control" size="5" style="width:100%;" multiple>
                                <option value="">-- Laden Sie die Daten --</option>
                            </select>
                            <small>Mehrfachauswahl: Strg+Klick f√ºr mehrere Inventare</small>
                            <div style="margin-top:10px;">
                                <button class="btn btn-secondary" onclick="loadInventoryTemplates()">üîÑ Laden</button>
                                <button class="btn btn-danger" onclick="deleteSelectedInventoryTemplate()">üóëÔ∏è L√∂schen</button>
                            </div>
                        </div>
                    </div>

                    <hr style="margin:20px 0;">

                    <!-- R√§ume verwalten (Room Management) - SOLL only, IST moved to Ausgef√ºhrt tab -->
                    <h3>R√§ume verwalten (SOLL)</h3>
                    <div class="form-group">
                        <label for="roomRoomType">Raumtyp:</label>
                        <select id="roomRoomType" class="form-control">
                            <option value="">-- Raumtyp ausw√§hlen --</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label for="roomName">Raum Name:</label>
                        <input type="text" id="roomName" class="form-control" placeholder="z.B. 'B√ºro 101'">
                    </div>
                    <div class="form-group">
                        <label for="roomAreaPlanned">Fl√§che SOLL (m¬≤):</label>
                        <input type="number" id="roomAreaPlanned" class="form-control" step="0.01" placeholder="0.00" style="max-width:200px;">
                    </div>
                    <div style="margin-top:10px;">
                        <button class="btn btn-primary" onclick="createRoom()">‚ûï Raum hinzuf√ºgen</button>
                    </div>
                    <div id="roomManagementResult" class="result"></div>

                    <hr style="margin:20px 0;">

                    <div class="subsection">
                        <h3>Raumtypen</h3>
                        <div class="form-group">
                            <label for="newRoomTypeName">Neuer Raumtyp:</label>
                            <div style="display:flex; gap:10px; align-items:flex-start;">
                                <input type="text" id="newRoomTypeName" class="form-control" placeholder="z.B. 'B√ºro', 'Besprechungsraum'" style="flex:1;">
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="newRoomTypeCategory">Raumkategorie:</label>
                            <div style="display:flex; gap:10px; align-items:flex-start;">
                                <input type="text" id="newRoomTypeCategory" class="form-control" placeholder="z.B. 'Arbeitsfl√§che', 'Gemeinschaftsfl√§che'" style="flex:1;">
                                <button class="btn btn-primary" onclick="createRoomType()">‚ûï Hinzuf√ºgen</button>
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Vorhandene Raumtypen:</label>
                            <select id="existingRoomTypes" class="form-control" size="5" style="width:100%;">
                                <option value="">-- Laden Sie die Daten --</option>
                            </select>
                            <div style="margin-top:10px;">
                                <button class="btn btn-secondary" onclick="loadRoomTypes()">üîÑ Laden</button>
                                <button class="btn btn-danger" onclick="deleteSelectedRoomType()">üóëÔ∏è L√∂schen</button>
                            </div>
                        </div>
                    </div>

                    <hr style="margin:20px 0;">


                </section>

 
                <!-- Import/Export -->
                <section class="card">
                    <h2>Import / Export</h2>
                    <p>Excel-Daten importieren oder exportieren</p>

                    <div class="form-group">
                        <label for="raumprogramImportFile">Excel-Datei f√ºr Import:</label>
                        <select id="raumprogramImportFile" class="form-control">
                            <option value="">-- Datei ausw√§hlen (nach "Dateien laden" in Einstellungen) --</option>
                        </select>
                    </div>

                    <div style="margin-top:15px;">
                        <button class="btn btn-primary" onclick="importRaumprogramFromExcel()">üì• Import (Excel ‚Üí SQL)</button>
                        <button class="btn btn-secondary" onclick="exportRaumprogramToExcel()">üì§ Export (SQL ‚Üí Excel)</button>
                    </div>
                    <div id="importExportResult" class="result"></div>
                </section>

            </div> <!-- END TAB RAUMPROGRAMM -->
            <!-- ========================================================= -->
            <!-- TAB - AUSGEF√úHRT (IST/Actuals Data Management)            -->
            <!-- ========================================================= -->
            <div id="tab-ausgefuehrt" class="tab-content">

                <!-- KPI Indicators Widget - IST/SOLL Comparison -->
                <section class="card kpi-widget">
                    <h2>√úbersicht (IST/SOLL Vergleich)</h2>
                    <div class="kpi-container">
                        <div class="kpi-item" id="istKpiBruttoContainer">
                            <span class="kpi-label">Bruttofl√§che</span>
                            <span class="kpi-value" id="istKpiBrutto">0 / 0 m¬≤</span>
                        </div>
                        <div class="kpi-item" id="istKpiNettoContainer">
                            <span class="kpi-label">Nettofl√§che</span>
                            <span class="kpi-value" id="istKpiNetto">0 / 0 m¬≤</span>
                        </div>
                        <div class="kpi-item" id="istKpiInventoryContainer">
                            <span class="kpi-label">Inventar Gesamt</span>
                            <span class="kpi-value" id="istKpiInventory">0 / 0</span>
                        </div>
                    </div>
                </section>

                <section class="card">
                    <h2>Ausgef√ºhrt (IST-Werte)</h2>
                    <p>Hier werden die tats√§chlichen (IST) Werte der R√§ume und Inventare erfasst und verwaltet. SOLL-Werte (grau) werden zum Vergleich angezeigt.</p>

                    <!-- Main Action Button with Progress Bar -->
                    <div style="margin-bottom:15px;">
                        <button class="btn btn-primary" onclick="loadAllIstData()">üì• Daten laden</button>
                        <button class="btn btn-success" onclick="saveAllIstChanges()">üíæ √Ñnderungen speichern</button>
                        <button class="btn btn-secondary" onclick="istUndo()" title="R√ºckg√§ngig (Strg+Z)">‚Ü∂ R√ºckg√§ngig</button>
                        <button class="btn btn-secondary" onclick="istRedo()" title="Wiederholen (Strg+Y)">‚Ü∑ Wiederholen</button>
                    </div>
                    <div id="istLoadingProgress" style="display:none; margin-bottom:15px;">
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <div class="spinner"></div>
                            <span>Lade Daten...</span>
                        </div>
                        <div style="margin-top: 10px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
                            <div id="istProgressBar" style="height: 6px; background: linear-gradient(90deg, #0066cc, #00aaff); width: 0%; transition: width 0.3s ease;"></div>
                        </div>
                        <small id="istLoadingStatus" style="color: #666;">Initialisiere...</small>
                    </div>
                    <div id="istResult" class="result"></div>

                    <!-- Filters -->
                    <div class="filter-controls">
                        <div class="form-group" style="display:inline-block; margin-right:15px;">
                            <label for="ist-filter-roomtype">Raumtyp:</label>
                            <select id="ist-filter-roomtype" class="form-control" style="width:200px;" onchange="loadIstData()">
                                <option value="">-- Alle --</option>
                            </select>
                        </div>
                        <div class="form-group" style="display:inline-block; margin-right:15px;">
                            <label for="ist-filter-inventory">Inventar:</label>
                            <select id="ist-filter-inventory" class="form-control" style="width:200px;" multiple onchange="loadIstData()" title="Strg+Klick f√ºr Mehrfachauswahl">
                                <option value="">-- Alle --</option>
                            </select>
                        </div>
                        <div class="form-group" style="display:inline-block;">
                            <label for="ist-search">Suche:</label>
                            <input type="text" id="ist-search" class="form-control" placeholder="Raum suchen..." style="width:200px;" onkeyup="loadIstData()">
                        </div>
                    </div>

                    <!-- Column Visibility Controls and Autosave Toggle -->
                    <div style="margin-bottom:10px; padding:10px; background:#f5f5f5; border-radius:5px;">
                        <div style="margin-bottom:8px;">
                            <label style="font-weight:bold; margin-right:15px;">Spalten anzeigen:</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="ist-col-raumtyp" checked onchange="loadIstData()"> Raumtyp</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="ist-col-raumkategorie" checked onchange="loadIstData()"> Raumkategorie</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="ist-col-raum" checked onchange="loadIstData()"> Raum</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="ist-col-netarea" checked onchange="loadIstData()"> Nettofl√§che SOLL/IST</label>
                            <label style="margin-right:10px;"><input type="checkbox" id="ist-col-grossarea" checked onchange="loadIstData()"> Bruttofl√§che SOLL/IST</label>
                            <label style="margin-right:10px; color:#0066cc;"><input type="checkbox" id="ist-col-showallsoll" onchange="loadIstData()"> Alle SOLL-Spalten anzeigen</label>
                        </div>
                        <div style="border-top:1px solid #ddd; padding-top:8px;">
                            <label style="font-weight:bold; margin-right:15px;">Einstellungen:</label>
                            <label style="margin-right:10px; color:#0066cc;"><input type="checkbox" id="ist-autosave" checked> √Ñnderungen automatisch speichern</label>
                        </div>
                    </div>

                    <!-- Data Table - IST values with SOLL comparison -->
                    <div class="analyse-table-container" style="max-height:500px; overflow-y:auto; overflow-x:auto;">
                        <table class="analyse-table" id="istTable">
                            <thead id="istTableHead">
                                <tr>
                                    <th>Raumtyp</th>
                                    <th>Raumkategorie</th>
                                    <th>Raum</th>
                                    <th>Nettofl√§che SOLL</th>
                                    <th>Nettofl√§che IST</th>
                                    <th>Bruttofl√§che SOLL</th>
                                    <th>Bruttofl√§che IST</th>
                                    <th>Aktionen</th>
                                </tr>
                            </thead>
                            <tbody id="istTableBody">
                                <tr>
                                    <td colspan="20" style="text-align:center; color:#666;">
                                        Keine Daten vorhanden. Klicken Sie auf "Daten laden".
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <!-- Pagination -->
                    <div style="margin-top:15px; display:flex; justify-content:space-between; align-items:center;">
                        <div>
                            <span id="istPaginationInfo">Seite 1 von 1</span>
                        </div>
                        <div>
                            <button class="btn btn-secondary" id="istPrevPage" onclick="loadIstData(currentIstPage - 1)" disabled>‚óÄ Zur√ºck</button>
                            <button class="btn btn-secondary" id="istNextPage" onclick="loadIstData(currentIstPage + 1)" disabled>Weiter ‚ñ∂</button>
                        </div>
                    </div>

                </section>

                <!-- IFC Data Source -->
                <section class="card">
                    <h2>IFC Datenquelle <span style="font-size:0.7em; color:#666;">(Coming Soon)</span></h2>
                    <p>W√§hlen Sie eine IFC-Datei aus, um IST-Werte automatisch zu extrahieren.</p>

                    <div class="form-group">
                        <label for="istIfcFile">IFC-Datei mit IfcSpaces:</label>
                        <select id="istIfcFile" class="form-control">
                            <option value="">-- IFC ausw√§hlen nach "Dateien laden" in Einstellungen --</option>
                        </select>
                    </div>

                    <div style="margin-top:15px;">
                        <button class="btn btn-primary" onclick="extractIstFromIfc()" title="Coming Soon">üìä IST aus IFC extrahieren</button>
                        <button class="btn btn-secondary" onclick="syncIstFromIfc()" title="Coming Soon">üîÑ IST aus IFC aktualisieren</button>
                    </div>
                    <div id="ifcExtractionResult" class="result"></div>
                </section>

            </div> <!-- END TAB AUSGEF√úHRT -->
            <!-- ========================================================= -->
            <!-- TAB 2 ‚Äì ANALYSE (SOLL/IST + ZUSAMMENFASSUNG)              -->
            <!-- ========================================================= -->
            <div id="tab-analyse" class="tab-content">

                <!-- KPI Summary Widget -->
                <section class="card kpi-widget">
                    <h2>√úbersicht</h2>
                    <div class="kpi-container">
                        <div class="kpi-item">
                            <span class="kpi-label">SOLL Gesamt</span>
                            <span class="kpi-value" id="kpiSollTotal">-</span>
                        </div>
                        <div class="kpi-item">
                            <span class="kpi-label">IST Gesamt</span>
                            <span class="kpi-value" id="kpiIstTotal">-</span>
                        </div>
                        <div class="kpi-item">
                            <span class="kpi-label">Abweichung</span>
                            <span class="kpi-value" id="kpiDeviation">-</span>
                        </div>
                        <div class="kpi-item kpi-status-ok">
                            <span class="kpi-label">Erf√ºllt</span>
                            <span class="kpi-value" id="kpiOkCount">0</span>
                        </div>
                        <div class="kpi-item kpi-status-under">
                            <span class="kpi-label">Unterschritten</span>
                            <span class="kpi-value" id="kpiUnderCount">0</span>
                        </div>
                        <div class="kpi-item kpi-status-over">
                            <span class="kpi-label">√úberschritten</span>
                            <span class="kpi-value" id="kpiOverCount">0</span>
                        </div>
                    </div>
                </section>

                <!-- Element Selection -->
                <section class="card">
                    <h2>Analyseelement ausw√§hlen</h2>
                    <div class="form-group">
                        <label for="analysisElementSelect">Element f√ºr Analyse ausw√§hlen *:</label>
                        <select id="analysisElementSelect" class="form-control" style="width:300px;" onchange="onAnalysisElementChange()">
                            <option value="">-- Element ausw√§hlen --</option>
                            <optgroup label="Fl√§che">
                                <option value="NetArea">Nettofl√§che</option>
                                <option value="GrossArea">Bruttofl√§che</option>
                            </optgroup>
                        </select>
                        <small>W√§hlen Sie ein Element f√ºr die Abweichungsanalyse</small>
                    </div>
                </section>

                <!-- Tolerance Configuration -->
                <section class="card">
                    <h2>Toleranz-Einstellungen</h2>
                    <div class="tolerance-controls">
                        <div class="form-group" style="display:inline-block; margin-right:20px;">
                            <label for="toleranceMin">Minimum Toleranz (%):</label>
                            <input type="number" id="toleranceMin" class="form-control" value="-10" min="-100" max="0" style="width:100px;">
                        </div>
                        <div class="form-group" style="display:inline-block; margin-right:20px;">
                            <label for="toleranceMax">Maximum Toleranz (%):</label>
                            <input type="number" id="toleranceMax" class="form-control" value="10" min="0" max="100" style="width:100px;">
                        </div>
                        <button class="btn btn-primary" onclick="applyToleranceSettings()">Toleranz anwenden</button>
                    </div>
                </section>

                <!-- Filter and Search Controls -->
                <section class="card">
                    <h2>Filter & Suche</h2>
                    <div class="filter-controls" style="display:flex; flex-wrap:wrap; gap:15px; align-items:flex-end;">
                        <div class="filter-buttons">
                            <button class="btn btn-secondary filter-btn active" data-filter="all" onclick="filterAnalyseTable('all')">Alle</button>
                            <button class="btn btn-secondary filter-btn" data-filter="ok" onclick="filterAnalyseTable('ok')">‚úÖ Erf√ºllt</button>
                            <button class="btn btn-secondary filter-btn" data-filter="under" onclick="filterAnalyseTable('under')">‚ö†Ô∏è Unterschritten</button>
                            <button class="btn btn-secondary filter-btn" data-filter="over" onclick="filterAnalyseTable('over')">üìä √úberschritten</button>
                        </div>
                        <div class="form-group" style="margin-bottom:0;">
                            <label for="analyseRoomCategoryFilter">Raumkategorie:</label>
                            <select id="analyseRoomCategoryFilter" class="form-control" style="width:180px;" onchange="onAnalysisFilterChange()">
                                <option value="">-- Alle --</option>
                            </select>
                        </div>
                        <div class="search-box">
                            <label for="analyseSearch">Suche:</label>
                            <input type="text" id="analyseSearch" class="form-control" placeholder="Raumtyp, Kategorie, Name..." style="width:200px;" onkeyup="onAnalysisFilterChange()">
                        </div>
                    </div>
                </section>

                <!-- Analysis Table -->
                <section class="card">
                    <h2>Analysetabelle</h2>
                    <p id="analyseTableDescription">W√§hlen Sie ein Analyseelement aus, um die Abweichungsanalyse anzuzeigen.</p>

                    <div class="analyse-table-container" style="max-height:500px; overflow-y:auto; overflow-x:auto;">
                        <table class="analyse-table" id="analyseTable">
                            <thead id="analyseTableHead">
                                <tr>
                                    <th onclick="sortAnalyseTable(0)">Raumtyp ‚Üï</th>
                                    <th onclick="sortAnalyseTable(1)">Raumkategorie ‚Üï</th>
                                    <th onclick="sortAnalyseTable(2)">Raumname ‚Üï</th>
                                    <th onclick="sortAnalyseTable(3)">SOLL ‚Üï</th>
                                    <th onclick="sortAnalyseTable(4)">IST ‚Üï</th>
                                    <th onclick="sortAnalyseTable(5)">Abweichung (%) ‚Üï</th>
                                    <th onclick="sortAnalyseTable(6)">Abweichung ‚Üï</th>
                                    <th onclick="sortAnalyseTable(7)">Status ‚Üï</th>
                                    <th>Kommentar IST</th>
                                    <th onclick="sortAnalyseTable(9)">Letzte Aktualisierung ‚Üï</th>
                                </tr>
                            </thead>
                            <tbody id="analyseTableBody">
                                <tr>
                                    <td colspan="10" style="text-align:center; color:#666;">
                                        W√§hlen Sie ein Analyseelement aus.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>

                    <div style="margin-top:15px;">
                        <button class="btn btn-primary" onclick="loadAnalyseData()">üì• Daten laden</button>
                        <button class="btn btn-secondary" onclick="recalculateAndSaveDeviations()">üìä Abweichungen berechnen & speichern</button>
                    </div>
                    <div id="analyseResult" class="result"></div>
                </section>

                <!-- Soll/Ist-Pr√ºfung (moved from Raumbuch tab) -->
                <section class="card">
                    <h2>Pset Raumbuch </h2>
                    <p>Die Differenz in der Fl√§che zwischen Raumprogramm (SOLL) und Raumbuch (IST) wird f√ºr jede Raumkategorie in Pset Raumbuch geschrieben.</p>

                    <button class="btn btn-primary" onclick="writePset()">üìù Pset erstellen</button>
                    <button class="btn btn-secondary" onclick="updatePset()">üîÑ Pset aktualisieren</button>
                    <button class="btn btn-secondary" onclick="deletePset()">üóëÔ∏è Pset l√∂schen</button>
                    <button class="btn btn-secondary" onclick="openIn3DViewer()">üîç In 3D-Viewer √∂ffnen</button>
                    <div id="step4Result" class="result"></div>
                </section>

            </div> <!-- END TAB 2 (ANALYSE) -->
            <!-- ========================================================= -->
            <!-- TAB 3 ‚Äì AUSSTATTUNGSVERWALTUNG (STEP 5)                   -->
            <!-- ========================================================= -->
            <div id="tab-ausstattung" class="tab-content">

                <section class="card">

                    <!-- Subsection: Room sheets -->
                    <div class="subsection">
                        <h2>Raumbl√§tter erstellen</h2>
                        <p>Erstellt ein Raumblatt pro Raum im Raumbuch</p>

                        <button class="btn btn-primary" onclick="createRoomSheets()">üìã Raumbl√§tter erstellen</button>
                        <button class="btn btn-secondary" onclick="deleteRoomLists()">üóëÔ∏è Raumbl√§tter l√∂schen</button>

                        <div id="step5_1Result" class="result"></div>
                    </div>

                    <hr style="margin:20px 0;">

                    <!-- Subsection: Inventory -->
                    <div class="subsection">
                        <h2>Ausstattung erstellen</h2>
                        <p>Raumbl√§tter mit Ausstattungen f√ºllen</p>

                        <div class="form-group">
                            <label for="inventoryFolder">Zielordner f√ºr IFC-Dateien:</label>
                            <select id="inventoryFolder" class="form-control">
                                <option value="">-- Klicken Sie auf "Projektdaten laden" --</option>
                            </select>
                        </div>

                        <button class="btn btn-primary" onclick="loadIfcFilesForInventory()">üìÅ IFC-Dateien laden</button>

                        <div class="form-group">
                            <label>IFC-Dateien ausw√§hlen:</label>
                            <div id="ifcFilesList" class="file-selection-list">
                                <p style="color:#666;">Klicken Sie auf "IFC-Dateien laden"</p>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="psetPartialName">Pset Name (teilweise):</label>
                            <input type="text" id="psetPartialName" class="form-control" value="Plancal nova">
                        </div>

                        <div class="form-group">
                            <label for="roomPropertyName">Eigenschaft f√ºr Raumnummer:</label>
                            <input type="text" id="roomPropertyName" class="form-control" value="Room Nbr">
                        </div>

                        <button class="btn btn-primary" onclick="discoverProperties()">üîç Eigenschaften laden</button>

                        <div class="form-group">
                            <label for="additionalProperties">Zus√§tzliche Eigenschaften:</label>
                            <select id="additionalProperties" class="form-control" multiple size="8">
                                <option value="">-- Klicken Sie auf "Verf√ºgbare Eigenschaften laden" --</option>
                            </select>
                        </div>

                        <button class="btn btn-primary" onclick="fillInventory()">üì¶ Ausstattungen erstellen</button>
                        <button class="btn btn-secondary" onclick="updateInventory()">üîÑ Ausstattungen aktualisieren</button>

                        <div id="step5_2Result" class="result"></div>

                    </div>
                </section>

            </div> <!-- END TAB 2 -->
            <!-- ========================================================= -->
            <!-- TAB 3 ‚Äì BCF TOPIC (STEP 2)                                -->
            <!-- ========================================================= -->
            <div id="tab-bcf" class="tab-content">

                <section class="card">
                    <h2>BCF-Themen erstellen</h2>

                    <div class="form-group">
                        <label for="bcfTitle">Titel:</label>
                        <input type="text" id="bcfTitle" class="form-control" value="Raumbuch">
                    </div>

                    <div class="form-group">
                        <label for="bcfAssignees">Zuweisen an (E-Mail):</label>
                        <select id="bcfAssignees" class="form-control" multiple size="5">
                            <option value="">-- Klicken Sie auf "Projektdaten laden" --</option>
                        </select>
                        <small>Mehrfachauswahl: Strg/Cmd</small>
                    </div>

                    <div class="form-group">
                        <label for="bcfDescription">Beschreibung:</label>
                        <textarea id="bcfDescription" class="form-control" rows="3">
Das Raumprogramm wurde erstellt. Den Link zum Ordner f√ºr die weitere Arbeit finden Sie unter ‚ÄûVerweise‚Äù.
                </textarea>
                    </div>

                    <div class="form-group">
                        <label for="bcfPriority">Priorit√§t:</label>
                        <select id="bcfPriority" class="form-control">
                            <option value="">-- Keine Priorit√§t --</option>
                            <option value="Low">Niedrig</option>
                            <option value="Normal">Normal</option>
                            <option value="High">Hoch</option>
                            <option value="Critical">Kritisch</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="bcfDueDate">F√§lligkeitsdatum:</label>
                        <input type="date" id="bcfDueDate" class="form-control">
                        <small>Wird automatisch auf heute gesetzt</small>
                    </div>

                    <button class="btn btn-primary" onclick="createBcfTopic()">üìã BCF-Themen erstellen</button>

                    <div id="step2Result" class="result"></div>

                </section>

            </div> <!-- END TAB 3 -->

        </main>



        <footer>
            <p>Raumbuch Manager v2.1 - Buildingpoint Schweiz AG</p>
            <p id="apiEndpoint" style="display: none;"></p>
        </footer>
    </div>

    <script>
        // Use relative URLs to work in both local development and Azure deployment
        const API_BASE = '/api/raumbuch';
        const API_PROJECT = '/api/project';
        const API_ANALYSIS = '/api/analysis';
        const API_BUILDING = '/api/building';

        // Display the current API endpoint in footer (hidden element for debugging)
        const apiEndpointEl = document.getElementById('apiEndpoint');
        if (apiEndpointEl) {
            apiEndpointEl.textContent = `API: ${window.location.origin}`;
        }
        
        // ====================================================================
        // BUILDING MANAGEMENT - Multi-building system
        // ====================================================================
        
        // Current selected building
        let currentBuildingId = null;
        
        /**
         * Load list of buildings from the database
         */
        async function loadBuildingList() {
            try {
                const response = await fetch(`${API_BUILDING}/list`);
                const data = await response.json();
                
                if (response.ok && data.success) {
                    const buildingSelect = document.getElementById('buildingSelect');
                    const raumprogramBuildingSelect = document.getElementById('raumprogram-building');
                    
                    let options = '<option value="">-- Geb√§ude ausw√§hlen --</option>';
                    data.buildings.forEach(b => {
                        const code = b.buildingCode ? ` (${b.buildingCode})` : '';
                        options += `<option value="${b.buildingID}">${escapeHtml(b.buildingName)}${code}</option>`;
                    });
                    
                    if (buildingSelect) buildingSelect.innerHTML = options;
                    if (raumprogramBuildingSelect) raumprogramBuildingSelect.innerHTML = options;
                    
                    // Restore last selected building from local storage
                    const savedBuildingId = localStorage.getItem('selectedBuildingId');
                    if (savedBuildingId) {
                        if (buildingSelect) buildingSelect.value = savedBuildingId;
                        if (raumprogramBuildingSelect) raumprogramBuildingSelect.value = savedBuildingId;
                        currentBuildingId = parseInt(savedBuildingId);
                    }
                    
                    showResult('buildingResult', 'success', `‚úÖ ${data.buildings.length} Geb√§ude geladen`);
                } else {
                    showResult('buildingResult', 'error', `‚ùå ${data.message || 'Fehler beim Laden'}`);
                }
            } catch (error) {
                console.error('Error loading buildings:', error);
                showResult('buildingResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Create a new building
         */
        async function createBuilding() {
            const name = document.getElementById('newBuildingName').value.trim();
            const code = document.getElementById('newBuildingCode').value.trim();
            
            if (!name) {
                showResult('buildingResult', 'error', '‚ö†Ô∏è Bitte geben Sie einen Geb√§udenamen ein');
                return;
            }
            
            showResult('buildingResult', 'loading', '‚è≥ Erstelle Geb√§ude...');
            
            try {
                const response = await fetch(`${API_BUILDING}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        buildingName: name,
                        buildingCode: code,
                        userId: getCurrentUserId()
                    })
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    showResult('buildingResult', 'success', `‚úÖ Geb√§ude "${name}" erstellt`);
                    
                    // Clear input fields
                    document.getElementById('newBuildingName').value = '';
                    document.getElementById('newBuildingCode').value = '';
                    
                    // Reload building list and select the new one
                    await loadBuildingList();
                    document.getElementById('buildingSelect').value = data.building.buildingID;
                    await loadBuildingDetails();
                } else {
                    showResult('buildingResult', 'error', `‚ùå ${data.message || 'Fehler beim Erstellen'}`);
                }
            } catch (error) {
                console.error('Error creating building:', error);
                showResult('buildingResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Load details of the selected building
         */
        async function loadBuildingDetails() {
            const buildingId = document.getElementById('buildingSelect').value;
            
            if (!buildingId) {
                currentBuildingId = null;
                localStorage.removeItem('selectedBuildingId');
                // Clear form fields but keep section visible
                clearBuildingForm();
                return;
            }
            
            try {
                const response = await fetch(`${API_BUILDING}/${buildingId}`);
                const data = await response.json();
                
                if (response.ok && data.success) {
                    const b = data.building;
                    currentBuildingId = b.buildingID;
                    localStorage.setItem('selectedBuildingId', b.buildingID);
                    
                    // Populate form fields
                    document.getElementById('editBuildingName').value = b.buildingName || '';
                    document.getElementById('editBuildingCode').value = b.buildingCode || '';
                    document.getElementById('editBuildingOwner').value = b.owner || '';
                    document.getElementById('editBuildingCreator').value = b.creator || '';
                    document.getElementById('editBuildingDescription').value = b.description || '';
                    document.getElementById('editAddressStreet').value = b.addressStreet || '';
                    document.getElementById('editAddressPostalCode').value = b.addressPostalCode || '';
                    document.getElementById('editAddressCity').value = b.addressCity || '';
                    document.getElementById('editAddressCountry').value = b.addressCountry || 'Switzerland';
                    // IFC fields are now hidden inputs
                    document.getElementById('editIFCEnabled').value = b.ifcEnabled ? 'true' : 'false';
                    document.getElementById('editIFCProjectGUID').value = b.ifcProjectGUID || '';
                    document.getElementById('editIFCBuildingGUID').value = b.ifcBuildingGUID || '';
                    document.getElementById('editIFCFileUrl').value = b.ifcFileUrl || '';
                    document.getElementById('editCoordinateSystem').value = b.coordinateSystem || 'Switzerland/CH1903+ (LV95) ‚Äì EPSG:2056';
                    document.getElementById('editLocalOriginX').value = b.localOriginX || 0;
                    document.getElementById('editLocalOriginY').value = b.localOriginY || 0;
                    document.getElementById('editLocalOriginZ').value = b.localOriginZ || 0;
                    document.getElementById('editLogoUrl').value = b.logoUrl || '';
                    
                    // Update logo preview
                    const logoPreview = document.getElementById('buildingLogoPreview');
                    if (b.logoUrl) {
                        logoPreview.src = b.logoUrl;
                        logoPreview.style.display = 'block';
                    } else {
                        logoPreview.style.display = 'none';
                    }
                    
                    // Also update the Raumprogramm building selector
                    const raumprogramSelect = document.getElementById('raumprogram-building');
                    if (raumprogramSelect) {
                        raumprogramSelect.value = buildingId;
                    }
                    
                    showResult('buildingDetailsResult', 'success', '‚úÖ Geb√§ude geladen');
                } else {
                    showResult('buildingResult', 'error', `‚ùå ${data.message || 'Fehler beim Laden'}`);
                }
            } catch (error) {
                console.error('Error loading building details:', error);
                showResult('buildingResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Clear building form fields
         */
        function clearBuildingForm() {
            document.getElementById('editBuildingName').value = '';
            document.getElementById('editBuildingCode').value = '';
            document.getElementById('editBuildingOwner').value = '';
            document.getElementById('editBuildingCreator').value = '';
            document.getElementById('editBuildingDescription').value = '';
            document.getElementById('editAddressStreet').value = '';
            document.getElementById('editAddressPostalCode').value = '';
            document.getElementById('editAddressCity').value = '';
            document.getElementById('editAddressCountry').value = 'Switzerland';
            document.getElementById('editIFCEnabled').value = 'false';
            document.getElementById('editIFCProjectGUID').value = '';
            document.getElementById('editIFCBuildingGUID').value = '';
            document.getElementById('editIFCFileUrl').value = '';
            document.getElementById('editCoordinateSystem').value = 'Switzerland/CH1903+ (LV95) ‚Äì EPSG:2056';
            document.getElementById('editLocalOriginX').value = 0;
            document.getElementById('editLocalOriginY').value = 0;
            document.getElementById('editLocalOriginZ').value = 0;
            document.getElementById('editLogoUrl').value = '';
            const logoPreview = document.getElementById('buildingLogoPreview');
            logoPreview.style.display = 'none';
        }
        
        /**
         * Save building changes
         */
        async function saveBuilding() {
            if (!currentBuildingId) {
                showResult('buildingDetailsResult', 'error', '‚ö†Ô∏è Kein Geb√§ude ausgew√§hlt');
                return;
            }
            
            showResult('buildingDetailsResult', 'loading', '‚è≥ Speichere...');
            
            try {
                // IFC fields are now stored as hidden inputs
                const ifcEnabledEl = document.getElementById('editIFCEnabled');
                const ifcEnabled = ifcEnabledEl.value === 'true' || ifcEnabledEl.checked === true;
                
                const updateData = {
                    buildingName: document.getElementById('editBuildingName').value,
                    buildingCode: document.getElementById('editBuildingCode').value,
                    owner: document.getElementById('editBuildingOwner').value,
                    creator: document.getElementById('editBuildingCreator').value,
                    description: document.getElementById('editBuildingDescription').value,
                    addressStreet: document.getElementById('editAddressStreet').value,
                    addressPostalCode: document.getElementById('editAddressPostalCode').value,
                    addressCity: document.getElementById('editAddressCity').value,
                    addressCountry: document.getElementById('editAddressCountry').value,
                    ifcEnabled: ifcEnabled,
                    ifcProjectGUID: document.getElementById('editIFCProjectGUID').value,
                    ifcBuildingGUID: document.getElementById('editIFCBuildingGUID').value,
                    ifcFileUrl: document.getElementById('editIFCFileUrl').value,
                    coordinateSystem: document.getElementById('editCoordinateSystem').value,
                    localOriginX: parseFloat(document.getElementById('editLocalOriginX').value) || 0,
                    localOriginY: parseFloat(document.getElementById('editLocalOriginY').value) || 0,
                    localOriginZ: parseFloat(document.getElementById('editLocalOriginZ').value) || 0,
                    logoUrl: document.getElementById('editLogoUrl').value,
                    userId: getCurrentUserId()
                };
                
                const response = await fetch(`${API_BUILDING}/${currentBuildingId}`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updateData)
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    showResult('buildingDetailsResult', 'success', '‚úÖ Geb√§ude gespeichert');
                    // Reload building list to update dropdown labels
                    await loadBuildingList();
                    document.getElementById('buildingSelect').value = currentBuildingId;
                } else {
                    showResult('buildingDetailsResult', 'error', `‚ùå ${data.message || 'Fehler beim Speichern'}`);
                }
            } catch (error) {
                console.error('Error saving building:', error);
                showResult('buildingDetailsResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Delete a building
         */
        async function deleteBuilding() {
            if (!currentBuildingId) {
                showResult('buildingDetailsResult', 'error', '‚ö†Ô∏è Kein Geb√§ude ausgew√§hlt');
                return;
            }
            
            const buildingName = document.getElementById('editBuildingName').value;
            const confirmed = confirm(`Sind Sie sicher, dass Sie das Geb√§ude "${buildingName}" und alle zugeh√∂rigen Daten (R√§ume, Inventar) l√∂schen m√∂chten?\n\nDiese Aktion kann nicht r√ºckg√§ngig gemacht werden!`);
            
            if (!confirmed) return;
            
            showResult('buildingDetailsResult', 'loading', '‚è≥ L√∂sche Geb√§ude...');
            
            try {
                const response = await fetch(`${API_BUILDING}/${currentBuildingId}?userId=${encodeURIComponent(getCurrentUserId() || '')}`, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    showResult('buildingResult', 'success', `‚úÖ Geb√§ude "${buildingName}" gel√∂scht`);
                    // Clear the form but keep section visible
                    clearBuildingForm();
                    currentBuildingId = null;
                    localStorage.removeItem('selectedBuildingId');
                    await loadBuildingList();
                } else {
                    showResult('buildingDetailsResult', 'error', `‚ùå ${data.message || 'Fehler beim L√∂schen'}`);
                }
            } catch (error) {
                console.error('Error deleting building:', error);
                showResult('buildingDetailsResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Refresh Trimble Connect data for the building
         */
        async function refreshTrimbleConnectData() {
            showResult('buildingDetailsResult', 'loading', '‚è≥ Lade Trimble Connect Daten...');
            
            // For now, just show a placeholder message
            // This would integrate with Trimble Connect API to fetch folders/users/groups
            document.getElementById('trimbleConnectInfo').innerHTML = `
                <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:15px;">
                    <div>
                        <strong>Ordner:</strong><br>
                        <small style="color:#666;">Keine Daten geladen</small>
                    </div>
                    <div>
                        <strong>Benutzer:</strong><br>
                        <small style="color:#666;">Keine Daten geladen</small>
                    </div>
                    <div>
                        <strong>Gruppen:</strong><br>
                        <small style="color:#666;">Keine Daten geladen</small>
                    </div>
                </div>
            `;
            
            showResult('buildingDetailsResult', 'success', '‚úÖ Trimble Connect Daten aktualisiert');
        }
        
        /**
         * Handle building change in Raumprogramm
         */
        function onBuildingChange() {
            const buildingId = document.getElementById('raumprogram-building').value;
            const messageEl = document.getElementById('buildingRequiredMessage');
            
            if (!buildingId) {
                messageEl.style.display = 'inline';
                currentBuildingId = null;
                localStorage.removeItem('selectedBuildingId');
            } else {
                messageEl.style.display = 'none';
                currentBuildingId = parseInt(buildingId);
                localStorage.setItem('selectedBuildingId', buildingId);
                
                // Also sync with Einstellungen tab
                const settingsSelect = document.getElementById('buildingSelect');
                if (settingsSelect) {
                    settingsSelect.value = buildingId;
                }
            }
        }
        
        /**
         * Check if building is selected before loading data
         */
        function checkBuildingSelected() {
            const buildingId = document.getElementById('raumprogram-building')?.value;
            if (!buildingId) {
                const messageEl = document.getElementById('buildingRequiredMessage');
                if (messageEl) messageEl.style.display = 'inline';
                showResult('raumprogramResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie ein Geb√§ude.');
                return false;
            }
            return true;
        }
        
        /**
         * Check if a building exists in the system (for create operations)
         * Shows error if no building exists - user must create one first
         */
        function requireBuilding(resultElementId = 'raumprogramResult') {
            if (!currentBuildingId) {
                showResult(resultElementId, 'error', '‚ö†Ô∏è Bitte erstellen Sie zuerst ein Geb√§ude in den Einstellungen, bevor Sie Daten hinzuf√ºgen.');
                return false;
            }
            return true;
        }
        
        /**
         * Get current building ID
         */
        function getCurrentBuildingId() {
            return currentBuildingId;
        }
        
        /**
         * Open the predefined folder in Trimble Connect
         */
        function openPredefinedFolder() {
            const folderSelect = document.getElementById('targetFolder');
            const selectedFolderId = folderSelect.value;
            
            if (!selectedFolderId) {
                showResult('connectionResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie zuerst einen Ordner aus.');
                return;
            }
            
            // Get the project ID from trimbleConnect context or localStorage
            let projectId = trimbleConnect.projectId;
            if (!projectId) {
                // Try to get from localStorage or other source
                projectId = localStorage.getItem('trimbleProjectId') || 'y7-N0uBcXNI'; // Default fallback
            }
            
            const url = `https://web.connect.trimble.com/projects/${projectId}/data/folder/${selectedFolderId}`;
            window.open(url, '_blank');
        }
        
        /**
         * Upload logo to Azure and update URL
         */
        async function uploadLogo() {
            const fileInput = document.getElementById('logoFileInput');
            const file = fileInput.files[0];
            
            if (!file) {
                showResult('connectionResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie eine Datei aus.');
                return;
            }
            
            if (!currentBuildingId) {
                showResult('connectionResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie zuerst ein Geb√§ude aus.');
                return;
            }
            
            showResult('connectionResult', 'loading', '‚è≥ Logo wird hochgeladen...');
            
            try {
                const formData = new FormData();
                formData.append('file', file);
                formData.append('buildingId', currentBuildingId);
                
                const response = await fetch(`${API_BUILDING}/upload-logo`, {
                    method: 'POST',
                    body: formData
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Update the logo URL field
                    document.getElementById('editLogoUrl').value = data.logoUrl;
                    
                    // Update the preview
                    const logoPreview = document.getElementById('buildingLogoPreview');
                    logoPreview.src = data.logoUrl;
                    logoPreview.style.display = 'block';
                    
                    showResult('connectionResult', 'success', '‚úÖ Logo erfolgreich hochgeladen');
                } else {
                    showResult('connectionResult', 'error', `‚ùå ${data.message || 'Fehler beim Hochladen'}`);
                }
            } catch (error) {
                console.error('Error uploading logo:', error);
                showResult('connectionResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
            
            // Clear the file input
            fileInput.value = '';
        }
        
        /**
         * Save configuration (Konfiguration speichern)
         * Saves to JSON and reads IFC properties if IFC file is selected
         */
        async function saveConfiguration() {
            if (!currentBuildingId) {
                showResult('connectionResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie zuerst ein Geb√§ude aus.');
                return;
            }
            
            showResult('connectionResult', 'loading', '‚è≥ Konfiguration wird gespeichert...');
            
            try {
                const ifcFileSelect = document.getElementById('ifcFile');
                const ifcFileName = ifcFileSelect.value;
                const targetFolder = document.getElementById('targetFolder').value;
                
                // Prepare configuration data
                const configData = {
                    buildingId: currentBuildingId,
                    predefinedFolder: targetFolder,
                    ifcSpacesFile: ifcFileName,
                    userId: getCurrentUserId()
                };
                
                // If IFC file is selected, we need to read IFC properties
                if (ifcFileName) {
                    configData.ifcEnabled = true;
                    configData.ifcFileUrl = ifcFileName;
                    
                    // Store the IFC file URL in hidden fields
                    document.getElementById('editIFCFileUrl').value = ifcFileName;
                    document.getElementById('editIFCEnabled').value = 'true';
                    
                    // Try to read IFC GUIDs from the file via API
                    try {
                        const ifcResponse = await fetch(`/api/building/read-ifc-properties?buildingId=${currentBuildingId}&ifcFileName=${encodeURIComponent(ifcFileName)}`);
                        const ifcData = await ifcResponse.json();
                        
                        if (ifcResponse.ok && ifcData.success) {
                            if (ifcData.projectGUID) {
                                document.getElementById('editIFCProjectGUID').value = ifcData.projectGUID;
                                configData.ifcProjectGUID = ifcData.projectGUID;
                            }
                            if (ifcData.buildingGUID) {
                                document.getElementById('editIFCBuildingGUID').value = ifcData.buildingGUID;
                                configData.ifcBuildingGUID = ifcData.buildingGUID;
                            }
                            if (ifcData.multipleBuildingsError) {
                                showResult('connectionResult', 'error', '‚ö†Ô∏è Fehler: Mehrere IfcBuilding-Objekte gefunden. Bitte w√§hlen Sie eine IFC-Datei mit nur einem Geb√§ude.');
                                return;
                            }
                        }
                    } catch (ifcError) {
                        console.warn('Could not read IFC properties:', ifcError);
                        // Continue saving without IFC GUIDs - they can be added later
                    }
                } else {
                    configData.ifcEnabled = false;
                    document.getElementById('editIFCEnabled').value = 'false';
                }
                
                // Save the configuration
                const response = await fetch(`${API_BUILDING}/${currentBuildingId}/save-configuration`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(configData)
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    // Also save to building record
                    await saveBuilding();
                    showResult('connectionResult', 'success', '‚úÖ Konfiguration gespeichert');
                } else {
                    showResult('connectionResult', 'error', `‚ùå ${data.message || 'Fehler beim Speichern'}`);
                }
            } catch (error) {
                console.error('Error saving configuration:', error);
                showResult('connectionResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        // ====================================================================
        // TRIMBLE CONNECT WORKSPACE & EXTENSION API INTEGRATION
        // ====================================================================

        // Store authentication and context from Trimble Connect
        let trimbleConnect = {
            accessToken: null,
            projectId: null,
            userId: null,  // Current user ID for authorization
            isEmbedded: false,
            isWorkspaceApp: false, // New flag for Workspace API
            consentStatus: 'pending' // pending, granted, denied
        };

        /**
         * Get the current user ID for authorization
         * Returns the user ID from Trimble Connect context, or null if not available
         */
        function getCurrentUserId() {
            return trimbleConnect.userId || null;
        }

        // Helper functions to expose to app.js for Workspace API integration
        window.setWorkspaceToken = function (token) {
            console.log('Setting workspace token from app.js');
            trimbleConnect.accessToken = token;
            trimbleConnect.isWorkspaceApp = true;
            trimbleConnect.consentStatus = 'granted';

            // Try to auto-load configs if we also have project ID
            tryAutoLoadConfigs();
        };

        window.setWorkspaceUserId = function (userId) {
            console.log('Setting workspace user ID from app.js:', userId);
            trimbleConnect.userId = userId;
        };

        window.setWorkspaceProjectId = function (projectId) {
            console.log('Setting workspace project ID from app.js:', projectId);
            trimbleConnect.projectId = projectId;
            trimbleConnect.isWorkspaceApp = true;

            // Try to auto-load configs if we also have token
            tryAutoLoadConfigs();
        };

        // Auto-load saved configurations when both token and projectId are available
        async function tryAutoLoadConfigs() {
            const token = getToken();
            const projectId = getProjectId();

            if (token && projectId) {
                console.log('Auto-loading saved configurations for project:', projectId);
                try {
                    await loadSavedConfigurations(projectId);
                    showResult('connectionResult', 'success', '‚úÖ Konfigurationen geladen. Klicken Sie "Projektdaten laden" f√ºr weitere Daten.');
                } catch (error) {
                    console.error('Error auto-loading configurations:', error);
                }
            }
        }

        // Check if running inside Trimble Connect as an extension
        function isInsideTrimbleConnect() {
            try {
                return window.parent !== window &&
                    window.parent.TrimbleConnectWorkspace !== undefined &&
                    window.parent.TrimbleConnectWorkspace !== null;
            } catch (e) {
                return false;
            }
        }

        // Initialize Trimble Connect Extension API
        function initializeTrimbleConnectExtension() {
            // Check if Workspace API is being initialized (app.js will handle authentication)
            // Check for both old WorkspaceAPI and new TrimbleConnectWorkspace
            if (window.WorkspaceAPI || window.TrimbleConnectWorkspace) {
                console.log('Workspace API detected - waiting for app.js to initialize');
                trimbleConnect.isEmbedded = true;
                trimbleConnect.isWorkspaceApp = true;
                // app.js will call setWorkspaceToken and setWorkspaceProjectId
                return;
            }

            trimbleConnect.isEmbedded = isInsideTrimbleConnect();

            if (trimbleConnect.isEmbedded) {
                console.log('Running inside Trimble Connect - initializing legacy extension API');

                try {
                    const workspace = window.parent.TrimbleConnectWorkspace;

                    // Request permission to use access token
                    workspace.extension.requestPermission()
                        .then(result => {
                            console.log('Extension permission result:', result);

                            if (result === 'granted') {
                                trimbleConnect.consentStatus = 'granted';
                                console.log('Permission granted - waiting for accessToken event');
                            } else if (result === 'denied') {
                                trimbleConnect.consentStatus = 'denied';
                                console.error('Permission denied by user');
                                showResult('connectionResult', 'error', '‚ùå Zugriff verweigert. Bitte erlauben Sie den Zugriff in den Extension-Einstellungen.');
                            } else if (result === 'pending') {
                                trimbleConnect.consentStatus = 'pending';
                                console.log('Permission pending - user needs to grant consent');
                            }
                        })
                        .catch(error => {
                            console.error('Error requesting permission:', error);
                            showResult('connectionResult', 'error', '‚ùå Fehler beim Anfordern der Berechtigung: ' + error.message);
                        });

                    // Listen for accessToken event (fired when token is available/refreshed)
                    workspace.extension.addEventListener('accessToken', (event) => {
                        console.log('Received accessToken event from Trimble Connect');

                        if (event && event.detail && event.detail.token) {
                            trimbleConnect.accessToken = event.detail.token;
                            trimbleConnect.consentStatus = 'granted';
                            console.log('Access token received and stored');

                            // Automatically load project data when token is received
                            if (trimbleConnect.projectId) {
                                console.log('Auto-loading project data with token and project ID');
                                loadProjectData().catch(error => {
                                    console.error('Error auto-loading project data:', error);
                                    showResult('connectionResult', 'error', '‚ö† Fehler beim automatischen Laden der Projektdaten. Bitte versuchen Sie "Projektdaten laden".');
                                });
                            }
                        } else {
                            console.error('Invalid accessToken event - missing token');
                        }
                    });

                    // Get project context (project ID)
                    workspace.getContext()
                        .then(context => {
                            console.log('Trimble Connect context:', context);
                            if (context && context.project && context.project.id) {
                                trimbleConnect.projectId = context.project.id;
                                console.log('Project ID retrieved from context:', trimbleConnect.projectId);

                                // If we already have the token, auto-load project data
                                if (trimbleConnect.accessToken) {
                                    console.log('Auto-loading project data with both token and project ID');
                                    loadProjectData().catch(error => {
                                        console.error('Error auto-loading project data:', error);
                                        showResult('connectionResult', 'error', '‚ö† Fehler beim automatischen Laden der Projektdaten. Bitte versuchen Sie "Projektdaten laden".');
                                    });
                                }
                            } else {
                                console.warn('No project context available from Trimble Connect');
                            }
                        })
                        .catch(error => {
                            console.error('Error getting Trimble Connect context:', error);
                            showResult('connectionResult', 'error', '‚ö† Fehler beim Abrufen des Projekt-Kontexts von Trimble Connect.');
                        });

                } catch (error) {
                    console.error('Error initializing Trimble Connect Extension API:', error);
                    showResult('connectionResult', 'error', '‚ùå Fehler beim Initialisieren der Trimble Connect Extension API: ' + error.message);
                }
            } else {
                console.log('Not running inside Trimble Connect - standalone mode');
                // For local development/testing, fallback to manual input fields would be used
                // (currently commented out in HTML)
            }
        }

        // Initialize on page load - but after app.js has had a chance to load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeTrimbleConnectExtension);
        } else {
            // DOM already loaded, wait a bit for app.js to initialize
            setTimeout(initializeTrimbleConnectExtension, 100);
        }

        function openTab(tabId) {
            // hide all tabs
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

            // deactivate tabs
            document.querySelectorAll('.tc-tab').forEach(t => t.classList.remove('active'));

            // show selected tab
            document.getElementById(tabId).classList.add('active');

            // activate tab button
            const index = ['tab-raumprogramm', 'tab-ausgefuehrt', 'tab-analyse', 'tab-ausstattung', 'tab-bcf', 'tab-konfig'].indexOf(tabId);
            document.querySelectorAll('.tc-tab')[index].classList.add('active');

            // Auto-load data when Analyse tab is opened
            if (tabId === 'tab-analyse') {
                loadAnalysisElements();
            }

            // Auto-load data when Raumprogramm tab is opened
            if (tabId === 'tab-raumprogramm') {
                refreshAllMasterData();
            }
        }

        // Global configuration object
        let currentConfig = {
            projectId: '',
            projectName: '',
            targetFolder: null,
            files: {
                template: null,
                raumprogramm: null,
                ifcModel: null,
                raumbuch: null
            },
            bcfAssignees: [],
            // New: Summary data for Analyse tab
            zusammenfassung: [],
            // Tolerance settings
            toleranceMin: -10,
            toleranceMax: 10,
            toleranceProfiles: [
                { name: 'Strenge Kontrolle (¬±5%)', min: -5, max: 5 },
                { name: 'Normal (¬±10%)', min: -10, max: 10 },
                { name: 'Fr√ºhe Projektphase (¬±20%)', min: -20, max: 20 }
            ]
        };

        function getToken() {
            // Use Trimble Connect token if available (from Workspace API or Extension API)
            if ((trimbleConnect.isEmbedded || trimbleConnect.isWorkspaceApp) && trimbleConnect.accessToken) {
                return trimbleConnect.accessToken;
            }

            // Fallback to manual input field (for local development)
            const tokenField = document.getElementById('accessToken');
            if (tokenField) {
                return tokenField.value.trim();
            }

            return '';
        }

        function getProjectId() {
            // Use Trimble Connect project ID if available (from Workspace API or Extension API)
            if ((trimbleConnect.isEmbedded || trimbleConnect.isWorkspaceApp) && trimbleConnect.projectId) {
                return trimbleConnect.projectId;
            }

            // Fallback to manual input field (for local development)
            const projectField = document.getElementById('projectId');
            if (projectField) {
                return projectField.value.trim();
            }

            return '';
        }

        function getTargetFolder() {
            const select = document.getElementById('targetFolder');
            const value = select.value;
            console.log('getTargetFolder() - selected value:', value);
            console.log('getTargetFolder() - selected index:', select.selectedIndex);
            console.log('getTargetFolder() - selected option:', select.options[select.selectedIndex]);
            return value;
        }

        function showResult(elementId, type, message) {
            const el = document.getElementById(elementId);
            el.className = `result ${type}`;
            el.innerHTML = message;
        }

        // ====================================================================
        //  CONFIGURATION MANAGEMENT
        // ====================================================================

        async function loadProjectData() {
            const token = getToken();
            const projectId = getProjectId();

            // Skip validation if we're waiting for credentials from Workspace/Extension API
            if (!token || !projectId) {
                // If we have neither token nor project ID, show a loading message instead of error
                // The app is likely still initializing via Workspace API
                if (trimbleConnect.isEmbedded || trimbleConnect.isWorkspaceApp) {
                    console.log('Waiting for Workspace API to provide token and project ID...');
                    showResult('connectionResult', 'loading', '‚è≥ Warte auf Authentifizierung...');
                } else {
                    showResult('connectionResult', 'error', '‚ö† Bitte authentifizieren Sie sich √ºber Trimble Connect');
                }
                return;
            }

            showResult('connectionResult', 'loading', '‚è≥ Projektdaten werden geladen...');

            try {
                // Load folders
                console.log('Loading folders...');
                const foldersResponse = await fetch(`${API_PROJECT}/folders`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessToken: token, projectId: projectId })
                });

                const contentType = foldersResponse.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const textResponse = await foldersResponse.text();
                    console.error('Non-JSON response:', textResponse);
                    showResult('connectionResult', 'error', '‚ùå Ung√ºltige Antwort vom Server (kein JSON)');
                    return;
                }

                const foldersData = await foldersResponse.json();
                console.log('Folders response:', foldersData);

                if (foldersResponse.ok && foldersData.success) {
                    const select = document.getElementById('targetFolder');

                    if (!foldersData.folders || !Array.isArray(foldersData.folders)) {
                        showResult('connectionResult', 'error', '‚ùå Keine Ordner-Daten in Antwort');
                        return;
                    }

                    select.innerHTML = '<option value="">-- Ordner ausw√§hlen --</option>';

                    // Also populate inventory folder dropdown
                    const inventoryFolderSelect = document.getElementById('inventoryFolder');
                    if (inventoryFolderSelect) {
                        inventoryFolderSelect.innerHTML = '<option value="">-- Ordner ausw√§hlen --</option>';
                    }

                    if (foldersData.folders.length === 0) {
                        showResult('connectionResult', 'error', '‚ö† Keine Ordner gefunden');
                        return;
                    }

                    foldersData.folders.forEach((folder) => {
                        const option = document.createElement('option');
                        option.value = folder.id || '';
                        option.textContent = folder.path || folder.name || 'Unnamed folder';
                        option.dataset.name = folder.name || '';
                        option.dataset.path = folder.path || '';
                        select.appendChild(option);

                        // Add to inventory folder dropdown
                        if (inventoryFolderSelect) {
                            const inventoryOption = document.createElement('option');
                            inventoryOption.value = folder.id || '';
                            inventoryOption.textContent = folder.path || folder.name || 'Unnamed folder';
                            inventoryOption.dataset.name = folder.name || '';
                            inventoryOption.dataset.path = folder.path || '';
                            inventoryFolderSelect.appendChild(inventoryOption);
                        }
                    });

                    console.log('Folders loaded:', foldersData.folders.length);
                } else {
                    const errorMsg = foldersData.message || foldersData.Message || 'Unbekannter Fehler';
                    showResult('connectionResult', 'error', `‚ùå ${errorMsg}`);
                    return;
                }

                // Load users
                console.log('Loading users...');
                const usersResponse = await fetch(`${API_PROJECT}/users`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessToken: token, projectId: projectId })
                });

                const usersData = await usersResponse.json();
                console.log('Users response:', usersData);

                if (usersResponse.ok && usersData.success) {
                    const select = document.getElementById('bcfAssignees');
                    select.innerHTML = '';

                    if (!usersData.users || !Array.isArray(usersData.users)) {
                        showResult('connectionResult', 'warning', `‚úÖ ${foldersData.folders.length} Ordner geladen, aber keine Benutzer gefunden`);
                        return;
                    }

                    usersData.users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.email;
                        option.textContent = `${user.displayName} (${user.email})`;
                        option.dataset.id = user.id;
                        option.dataset.displayName = user.displayName;
                        select.appendChild(option);
                    });

                    console.log('Users loaded:', usersData.users.length);
                    showResult('connectionResult', 'success', `‚úÖ ${foldersData.folders.length} Ordner und ${usersData.users.length} Benutzer geladen!`);
                } else {
                    const errorMsg = usersData.message || usersData.Message || 'Unbekannter Fehler';
                    showResult('connectionResult', 'warning', `‚úÖ ${foldersData.folders.length} Ordner geladen, aber Fehler beim Laden der Benutzer: ${errorMsg}`);
                }

                // Load saved configurations from Azure
                await loadSavedConfigurations(projectId);
            } catch (error) {
                console.error('Error in loadProjectData:', error);
                showResult('connectionResult', 'error', '‚ùå Fehler bei der Authentifizierung mit Trimble Connect');
            }
        }

        async function loadSavedConfigurations(projectId) {
            try {
                console.log('Loading saved configurations for project:', projectId);
                const response = await fetch(`${API_PROJECT}/config/list`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ projectId: projectId })
                });

                if (!response.ok) {
                    console.warn('Failed to load configurations:', response.status);
                    return;
                }

                const data = await response.json();
                const configSelect = document.getElementById('savedConfigs');
                configSelect.innerHTML = '<option value="">-- Konfiguration ausw√§hlen --</option>';

                if (data.success && data.configurations && data.configurations.length > 0) {
                    data.configurations.forEach(config => {
                        const option = document.createElement('option');
                        option.value = config.name;
                        const dateStr = config.lastModified ? new Date(config.lastModified).toLocaleDateString('de-DE') : '';
                        option.textContent = `${config.name} ${dateStr ? '(' + dateStr + ')' : ''}`;
                        configSelect.appendChild(option);
                    });
                    console.log(`Loaded ${data.configurations.length} saved configurations`);
                } else {
                    configSelect.innerHTML = '<option value="">-- Keine gespeicherten Konfigurationen --</option>';
                }
            } catch (error) {
                console.error('Error loading saved configurations:', error);
            }
        }

        async function fetchFolders() {
            // This function is now replaced by loadProjectData()
            // Keeping it for backward compatibility if called from elsewhere
            await loadProjectData();
        }

        async function fetchUsers() {
            // This function is now replaced by loadProjectData()
            // Keeping it for backward compatibility if called from elsewhere
            await loadProjectData();
        }

        async function fetchFiles() {
            const token = getToken();
            const folderId = getTargetFolder();

            console.log('fetchFiles() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Folder ID:', folderId);

            if (!token || !folderId) {
                if (!token) {
                    showResult('connectionResult', 'error', '‚ö† Authentifizierung l√§uft... Bitte warten Sie, bis Trimble Connect die Verbindung hergestellt hat.');
                } else {
                    showResult('connectionResult', 'error', '‚ö† Bitte w√§hlen Sie zuerst einen Zielordner aus');
                }
                console.error('Missing token or folderId');
                return;
            }

            showResult('connectionResult', 'loading', '‚è≥ Dateien werden geladen...');

            try {
                // Fetch IFC files for IFC dropdown (primary use case now)
                console.log('Fetching IFC files from folder:', folderId);
                const ifcResponse = await fetch(`${API_PROJECT}/files`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        folderId: folderId,
                        fileExtensions: ['ifc']
                    })
                });

                console.log('IFC response status:', ifcResponse.status);
                const ifcData = await ifcResponse.json();
                console.log('IFC response data:', ifcData);

                let ifcCount = 0;

                if (ifcResponse.ok && ifcData.success) {
                    const ifcSelect = document.getElementById('ifcFile');
                    if (ifcSelect) {
                        ifcSelect.innerHTML = '<option value="">-- IFC ausw√§hlen --</option>';

                        console.log('IFC files found:', ifcData.files?.length || 0);

                        if (ifcData.files && ifcData.files.length > 0) {
                            ifcData.files.forEach(file => {
                                console.log('Adding IFC file:', file.name);
                                const option = document.createElement('option');
                                option.value = file.id;
                                option.textContent = file.name;
                                option.dataset.name = file.name;
                                ifcSelect.appendChild(option);
                            });
                            ifcCount = ifcData.files.length;
                        }
                    }
                } else {
                    console.error('IFC fetch failed:', ifcData);
                }

                console.log('Total IFC files:', ifcCount);
                showResult('connectionResult', 'success', `‚úÖ Dateien geladen! ${ifcCount} IFC-Datei(en) gefunden.`);
            } catch (error) {
                console.error('Error in fetchFiles:', error);
                console.error('Error stack:', error.stack);
                showResult('connectionResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function fetchUsers() {
            const token = getToken();
            const projectId = getProjectId();

            if (!token || !projectId) {
                showResult('step2Result', 'error', '‚ö† Bitte warten Sie auf die Authentifizierung √ºber Trimble Connect');
                return;
            }

            showResult('step2Result', 'loading', '‚è≥ Benutzer werden geladen...');

            try {
                const response = await fetch(`${API_PROJECT}/users`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessToken: token, projectId: projectId })
                });

                console.log('Response status:', response.status);
                const contentType = response.headers.get('content-type');
                console.log('Content-Type:', contentType);

                if (!contentType || !contentType.includes('application/json')) {
                    const textResponse = await response.text();
                    console.error('Non-JSON response:', textResponse);
                    showResult('step2Result', 'error', '‚ùå Ung√ºltige Antwort vom Server (kein JSON)');
                    return;
                }

                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    const select = document.getElementById('bcfAssignees');
                    select.innerHTML = '';

                    const users = data.users || data.Users;
                    if (!users || !Array.isArray(users)) {
                        showResult('step2Result', 'error', '‚ö† Keine Benutzer-Daten in Antwort');
                        return;
                    }

                    console.log('Number of users:', users.length);

                    users.forEach(user => {
                        console.log('Adding user:', user.email, user.displayName);
                        const option = document.createElement('option');
                        option.value = user.email || user.Email;
                        option.textContent = `${user.displayName || user.DisplayName} (${user.email || user.Email})`;
                        option.dataset.id = user.id || user.Id;
                        option.dataset.displayName = user.displayName || user.DisplayName;
                        select.appendChild(option);
                    });

                    showResult('step2Result', 'success', `‚úÖ ${users.length} Benutzer geladen!`);
                } else {
                    console.error('Response not OK or success=false');
                    const errorMsg = data.message || data.Message || 'Unbekannter Fehler';
                    showResult('step2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in fetchUsers:', error);
                console.error('Error stack:', error.stack);
                showResult('step2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function saveConfig() {
            const configName = document.getElementById('configName').value.trim();
            const projectId = getProjectId();

            if (!configName) {
                alert('‚ö† Bitte geben Sie einen Konfigurations-Namen ein!');
                return;
            }

            if (!projectId) {
                alert('‚ö† Warte auf Projekt-ID von Trimble Connect. Bitte versuchen Sie es in wenigen Sekunden erneut.');
                return;
            }

            // Build configuration object including all user choices
            const config = {
                projectId: projectId,
                projectName: configName,
                lastUpdated: new Date().toISOString(),
                targetFolder: getSelectedOption('targetFolder'),
                files: {
                    template: getSelectedOption('templateFile'),
                    ifcModel: getSelectedOption('ifcFile'),
                    raumbuch: getSelectedOption('raumbuchFile')
                },
                bcfAssignees: getSelectedUsers(),
                // Analyse tab settings
                zusammenfassung: currentConfig.zusammenfassung || [],
                toleranceMin: toleranceSettings.min,
                toleranceMax: toleranceSettings.max,
                toleranceProfiles: currentConfig.toleranceProfiles || [],
                // Ausstattung tab settings
                inventoryFolder: getSelectedOption('inventoryFolder'),
                psetPartialName: document.getElementById('psetPartialName')?.value || 'Plancal nova',
                roomPropertyName: document.getElementById('roomPropertyName')?.value || 'Room Nbr',
                selectedIfcFiles: getSelectedIfcFiles(),
                selectedProperties: getSelectedProperties()
            };

            try {
                showResult('connectionResult', 'info', 'üîÑ Speichere Konfiguration...');

                // Try to save to Azure
                const response = await fetch(`${API_PROJECT}/config/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        configName: configName,
                        configuration: config
                    })
                });

                // Check if response is OK first
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error response:', response.status, errorText);
                    throw new Error(`Server error (${response.status}): ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                console.log('Save config response:', data);

                if (data.success) {
                    if (data.savedToAzure) {
                        showResult('connectionResult', 'success', `‚úÖ ${data.message}`);
                        // Reload the configurations list
                        await loadSavedConfigurations(projectId);
                    } else {
                        // Azure not configured, download as file
                        const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${configName}.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        showResult('connectionResult', 'success', `‚úÖ Konfiguration "${configName}.json" heruntergeladen (lokaler Modus)!`);
                    }
                } else {
                    throw new Error(data.message || 'Fehler beim Speichern (keine Fehlermeldung vom Server)');
                }
            } catch (error) {
                console.error('Error saving config:', error);
                showResult('connectionResult', 'error', `‚ùå Fehler beim Speichern: ${error.message}`);
            }
        }

        async function loadConfigFromAzure() {
            const configName = document.getElementById('savedConfigs').value;
            const projectId = getProjectId();

            if (!configName) {
                alert('‚ö† Bitte w√§hlen Sie eine Konfiguration aus!');
                return;
            }

            if (!projectId) {
                alert('‚ö† Project ID nicht gefunden!');
                return;
            }

            try {
                showResult('connectionResult', 'info', 'üîÑ Lade Konfiguration...');

                const response = await fetch(`${API_PROJECT}/config/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId: projectId,
                        configName: configName
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.success && data.configuration) {
                    applyConfiguration(data.configuration);
                    showResult('connectionResult', 'success', `‚úÖ ${data.message}`);
                } else {
                    throw new Error(data.message || 'Fehler beim Laden');
                }
            } catch (error) {
                console.error('Error loading config from Azure:', error);
                showResult('connectionResult', 'error', `‚ùå Fehler beim Laden: ${error.message}`);
            }
        }

        async function deleteConfigFromAzure() {
            const configName = document.getElementById('savedConfigs').value;
            const projectId = getProjectId();

            if (!configName) {
                alert('‚ö† Bitte w√§hlen Sie eine Konfiguration aus!');
                return;
            }

            if (!projectId) {
                alert('‚ö† Project ID nicht gefunden!');
                return;
            }

            // Confirm deletion
            if (!confirm(`M√∂chten Sie die Konfiguration "${configName}" wirklich l√∂schen?`)) {
                return;
            }

            try {
                showResult('connectionResult', 'info', 'üîÑ L√∂sche Konfiguration...');

                const response = await fetch(`${API_PROJECT}/config/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId: projectId,
                        configName: configName
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    showResult('connectionResult', 'success', `‚úÖ ${data.message}`);
                    // Reload the configurations list
                    await loadSavedConfigurations(projectId);
                } else {
                    throw new Error(data.message || 'Fehler beim L√∂schen');
                }
            } catch (error) {
                console.error('Error deleting config from Azure:', error);
                showResult('connectionResult', 'error', `‚ùå Fehler beim L√∂schen: ${error.message}`);
            }
        }

        function applyConfiguration(config) {
            currentConfig = config;

            // Fill Project ID and Name (only if fields exist - they may be hidden in extension mode)
            const projectIdField = document.getElementById('projectId');
            if (projectIdField) {
                projectIdField.value = config.projectId || '';
            }
            document.getElementById('configName').value = config.projectName || '';

            // Fill Target Folder (display name in readonly field if not in dropdown yet)
            if (config.targetFolder) {
                const folderSelect = document.getElementById('targetFolder');
                // Try to find and select the folder
                let found = false;
                for (let i = 0; i < folderSelect.options.length; i++) {
                    if (folderSelect.options[i].value === config.targetFolder.id) {
                        folderSelect.selectedIndex = i;
                        found = true;
                        break;
                    }
                }
                // If not found, add temporary option
                if (!found) {
                    const option = document.createElement('option');
                    option.value = config.targetFolder.id;
                    option.textContent = config.targetFolder.path || config.targetFolder.name;
                    option.dataset.name = config.targetFolder.name;
                    option.dataset.path = config.targetFolder.path;
                    folderSelect.appendChild(option);
                    folderSelect.value = config.targetFolder.id;
                }
            }

            // Fill Template
            if (config.files?.template) {
                setSelectValue('templateFile', config.files.template.id, config.files.template.name);
            }

            // Fill IFC
            if (config.files?.ifcModel) {
                setSelectValue('ifcFile', config.files.ifcModel.id, config.files.ifcModel.name);
            }

            // Fill Raumbuch (changed from readonly to dropdown)
            if (config.files?.raumbuch) {
                setSelectValue('raumbuchFile', config.files.raumbuch.id, config.files.raumbuch.name);
            }

            // Fill BCF Assignees
            if (config.bcfAssignees && config.bcfAssignees.length > 0) {
                const select = document.getElementById('bcfAssignees');
                // Pre-select users if they exist in dropdown
                for (let i = 0; i < select.options.length; i++) {
                    const option = select.options[i];
                    const isSelected = config.bcfAssignees.some(u => u.email === option.value);
                    option.selected = isSelected;
                }
            }

            // Restore tolerance settings
            if (config.toleranceMin !== undefined) {
                toleranceSettings.min = config.toleranceMin;
                document.getElementById('toleranceMin').value = config.toleranceMin;
            }
            if (config.toleranceMax !== undefined) {
                toleranceSettings.max = config.toleranceMax;
                document.getElementById('toleranceMax').value = config.toleranceMax;
            }

            // Restore zusammenfassung data
            if (config.zusammenfassung && config.zusammenfassung.length > 0) {
                analyseData = config.zusammenfassung;
                currentConfig.zusammenfassung = config.zusammenfassung;
            }

            // Restore Ausstattung tab settings
            if (config.inventoryFolder) {
                setSelectValue('inventoryFolder', config.inventoryFolder.id, config.inventoryFolder.name);
            }
            if (config.psetPartialName) {
                document.getElementById('psetPartialName').value = config.psetPartialName;
            }
            if (config.roomPropertyName) {
                document.getElementById('roomPropertyName').value = config.roomPropertyName;
            }
        }

        function getSelectedOption(selectId) {
            const select = document.getElementById(selectId);
            if (!select) return null;
            const option = select.options[select.selectedIndex];
            if (!option || !option.value) return null;

            return {
                id: option.value,
                name: option.dataset.name || option.textContent,
                path: option.dataset.path || ''
            };
        }

        function getSelectedUsers() {
            const select = document.getElementById('bcfAssignees');
            const users = [];
            for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].selected) {
                    users.push({
                        id: select.options[i].dataset.id || '',
                        email: select.options[i].value,
                        displayName: select.options[i].dataset.displayName || select.options[i].textContent
                    });
                }
            }
            return users;
        }

        function setSelectValue(selectId, value, name) {
            const select = document.getElementById(selectId);
            if (!select) {
                console.log(`Select element ${selectId} not found, skipping`);
                return;
            }
            let found = false;

            // Try to find existing option
            for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].value === value) {
                    select.selectedIndex = i;
                    found = true;
                    return;
                }
            }

            // If not found, add as option
            if (!found && value && name) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = name;
                option.dataset.name = name;
                select.appendChild(option);
                select.value = value;
            }
        }

        // ====================================================================
        //  POLLING HELPER FUNCTION
        // ====================================================================

        /**
         * Polls the folder for a newly created file by name.
         * Tries up to 5 times with 500ms intervals.
         * Returns the file ID if found, or null if not found.
         */
        async function pollForFile(fileName, maxAttempts = 5, delayMs = 500) {
            const token = getToken();
            const folderId = getTargetFolder();

            console.log(`Starting polling for file: ${fileName}`);

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                console.log(`Poll attempt ${attempt}/${maxAttempts}`);
                //
                // Wait before querying
                await new Promise(resolve => setTimeout(resolve, delayMs));

                try {
                    const response = await fetch(`${API_PROJECT}/files`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            accessToken: token,
                            folderId: folderId,
                            fileExtensions: ['xlsx']
                        })
                    });

                    if (!response.ok) {
                        console.warn(`Folder query failed with status ${response.status}`);
                        continue;
                    }

                    const data = await response.json();

                    if ((data.success || data.Success) && (data.files || data.Files)) {
                        // Find the file by name (case-insensitive)
                        const files = data.files || data.Files;
                        const foundFile = files.find(f =>
                            (f.name || f.Name).toLowerCase() === fileName.toLowerCase()
                        );

                        if (foundFile && (foundFile.id || foundFile.Id)) {
                            const fileId = foundFile.id || foundFile.Id;
                            const fileName = foundFile.name || foundFile.Name;
                            console.log(`Found file: ${fileName}, ID: ${fileId}`);
                            return foundFile;
                        }
                    }

                    console.log(`File '${fileName}' not found yet. Will retry...`);
                } catch (error) {
                    console.error(`Error during poll attempt ${attempt}:`, error);
                }
            }

            console.warn(`File '${fileName}' not found after ${maxAttempts} attempts.`);
            return null;
        }

        /**
         * Updates a dropdown with a new file option and selects it.
         */
        function updateDropdownWithFile(selectId, file) {
            const select = document.getElementById(selectId);
            if (!select) {
                console.log(`Dropdown ${selectId} not found, skipping update`);
                return;
            }

            // Check if file already exists in dropdown
            let optionExists = false;
            for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].value === file.id) {
                    select.selectedIndex = i;
                    optionExists = true;
                    break;
                }
            }

            // If not exists, add it
            if (!optionExists) {
                const option = document.createElement('option');
                option.value = file.id;
                option.textContent = file.name;
                option.dataset.name = file.name;
                select.appendChild(option);
                select.value = file.id;
            }

            console.log(`Updated dropdown ${selectId} with file: ${file.name}`);
        }

        // ====================================================================
        //  EXISTING FUNCTIONS (updated to use polling)
        // ====================================================================

        async function testConnection() {
            const token = getToken();
            const projectId = getProjectId();

            if (!token || !projectId) {
                showResult('connectionResult', 'error', '‚ö† Bitte warten Sie auf die Authentifizierung √ºber Trimble Connect');
                return;
            }

            showResult('connectionResult', 'loading', '‚è≥ Teste Verbindung...');

            try {
                const response = await fetch(`${API_BASE}/test-project`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessToken: token, projectId: projectId })
                });

                const data = await response.json();

                if (response.ok) {
                    showResult('connectionResult', 'success', `‚úÖ Verbindung OK! Projekt: ${data.projectId || projectId}`);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('connectionResult', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('connectionResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function importTemplate() {
            const token = getToken();
            const projectId = getProjectId();
            const templateFileId = document.getElementById('templateFile').value;
            const targetFolder = getTargetFolder();

            console.log('importTemplate() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('ProjectId:', projectId);
            console.log('Template File ID:', templateFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !templateFileId || !targetFolder || !projectId) {
                showResult('step1Result', 'error', '‚ö† Bitte alle Felder ausf√ºllen');
                return;
            }

            showResult('step1Result', 'loading', '‚è≥ Importiere Vorlage...');

            try {
                const requestBody = {
                    accessToken: token,
                    projectId: projectId,
                    templateFileId: templateFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/import-template`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok) {
                    const fileName = data.raumprogrammFileName || 'Raumprogramm.xlsx';
                    const fileId = data.raumprogrammFileId || 'N/A';

                    console.log('Raumprogramm created successfully:', fileName, fileId);

                    // Save to config
                    currentConfig.files.raumprogramm = {
                        id: fileId,
                        name: fileName
                    };

                    console.log('Updated currentConfig.files.raumprogramm:', currentConfig.files.raumprogramm);

                    showResult('step1Result', 'loading', `‚úÖ Raumprogramm erstellt!<br>‚è≥ Warte auf ID von Connect...`);

                    // Poll for the file to get the actual Connect ID
                    const foundFile = await pollForFile(fileName);

                    if (foundFile) {
                        // Update config with correct ID
                        currentConfig.files.raumprogramm.id = foundFile.id;

                        // Update dropdown in Step 3
                        updateDropdownWithFile('raumprogrammFile', foundFile);

                        showResult('step1Result', 'success',
                            `‚úÖ Erfolgreich!<br>Datei: ${fileName}<br>ID: ${foundFile.id}<br>‚úÖ Raumprogramm wurde zur Dropdown-Liste hinzugef√ºgt!`);
                    } else {
                        // File not found after polling, use backend ID
                        showResult('step1Result', 'warning',
                            `‚ö†Ô∏è Raumprogramm wurde erstellt, aber ID konnte nicht sofort abgerufen werden.<br>Datei: ${fileName}<br>Bitte klicken Sie auf "Dateien laden" um die Liste zu aktualisieren.`);
                    }
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    console.error('Import template failed:', errorMsg);
                    showResult('step1Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in importTemplate:', error);
                showResult('step1Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function createBcfTopic() {
            const token = getToken();
            const projectId = getProjectId();
            const folderId = getTargetFolder();
            const title = document.getElementById('bcfTitle').value.trim();
            const description = document.getElementById('bcfDescription').value.trim();
            const priority = document.getElementById('bcfPriority').value;
            const dueDate = document.getElementById('bcfDueDate').value;

            // Get selected users
            const selectedUsers = getSelectedUsers();
            if (selectedUsers.length === 0) {
                showResult('step2Result', 'error', '‚ö† Bitte mindestens einen Benutzer ausw√§hlen');
                return;
            }

            const assignedTo = selectedUsers.map(u => u.email).join(',');

            if (!token || !projectId || !folderId) {
                showResult('step2Result', 'error', '‚ö† Bitte Token, Project ID und Folder ausw√§hlen');
                return;
            }

            showResult('step2Result', 'loading', '‚è≥ Erstelle BCF Topic...');

            try {
                const response = await fetch(`${API_BASE}/create-bcf-topic`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        projectId: projectId,
                        folderId: folderId,
                        title: title,
                        description: description,
                        assignedTo: assignedTo,
                        createMultipleTopics: false,
                        priority: priority || null,
                        dueDate: dueDate || null
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    let resultHtml = `‚úÖ BCF Topic erfolgreich erstellt!<br>Topic GUID: ${data.topicGuid || 'N/A'}`;

                    if (data.documentReferenceGuid) {
                        resultHtml += `<br>Dokumentreferenz GUID: ${data.documentReferenceGuid}`;
                    }

                    resultHtml += `<br><br>‚ö†Ô∏è Bitte pr√ºfen Sie die Benutzerzuweisungen und Berechtigungen in Trimble Connect.`;

                    showResult('step2Result', 'success', resultHtml);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function importIfc() {
            const token = getToken();
            const projectId = getProjectId();
            const ifcFileId = document.getElementById('ifcFile').value;
            const raumprogrammFileSelect = document.getElementById('raumprogrammFile');
            const raumprogrammFileId = raumprogrammFileSelect.value;
            const targetFolder = getTargetFolder();

            console.log('importIfc() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('ProjectId:', projectId);
            console.log('IFC File ID:', ifcFileId);
            console.log('Raumprogramm File ID:', raumprogrammFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !projectId || !ifcFileId || !raumprogrammFileId || !targetFolder) {
                let missingFields = [];
                if (!token) missingFields.push('Token');
                if (!projectId) missingFields.push('Project ID');
                if (!ifcFileId) missingFields.push('IFC File');
                if (!raumprogrammFileId) missingFields.push('Raumprogramm File');
                if (!targetFolder) missingFields.push('Target Folder');

                showResult('step3Result', 'error', `‚ö† Bitte alle Felder ausf√ºllen. Fehlende Felder: ${missingFields.join(', ')}`);
                return;
            }

            showResult('step3Result', 'loading', '‚è≥ Importiere IFC und erstelle Raumbuch... (kann einige Sekunden dauern)');

            try {
                const requestBody = {
                    accessToken: token,
                    projectId: projectId,
                    ifcFileId: ifcFileId,
                    raumprogrammFileId: raumprogrammFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/import-ifc`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok) {
                    const fileName = data.raumbuchFileName || 'Raumbuch.xlsx';
                    const fileId = data.raumbuchFileId || 'N/A';

                    console.log('Raumbuch created successfully:', fileName, fileId);

                    // Save to config
                    currentConfig.files.raumbuch = {
                        id: fileId,
                        name: fileName
                    };

                    let message = `‚úÖ Raumbuch erstellt!<br>Datei: ${fileName}<br>‚è≥ Warte auf ID von Connect...<br><br><strong>Analyse:</strong><br>`;
                    if (data.analysis && data.analysis.length > 0) {
                        data.analysis.forEach(a => {
                            // Use new status logic: OK, Zu wenig, Zu viel
                            const status = a.status || (a.isUnderLimit ? '‚ö†Ô∏è Zu wenig' : (a.isOverLimit ? 'üìä Zu viel' : '‚úÖ OK'));
                            message += `- ${a.roomCategory}: ${a.percentage.toFixed(1)}% ${status}<br>`;
                        });
                    }

                    showResult('step3Result', 'loading', message);

                    // Poll for the file to get the actual Connect ID
                    const foundFile = await pollForFile(fileName);

                    if (foundFile) {
                        // Update config with correct ID
                        currentConfig.files.raumbuch.id = foundFile.id;

                        // Update dropdown (used by both Step 3 update and Step 4 pset operations)
                        updateDropdownWithFile('raumbuchFile', foundFile);

                        message = `‚úÖ Raumbuch erfolgreich erstellt!<br>Datei: ${fileName}<br>ID: ${foundFile.id}<br>‚úÖ Raumbuch wurde zur Dropdown-Liste hinzugef√ºgt!`;
                        showResult('step3Result', 'success', message);
                    } else {
                        // File not found after polling, use backend ID
                        message = `‚ö†Ô∏è Raumbuch wurde erstellt, aber ID konnte nicht sofort abgerufen werden.<br>Datei: ${fileName}<br>Bitte klicken Sie auf "Dateien laden" um die Liste zu aktualisieren.<br><br><strong>Analyse:</strong><br>`;
                        if (data.analysis && data.analysis.length > 0) {
                            data.analysis.forEach(a => {
                                // Use new status logic: OK, Zu wenig, Zu viel
                                const status = a.status || (a.isUnderLimit ? '‚ö†Ô∏è Zu wenig' : (a.isOverLimit ? 'üìä Zu viel' : '‚úÖ OK'));
                                message += `- ${a.roomCategory}: ${a.percentage.toFixed(1)}% ${status}<br>`;
                            });
                        }
                        showResult('step3Result', 'warning', message);
                    }
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step3Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in importIfc:', error);
                showResult('step3Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function updateRaumbuch() {
            const token = getToken();
            const projectId = getProjectId();
            const ifcFileId = document.getElementById('ifcFile').value;
            const templateFileId = document.getElementById('templateFile').value;
            const existingRaumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();

            // Get column mappings
            const raumtypCol = document.getElementById('mappingRaumtyp').value;
            const raumkategorieCol = document.getElementById('mappingRaumkategorie').value;
            const flaecheSollCol = document.getElementById('mappingFlaecheSoll').value;

            console.log('updateRaumbuch() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('ProjectId:', projectId);
            console.log('IFC File ID:', ifcFileId);
            console.log('Template File ID:', templateFileId);
            console.log('Existing Raumbuch File ID:', existingRaumbuchFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !projectId || !ifcFileId || !templateFileId || !existingRaumbuchFileId || !targetFolder) {
                let missingFields = [];
                if (!token) missingFields.push('Token');
                if (!projectId) missingFields.push('Project ID');
                if (!ifcFileId) missingFields.push('IFC File');
                if (!templateFileId) missingFields.push('Vorlagendatei');
                if (!existingRaumbuchFileId) missingFields.push('Raumbuch File');
                if (!targetFolder) missingFields.push('Target Folder');

                showResult('step3Result', 'error', `‚ö† Bitte alle Felder ausf√ºllen. Fehlende Felder: ${missingFields.join(', ')}`);
                return;
            }

            if (!raumtypCol || !flaecheSollCol) {
                showResult('step3Result', 'error', '‚ö† Bitte laden Sie die Vorlage und w√§hlen Sie mindestens Raumtyp und Fl√§che Soll Spalten aus');
                return;
            }

            showResult('step3Result', 'loading', '‚è≥ Aktualisiere Raumbuch... (kann einige Sekunden dauern)');

            try {
                const requestBody = {
                    accessToken: token,
                    projectId: projectId,
                    raumbuchFileId: existingRaumbuchFileId,
                    templateFileId: templateFileId,
                    ifcFileId: ifcFileId,
                    targetFolderId: targetFolder,
                    columnMappings: {
                        raumtypColumn: parseInt(raumtypCol),
                        raumkategorieColumn: raumkategorieCol ? parseInt(raumkategorieCol) : -1,
                        flaecheSollColumn: parseInt(flaecheSollCol)
                    }
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/update-raumbuch-with-mappings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok) {
                    const fileName = data.raumbuchFileName || 'Raumbuch.xlsx';
                    const fileId = data.raumbuchFileId || 'N/A';

                    console.log('Raumbuch updated successfully:', fileName, fileId);

                    // Save to config
                    currentConfig.files.raumbuch = {
                        id: fileId,
                        name: fileName
                    };

                    let message = `‚úÖ Raumbuch aktualisiert!<br>Datei: ${fileName}<br>`;
                    message += `R√§ume hinzugef√ºgt: ${data.RoomsAdded || 0}<br>`;
                    message += `R√§ume aktualisiert: ${data.RoomsUpdated || 0}<br>`;
                    message += `R√§ume unver√§ndert: ${data.RoomsUnchanged || 0}`;

                    showResult('step3Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step3Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in updateRaumbuch:', error);
                showResult('step3Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function writePset() {
            const token = getToken();
            const ifcFileId = document.getElementById('ifcFile').value; // Read from Step 3
            const raumbuchFileId = document.getElementById('raumbuchFile').value; // Read from Step 3
            const targetFolder = getTargetFolder();

            if (!token || !ifcFileId || !raumbuchFileId || !targetFolder) {
                showResult('step4Result', 'error', '‚ö† Bitte alle Felder ausf√ºllen (IFC und Raumbuch aus Schritt 3 erforderlich)');
                return;
            }

            showResult('step4Result', 'loading', '‚è≥ Schreibe Pset "Raumbuch" in IFC... (kann einige Sekunden dauern)');

            try {
                const response = await fetch(`${API_BASE}/write-raumbuch-pset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        ifcFileId: ifcFileId,
                        raumbuchFileId: raumbuchFileId,
                        targetFolderId: targetFolder
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    let message = `‚úÖ ${data.Message || data.message || 'Pset erfolgreich geschrieben!'}<br>`;
                    message += `R√§ume aktualisiert: ${data.RoomsUpdated || data.roomsUpdated || 0}<br>`;
                    message += `R√§ume √ºbersprungen: ${data.RoomsSkipped || data.roomsSkipped || 0}`;

                    if (data.Warnings && data.Warnings.length > 0) {
                        message += '<br><br><strong>Warnungen:</strong><br>';
                        data.Warnings.forEach(w => {
                            message += `- ${w}<br>`;
                        });
                    }

                    showResult('step4Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step4Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step4Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function updatePset() {
            const token = getToken();
            const ifcFileId = document.getElementById('ifcFile').value; // Read from Step 3
            const raumbuchFileId = document.getElementById('raumbuchFile').value; // Read from Step 3
            const targetFolder = getTargetFolder();

            if (!token || !ifcFileId || !raumbuchFileId || !targetFolder) {
                showResult('step4Result', 'error', '‚ö† Bitte alle Felder ausf√ºllen (IFC und Raumbuch aus Schritt 3 erforderlich)');
                return;
            }

            showResult('step4Result', 'loading', '‚è≥ Aktualisiere Pset "Raumbuch" in IFC...');

            try {
                const response = await fetch(`${API_BASE}/update-raumbuch-pset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        ifcFileId: ifcFileId,
                        raumbuchFileId: raumbuchFileId,
                        targetFolderId: targetFolder
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    let message = `‚úÖ ${data.Message || data.message || 'Pset erfolgreich aktualisiert!'}<br>`;
                    message += `R√§ume aktualisiert: ${data.RoomsUpdated || data.roomsUpdated || 0}<br>`;
                    message += `R√§ume √ºbersprungen: ${data.RoomsSkipped || data.roomsSkipped || 0}`;

                    showResult('step4Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step4Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step4Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function deletePset() {
            const token = getToken();
            const ifcFileId = document.getElementById('ifcFile').value; // Read from Step 3
            const targetFolder = getTargetFolder();

            if (!token || !ifcFileId || !targetFolder) {
                showResult('step4Result', 'error', '‚ö† Bitte IFC File aus Schritt 3 ausw√§hlen');
                return;
            }

            if (!confirm('Sind Sie sicher, dass Sie das Pset "Raumbuch" aus der IFC-Datei l√∂schen m√∂chten?')) {
                return;
            }

            showResult('step4Result', 'loading', '‚è≥ L√∂sche Pset "Raumbuch" aus IFC...');

            try {
                const response = await fetch(`${API_BASE}/delete-raumbuch-pset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        ifcFileId: ifcFileId,
                        targetFolderId: targetFolder
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    let message = `‚úÖ ${data.Message || data.message || 'Pset erfolgreich gel√∂scht!'}<br>`;
                    message += `Psets entfernt: ${data.PsetsRemoved || data.psetsRemoved || 0}`;

                    showResult('step4Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step4Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step4Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Opens the IFC file in 3D Viewer using Trimble Connect
         */
        async function openIn3DViewer() {
            const ifcFileId = document.getElementById('ifcFile').value;
            const projectId = getProjectId();

            if (!ifcFileId) {
                showResult('step4Result', 'error', '‚ö† Bitte IFC-Datei in Einstellungen ausw√§hlen');
                return;
            }

            if (!projectId) {
                showResult('step4Result', 'error', '‚ö† Projekt-ID nicht verf√ºgbar');
                return;
            }

            try {
                // Build the Trimble Connect 3D Viewer URL
                // Format: https://web.connect.trimble.com/projects/{projectId}/viewer/3d/?modelId={fileId}
                const viewerUrl = `https://web.connect.trimble.com/projects/${projectId}/viewer/3d/?modelId=${ifcFileId}`;

                console.log('Opening 3D Viewer:', viewerUrl);

                // Open in new tab
                window.open(viewerUrl, '_blank');

                showResult('step4Result', 'success', '‚úÖ 3D-Viewer wird in neuem Tab ge√∂ffnet...');
            } catch (error) {
                console.error('Error opening 3D Viewer:', error);
                showResult('step4Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function createRoomSheets() {
            const token = getToken();
            const raumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();

            console.log('createRoomSheets() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Raumbuch File ID:', raumbuchFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !raumbuchFileId || !targetFolder) {
                showResult('step5_1Result', 'error', '‚ö† Bitte Token, Raumbuch-Datei und Zielordner ausw√§hlen');
                return;
            }

            showResult('step5_1Result', 'loading', '‚è≥ Erstelle Raumlisten...');

            try {
                const requestBody = {
                    accessToken: token,
                    raumbuchFileId: raumbuchFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/create-room-sheets`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    let message = `‚úÖ ${data.message || data.Message}<br>`;
                    message += `Raumlisten erstellt: ${data.roomSheetsCreated || data.RoomSheetsCreated || 0}`;

                    showResult('step5_1Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.Message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step5_1Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_1Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function loadIfcFilesForInventory() {
            const token = getToken();
            const inventoryFolderId = document.getElementById('inventoryFolder').value;

            console.log('loadIfcFilesForInventory() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Inventory Folder ID:', inventoryFolderId);

            if (!token || !inventoryFolderId) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Token und IFC-Ordner ausw√§hlen');
                return;
            }

            showResult('step5_2Result', 'loading', '‚è≥ IFC-Dateien werden geladen...');

            try {
                const response = await fetch(`${API_PROJECT}/files`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        folderId: inventoryFolderId,
                        fileExtensions: ['ifc']
                    })
                });

                console.log('IFC files response status:', response.status);
                const data = await response.json();
                console.log('IFC files response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    const ifcFilesList = document.getElementById('ifcFilesList');

                    const files = data.files || data.Files;
                    if (files && files.length > 0) {
                        // Create checkboxes for each IFC file
                        let html = '';
                        files.forEach(file => {
                            const fileId = file.id || file.Id;
                            const fileName = file.name || file.Name;
                            html += `
                                        <label class="file-checkbox-label">
                                            <input type="checkbox" id="ifc_${fileId}" value="${fileId}" class="ifc-file-checkbox file-checkbox">
                                            <span>${fileName}</span>
                                        </label>
                                    `;
                        });
                        ifcFilesList.innerHTML = html;
                        showResult('step5_2Result', 'success', `‚úÖ ${files.length} IFC-Datei(en) gefunden`);
                    } else {
                        ifcFilesList.innerHTML = '<p style="color: #666;">Keine IFC-Dateien gefunden</p>';
                        showResult('step5_2Result', 'warning', '‚ö† Keine IFC-Dateien im ausgew√§hlten Ordner gefunden');
                    }
                } else {
                    const errorMsg = data.message || data.Message || `HTTP ${response.status}`;
                    showResult('step5_2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function discoverProperties() {
            const token = getToken();
            const psetPartialName = document.getElementById('psetPartialName').value;

            // Get selected IFC file IDs
            const selectedCheckboxes = document.querySelectorAll('.ifc-file-checkbox:checked');
            const ifcFileIds = Array.from(selectedCheckboxes).map(cb => cb.value);

            console.log('discoverProperties() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('IFC File IDs:', ifcFileIds);
            console.log('Pset Partial Name:', psetPartialName);

            if (!token || ifcFileIds.length === 0) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Token und mindestens eine IFC-Datei ausw√§hlen');
                return;
            }

            if (!psetPartialName) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Pset-Name angeben');
                return;
            }

            showResult('step5_2Result', 'loading', '‚è≥ Eigenschaften werden geladen...');

            try {
                const requestBody = {
                    accessToken: token,
                    ifcFileIds: ifcFileIds,
                    psetPartialName: psetPartialName
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/discover-properties`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    const select = document.getElementById('additionalProperties');
                    select.innerHTML = '';

                    const properties = data.properties || data.Properties;
                    if (properties && properties.length > 0) {
                        properties.forEach(prop => {
                            const option = document.createElement('option');
                            option.value = prop.propertyName || prop.PropertyName;
                            option.textContent = `${prop.propertyName || prop.PropertyName} (${prop.psetName || prop.PsetName})`;
                            select.appendChild(option);
                        });
                        showResult('step5_2Result', 'success', `‚úÖ ${properties.length} Eigenschaft(en) gefunden`);
                    } else {
                        select.innerHTML = '<option value="">-- Keine Eigenschaften gefunden --</option>';
                        showResult('step5_2Result', 'warning', '‚ö† Keine Eigenschaften gefunden');
                    }
                } else {
                    const errorMsg = data.message || data.Message || `HTTP ${response.status}`;
                    showResult('step5_2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in discoverProperties:', error);
                showResult('step5_2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function fillInventory() {
            const token = getToken();
            const raumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();
            const psetPartialName = document.getElementById('psetPartialName').value;
            const roomPropertyName = document.getElementById('roomPropertyName').value;

            // Get selected IFC file IDs
            const selectedCheckboxes = document.querySelectorAll('.ifc-file-checkbox:checked');
            const ifcFileIds = Array.from(selectedCheckboxes).map(cb => cb.value);

            // Get selected additional properties
            const additionalPropertiesSelect = document.getElementById('additionalProperties');
            const additionalProperties = Array.from(additionalPropertiesSelect.selectedOptions).map(opt => opt.value).filter(v => v);

            console.log('fillInventory() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Raumbuch File ID:', raumbuchFileId);
            console.log('IFC File IDs:', ifcFileIds);
            console.log('Pset Partial Name:', psetPartialName);
            console.log('Additional Properties:', additionalProperties);
            console.log('Room Property Name:', roomPropertyName);

            if (!token || !raumbuchFileId || !targetFolder || ifcFileIds.length === 0) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Token, Raumbuch-Datei, Zielordner und mindestens eine IFC-Datei ausw√§hlen');
                return;
            }

            if (!psetPartialName || !roomPropertyName) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Pset-Name und Raumnummer-Eigenschaft angeben');
                return;
            }

            showResult('step5_2Result', 'loading', '‚è≥ Inventar wird erstellt...');

            try {
                const requestBody = {
                    accessToken: token,
                    raumbuchFileId: raumbuchFileId,
                    ifcFileIds: ifcFileIds,
                    psetPartialName: psetPartialName,
                    roomPropertyName: roomPropertyName,
                    targetFolderId: targetFolder,
                    additionalProperties: additionalProperties.length > 0 ? additionalProperties : null
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/fill-inventory`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    let message = `‚úÖ ${data.message || data.Message}<br>`;
                    message += `R√§ume aktualisiert: ${data.roomsUpdated || data.RoomsUpdated || 0}<br>`;
                    message += `Objekte hinzugef√ºgt: ${data.totalItems || data.TotalItems || 0}`;

                    const warnings = data.warnings || data.Warnings;
                    if (warnings && warnings.length > 0) {
                        message += '<br><br><strong>Warnungen:</strong><br>';
                        warnings.forEach(w => {
                            message += `‚ö† ${w}<br>`;
                        });
                    }

                    showResult('step5_2Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.Message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step5_2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function deleteRoomLists() {
            const token = getToken();
            const raumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();

            console.log('deleteRoomLists() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Raumbuch File ID:', raumbuchFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !raumbuchFileId || !targetFolder) {
                showResult('step5_1Result', 'error', '‚ö† Bitte Token, Raumbuch-Datei und Zielordner ausw√§hlen');
                return;
            }

            showResult('step5_1Result', 'loading', '‚è≥ L√∂sche Raumlisten...');

            try {
                const requestBody = {
                    accessToken: token,
                    raumbuchFileId: raumbuchFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/delete-room-lists`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    let message = `‚úÖ ${data.message || data.Message}<br>`;
                    message += `${data.sheetsDeleted || data.SheetsDeleted || 0} Raumbl√§tter gel√∂scht<br>`;
                    message += `${data.hyperlinksRemoved || data.HyperlinksRemoved || 0} Hyperlinks entfernt`;

                    showResult('step5_1Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.Message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step5_1Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_1Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function updateInventory() {
            const token = getToken();
            const raumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();
            const psetPartialName = document.getElementById('psetPartialName').value;
            const roomPropertyName = document.getElementById('roomPropertyName').value;

            // Get selected IFC file IDs
            const selectedCheckboxes = document.querySelectorAll('.ifc-file-checkbox:checked');
            const ifcFileIds = Array.from(selectedCheckboxes).map(cb => cb.value);

            // Get selected additional properties
            const additionalPropertiesSelect = document.getElementById('additionalProperties');
            const additionalProperties = Array.from(additionalPropertiesSelect.selectedOptions).map(opt => opt.value).filter(v => v);

            console.log('updateInventory() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Raumbuch File ID:', raumbuchFileId);
            console.log('IFC File IDs:', ifcFileIds);
            console.log('Pset Partial Name:', psetPartialName);
            console.log('Room Property Name:', roomPropertyName);
            console.log('Additional Properties:', additionalProperties);

            if (!token || !raumbuchFileId || !targetFolder || ifcFileIds.length === 0) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Token, Raumbuch-Datei, Zielordner und mindestens eine IFC-Datei ausw√§hlen');
                return;
            }

            if (!psetPartialName || !roomPropertyName) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Pset-Name und Raumnummer-Eigenschaft angeben');
                return;
            }

            showResult('step5_2Result', 'loading', '‚è≥ Inventar wird aktualisiert...');

            try {
                const requestBody = {
                    accessToken: token,
                    raumbuchFileId: raumbuchFileId,
                    ifcFileIds: ifcFileIds,
                    psetPartialName: psetPartialName,
                    roomPropertyName: roomPropertyName,
                    targetFolderId: targetFolder,
                    additionalProperties: additionalProperties.length > 0 ? additionalProperties : null
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/update-inventory`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    let message = `‚úÖ ${data.message || data.Message}<br>`;
                    message += `R√§ume aktualisiert: ${data.roomsUpdated || data.RoomsUpdated || 0}<br>`;
                    message += `Objekte gel√∂scht: ${data.itemsDeleted || data.ItemsDeleted || 0}<br>`;
                    message += `Objekte hinzugef√ºgt: ${data.itemsAdded || data.ItemsAdded || 0}`;

                    const warnings = data.warnings || data.Warnings;
                    if (warnings && warnings.length > 0) {
                        message += '<br><br><strong>Warnungen:</strong><br>';
                        warnings.forEach(w => {
                            message += `‚ö† ${w}<br>`;
                        });
                    }

                    showResult('step5_2Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.Message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step5_2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        // ====================================================================
        //  ANALYSE TAB FUNCTIONS (Redesigned)
        // ====================================================================

        // Store current tolerance settings
        let toleranceSettings = {
            min: -10,
            max: 10
        };

        // Store current analyse data
        let analyseData = [];
        
        // Store current analysis state
        let currentAnalysisElement = {
            type: null,
            inventoryTemplateId: null,
            name: null
        };
        
        // Current status filter for analysis
        let currentStatusFilter = 'all';
        
        // Autosave timer for comment
        const analysisCommentTimers = new Map();
        const ANALYSIS_AUTOSAVE_DELAY = 600;

        /**
         * Loads available analysis elements (Area types and inventory templates)
         */
        async function loadAnalysisElements() {
            try {
                const response = await fetch(`${API_ANALYSIS}/elements`);
                const data = await response.json();
                
                if (response.ok && data.success) {
                    const select = document.getElementById('analysisElementSelect');
                    
                    // Keep the default option and area optgroup
                    let html = '<option value="">-- Element ausw√§hlen --</option>';
                    html += '<optgroup label="Fl√§che">';
                    html += '<option value="NetArea">Nettofl√§che</option>';
                    html += '<option value="GrossArea">Bruttofl√§che</option>';
                    html += '</optgroup>';
                    
                    // Add inventory templates
                    const inventoryElements = data.elements.filter(e => e.category === 'Inventory');
                    if (inventoryElements.length > 0) {
                        html += '<optgroup label="Inventar">';
                        inventoryElements.forEach(e => {
                            const unit = e.unit ? ` (${escapeHtml(e.unit)})` : '';
                            html += `<option value="Inventory:${e.inventoryTemplateID}">${escapeHtml(e.name)}${unit}</option>`;
                        });
                        html += '</optgroup>';
                    }
                    
                    select.innerHTML = html;
                }
            } catch (error) {
                console.error('Error loading analysis elements:', error);
            }
        }

        /**
         * Handles analysis element selection change
         */
        function onAnalysisElementChange() {
            const select = document.getElementById('analysisElementSelect');
            const value = select.value;
            
            if (!value) {
                currentAnalysisElement = { type: null, inventoryTemplateId: null, name: null };
                document.getElementById('analyseTableDescription').textContent = 
                    'W√§hlen Sie ein Analyseelement aus, um die Abweichungsanalyse anzuzeigen.';
                document.getElementById('analyseTableBody').innerHTML = 
                    '<tr><td colspan="10" style="text-align:center; color:#666;">W√§hlen Sie ein Analyseelement aus.</td></tr>';
                return;
            }
            
            if (value.startsWith('Inventory:')) {
                const templateId = parseInt(value.split(':')[1]);
                currentAnalysisElement = {
                    type: 'Inventory',
                    inventoryTemplateId: templateId,
                    name: select.options[select.selectedIndex].text
                };
            } else {
                currentAnalysisElement = {
                    type: value,
                    inventoryTemplateId: null,
                    name: select.options[select.selectedIndex].text
                };
            }
            
            document.getElementById('analyseTableDescription').textContent = 
                `Abweichungsanalyse f√ºr: ${currentAnalysisElement.name}`;
            
            // Load settings and data for this element
            loadAnalysisSettingsForElement();
            loadAnalyseData();
        }

        /**
         * Loads tolerance settings for the current element
         */
        async function loadAnalysisSettingsForElement() {
            if (!currentAnalysisElement.type) return;
            
            try {
                let url = `${API_ANALYSIS}/settings?elementType=${encodeURIComponent(currentAnalysisElement.type)}`;
                if (currentAnalysisElement.inventoryTemplateId) {
                    url += `&inventoryTemplateId=${currentAnalysisElement.inventoryTemplateId}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (response.ok && data.success && data.settings) {
                    toleranceSettings.min = data.settings.toleranceMin;
                    toleranceSettings.max = data.settings.toleranceMax;
                    
                    document.getElementById('toleranceMin').value = data.settings.toleranceMin;
                    document.getElementById('toleranceMax').value = data.settings.toleranceMax;
                }
            } catch (error) {
                console.error('Error loading analysis settings:', error);
            }
        }

        /**
         * Applies tolerance settings and saves to database
         */
        async function applyToleranceSettings() {
            if (!currentAnalysisElement.type) {
                showResult('analyseResult', 'error', '‚ö†Ô∏è Bitte zuerst ein Analyseelement ausw√§hlen');
                return;
            }
            
            const toleranceMin = parseFloat(document.getElementById('toleranceMin').value) || -10;
            const toleranceMax = parseFloat(document.getElementById('toleranceMax').value) || 10;
            
            toleranceSettings.min = toleranceMin;
            toleranceSettings.max = toleranceMax;
            
            showResult('analyseResult', 'loading', '‚è≥ Speichere Toleranzeinstellungen...');
            
            try {
                const requestBody = {
                    selectedElementType: currentAnalysisElement.type,
                    selectedInventoryTemplateID: currentAnalysisElement.inventoryTemplateId,
                    toleranceMin: toleranceMin,
                    toleranceMax: toleranceMax,
                    userId: getCurrentUserId()
                };
                
                const response = await fetch(`${API_ANALYSIS}/settings`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    showResult('analyseResult', 'success', '‚úÖ Toleranzeinstellungen gespeichert');
                    // Reload data with new tolerance
                    await loadAnalyseData();
                } else {
                    showResult('analyseResult', 'error', `‚ùå ${data.message || 'Fehler beim Speichern'}`);
                }
            } catch (error) {
                console.error('Error saving tolerance settings:', error);
                showResult('analyseResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Handles filter change (room category or search)
         */
        function onAnalysisFilterChange() {
            loadAnalyseData();
        }

        /**
         * Loads analyse data from the new Analysis API
         */
        async function loadAnalyseData() {
            if (!currentAnalysisElement.type) {
                // If no element selected, show message
                document.getElementById('analyseTableBody').innerHTML = 
                    '<tr><td colspan="10" style="text-align:center; color:#666;">W√§hlen Sie ein Analyseelement aus.</td></tr>';
                return;
            }
            
            showResult('analyseResult', 'loading', '‚è≥ Lade Analysedaten...');

            try {
                // Build query parameters
                let url = `${API_ANALYSIS}/data?elementType=${encodeURIComponent(currentAnalysisElement.type)}`;
                
                if (currentAnalysisElement.inventoryTemplateId) {
                    url += `&inventoryTemplateId=${currentAnalysisElement.inventoryTemplateId}`;
                }
                
                const roomCategory = document.getElementById('analyseRoomCategoryFilter')?.value;
                if (roomCategory) {
                    url += `&roomCategory=${encodeURIComponent(roomCategory)}`;
                }
                
                const search = document.getElementById('analyseSearch')?.value?.trim();
                if (search) {
                    url += `&search=${encodeURIComponent(search)}`;
                }
                
                if (currentStatusFilter && currentStatusFilter !== 'all') {
                    url += `&status=${currentStatusFilter}`;
                }
                
                const response = await fetch(url);
                const data = await response.json();
                
                if (response.ok && data.success) {
                    analyseData = data.rows || [];
                    
                    // Update room category filter
                    updateRoomCategoryFilter(data.roomCategories || []);
                    
                    // Update tolerance settings display
                    document.getElementById('toleranceMin').value = data.toleranceMin;
                    document.getElementById('toleranceMax').value = data.toleranceMax;
                    toleranceSettings.min = data.toleranceMin;
                    toleranceSettings.max = data.toleranceMax;
                    
                    // Render table and KPIs
                    renderAnalyseTableNew(analyseData);
                    updateKPIWidgetNew(data);
                    
                    showResult('analyseResult', 'success', `‚úÖ ${analyseData.length} Eintr√§ge geladen`);
                } else {
                    showResult('analyseResult', 'error', `‚ùå ${data.message || 'Fehler beim Laden'}`);
                }
            } catch (error) {
                console.error('Error loading analyse data:', error);
                showResult('analyseResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Updates the room category filter dropdown
         */
        function updateRoomCategoryFilter(categories) {
            const select = document.getElementById('analyseRoomCategoryFilter');
            const currentValue = select.value;
            
            let html = '<option value="">-- Alle --</option>';
            categories.forEach(cat => {
                const selected = cat === currentValue ? 'selected' : '';
                html += `<option value="${escapeHtml(cat)}" ${selected}>${escapeHtml(cat)}</option>`;
            });
            
            select.innerHTML = html;
        }
        
        /**
         * Renders the redesigned analysis table
         */
        function renderAnalyseTableNew(rows) {
            const tbody = document.getElementById('analyseTableBody');
            if (!tbody) return;
            
            if (!rows || rows.length === 0) {
                tbody.innerHTML = '<tr><td colspan="10" style="text-align:center; color:#666;">Keine Daten vorhanden.</td></tr>';
                return;
            }
            
            let html = '';
            rows.forEach((row, index) => {
                const statusClass = getAnalysisStatusClass(row.status);
                const rowClass = getAnalysisRowClass(row.status);
                const deviationPercent = row.deviationPercent !== null && row.deviationPercent !== undefined && typeof row.deviationPercent === 'number' 
                    ? row.deviationPercent.toFixed(2) + '%' : '-';
                const deviationValue = row.deviationValue !== null && row.deviationValue !== undefined && typeof row.deviationValue === 'number'
                    ? row.deviationValue.toFixed(2) : '-';
                const lastUpdated = row.lastUpdated ? new Date(row.lastUpdated).toLocaleString('de-DE') : '-';
                const statusText = (row.statusText || '').toLowerCase() || 'erf√ºllt';
                const sollValueStr = typeof row.sollValue === 'number' ? row.sollValue.toFixed(2) : '0.00';
                const istValueStr = typeof row.istValue === 'number' ? row.istValue.toFixed(2) : '0.00';
                
                html += `
                    <tr class="analyse-row ${rowClass}" data-status="${statusText}" 
                        data-room-id="${row.roomID}" data-inventory-id="${row.roomInventoryID || ''}" 
                        data-index="${index}">
                        <td>${escapeHtml(row.roomTypeName || '-')}</td>
                        <td>${escapeHtml(row.roomCategory || '-')}</td>
                        <td>${escapeHtml(row.roomName || '-')}</td>
                        <td>${sollValueStr}</td>
                        <td>${istValueStr}</td>
                        <td>${deviationPercent}</td>
                        <td>${deviationValue}</td>
                        <td><span class="status-badge ${statusClass}">${escapeHtml(row.statusText || 'Erf√ºllt')}</span></td>
                        <td><input type="text" class="form-control analysis-comment-input" 
                            value="${escapeHtml(row.commentIst || '')}" 
                            data-room-id="${row.roomID}"
                            data-inventory-id="${row.roomInventoryID || ''}"
                            placeholder="Kommentar..." 
                            style="width:150px;"
                            oninput="onAnalysisCommentChange(this)"></td>
                        <td>${lastUpdated}</td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
        }
        
        /**
         * Gets row CSS class based on status code
         */
        function getAnalysisRowClass(status) {
            switch(status) {
                case -1: return 'analyse-row-under';
                case 1: return 'analyse-row-over';
                case 0: 
                default: return 'analyse-row-ok';
            }
        }
        
        /**
         * Gets status badge CSS class based on status code
         */
        function getAnalysisStatusClass(status) {
            switch(status) {
                case -1: return 'status-under';
                case 1: return 'status-over';
                case 0: 
                default: return 'status-ok';
            }
        }
        
        /**
         * Updates KPI widgets with new API data
         */
        function updateKPIWidgetNew(data) {
            const sollTotal = document.getElementById('kpiSollTotal');
            const istTotal = document.getElementById('kpiIstTotal');
            const deviation = document.getElementById('kpiDeviation');
            const okCount = document.getElementById('kpiOkCount');
            const underCount = document.getElementById('kpiUnderCount');
            const overCount = document.getElementById('kpiOverCount');
            
            sollTotal.textContent = data.totalSoll ? data.totalSoll.toFixed(2) : '0';
            istTotal.textContent = data.totalIst ? data.totalIst.toFixed(2) : '0';
            
            // Calculate total deviation percentage
            if (data.totalSoll && data.totalSoll > 0) {
                const deviationPct = ((data.totalIst - data.totalSoll) / data.totalSoll) * 100;
                deviation.textContent = deviationPct.toFixed(2) + '%';
            } else {
                deviation.textContent = '-';
            }
            
            okCount.textContent = data.countErfuellt || 0;
            underCount.textContent = data.countUnterschritten || 0;
            overCount.textContent = data.countUeberschritten || 0;
        }
        
        /**
         * Handles IST comment changes (autosave)
         */
        function onAnalysisCommentChange(input) {
            const roomId = parseInt(input.dataset.roomId);
            const inventoryId = input.dataset.inventoryId ? parseInt(input.dataset.inventoryId) : null;
            const key = `comment-${roomId}-${inventoryId || ''}`;
            
            // Clear existing timer
            if (analysisCommentTimers.has(key)) {
                clearTimeout(analysisCommentTimers.get(key));
            }
            
            // Set new timer
            analysisCommentTimers.set(key, setTimeout(async () => {
                await saveAnalysisComment(input, roomId, inventoryId);
                analysisCommentTimers.delete(key);
            }, ANALYSIS_AUTOSAVE_DELAY));
        }
        
        /**
         * Saves an analysis comment
         */
        async function saveAnalysisComment(input, roomId, inventoryId) {
            try {
                input.style.backgroundColor = '#fff3cd'; // Yellow during save
                
                const requestBody = {
                    elementType: currentAnalysisElement.type,
                    roomID: roomId,
                    roomInventoryID: inventoryId || null,
                    commentIst: input.value,
                    userId: getCurrentUserId()
                };
                
                const response = await fetch(`${API_ANALYSIS}/comment`, {
                    method: 'PUT',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                if (response.ok) {
                    input.style.backgroundColor = '#d4edda'; // Green on success
                    setTimeout(() => { input.style.backgroundColor = ''; }, 1000);
                } else {
                    input.style.backgroundColor = '#f8d7da'; // Red on error
                    setTimeout(() => { input.style.backgroundColor = ''; }, 2000);
                }
            } catch (error) {
                console.error('Error saving comment:', error);
                input.style.backgroundColor = '#f8d7da';
                setTimeout(() => { input.style.backgroundColor = ''; }, 2000);
            }
        }
        
        /**
         * Recalculates and saves deviations to database
         */
        async function recalculateAndSaveDeviations() {
            if (!currentAnalysisElement.type) {
                showResult('analyseResult', 'error', '‚ö†Ô∏è Bitte zuerst ein Analyseelement ausw√§hlen');
                return;
            }
            
            showResult('analyseResult', 'loading', '‚è≥ Berechne und speichere Abweichungen...');
            
            try {
                const requestBody = {
                    elementType: currentAnalysisElement.type,
                    inventoryTemplateID: currentAnalysisElement.inventoryTemplateId,
                    toleranceMin: toleranceSettings.min,
                    toleranceMax: toleranceSettings.max,
                    userId: getCurrentUserId()
                };
                
                const response = await fetch(`${API_ANALYSIS}/compute`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    showResult('analyseResult', 'success', `‚úÖ ${data.updatedCount} Eintr√§ge aktualisiert`);
                    // Reload data
                    await loadAnalyseData();
                } else {
                    showResult('analyseResult', 'error', `‚ùå ${data.message || 'Fehler beim Berechnen'}`);
                }
            } catch (error) {
                console.error('Error computing deviations:', error);
                showResult('analyseResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Renders the analyse table with the given data
         */
        function renderAnalyseTable(data) {
            const tbody = document.getElementById('analyseTableBody');
            if (!tbody) return;

            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; color:#666;">Keine Daten vorhanden.</td></tr>';
                return;
            }

            let html = '';
            data.forEach((item, index) => {
                const percentage = getItemProp(item, 'percentage', 'Percentage', 0);
                const sollArea = getItemProp(item, 'sollArea', 'SollArea', 0);
                const istArea = getItemProp(item, 'istArea', 'IstArea', 0);
                const raumtyp = getItemProp(item, 'raumtyp', 'Raumtyp', null) ||
                    getItemProp(item, 'roomCategory', 'RoomCategory', '-');
                const raumkategorie = getItemProp(item, 'raumkategorie', 'Raumkategorie', '');
                const comment = getItemProp(item, 'comment', 'Comment', '');

                // Determine status based on tolerance settings
                const status = getStatus(percentage, sollArea, istArea);
                const statusClass = getStatusClass(status);
                // Color logic: Red for Unterschritten, Green for Erf√ºllt, Yellow for √úberschritten
                let rowClass = '';
                if (status === 'Unterschritten' || sollArea === 0) {
                    rowClass = 'analyse-row-under';
                } else if (status === 'Erf√ºllt') {
                    rowClass = 'analyse-row-ok';
                } else if (status === '√úberschritten') {
                    rowClass = 'analyse-row-over';
                }

                // Create visual bar
                const barHtml = createProgressBar(percentage);

                html += `
                        <tr class="analyse-row ${rowClass}" data-status="${status.toLowerCase()}" data-index="${index}">
                            <td>${escapeHtml(raumtyp)}</td>
                            <td><input type="text" class="kategorie-input form-control" value="${escapeHtml(raumkategorie)}" data-index="${index}" data-field="raumkategorie" style="width:100px; padding:4px;" onchange="onAnalyseFieldChange(${index})"></td>
                            <td><input type="number" class="soll-input form-control" value="${sollArea.toFixed(2)}" data-index="${index}" data-field="sollArea" step="0.01" style="width:80px; padding:4px;" onchange="onSollChange(${index})"></td>
                            <td>${istArea.toFixed(2)}</td>
                            <td>${barHtml}</td>
                            <td><span class="status-badge ${statusClass}" data-index="${index}">${status}</span></td>
                            <td><input type="text" class="comment-input" value="${escapeHtml(comment)}" data-index="${index}" data-field="comment" placeholder="Kommentar..." onchange="onAnalyseFieldChange(${index})"></td>
                        </tr>
                    `;
            });

            tbody.innerHTML = html;
        }

        /**
         * Determines the status based on percentage and tolerance settings
         * Status values: Erf√ºllt (within tolerance), Unterschritten (IST < SOLL), √úberschritten (IST > SOLL)
         */
        function getStatus(percentage, sollArea, istArea) {
            // Handle null/undefined/NaN cases
            if (percentage == null || isNaN(percentage)) return 'Erf√ºllt';

            // SOLL=0 is considered Unterschritten (red)
            if (sollArea === 0) return 'Unterschritten';

            // Both zero = Erf√ºllt
            if (sollArea <= 0 && istArea <= 0) return 'Erf√ºllt';

            const deviation = percentage - 100;

            // IST < SOLL = Unterschritten (red)
            if (deviation < toleranceSettings.min) {
                return 'Unterschritten';
                // IST > SOLL = √úberschritten (no color in Excel, yellow in UI)
            } else if (deviation > toleranceSettings.max) {
                return '√úberschritten';
            }
            // Within tolerance = Erf√ºllt (green)
            return 'Erf√ºllt';
        }

        /**
         * Gets the CSS class for status badge
         */
        function getStatusClass(status) {
            switch (status) {
                case 'Unterschritten': return 'status-under';
                case '√úberschritten': return 'status-over';
                default: return 'status-ok';
            }
        }

        // Constants for progress bar visualization
        const PROGRESS_BAR_MAX_PERCENT = 150;
        const DEVIATION_INTENSITY_DIVISOR = 30;

        /**
         * Creates a visual progress bar for SOLL/IST comparison
         */
        function createProgressBar(percentage) {
            // Handle null/undefined/NaN cases
            if (percentage == null || isNaN(percentage)) percentage = 0;

            const width = Math.min(Math.max(percentage, 0), PROGRESS_BAR_MAX_PERCENT);
            const barWidth = (width / PROGRESS_BAR_MAX_PERCENT) * 100;
            const markerPos = (100 / PROGRESS_BAR_MAX_PERCENT) * 100; // 100% marker position

            let barColor = '#2E8540'; // Green for OK
            if (percentage < 100 - Math.abs(toleranceSettings.min)) {
                barColor = '#D64545'; // Red for under
            } else if (percentage > 100 + toleranceSettings.max) {
                barColor = '#FFBF47'; // Yellow for over
            }

            // Color intensity based on deviation
            const deviation = Math.abs(percentage - 100);
            const intensity = Math.min(deviation / DEVIATION_INTENSITY_DIVISOR, 1);

            return `
                    <div class="progress-bar-container">
                        <div class="progress-bar-bg">
                            <div class="progress-bar-fill" style="width:${barWidth}%; background-color:${barColor}; opacity:${0.4 + intensity * 0.6};"></div>
                            <div class="progress-bar-marker" style="left:${markerPos}%;"></div>
                        </div>
                        <span class="progress-bar-label">${percentage.toFixed(0)}%</span>
                    </div>
                `;
        }

        /**
         * Updates the KPI widget with summary data
         */
        function updateKPIWidget(data) {
            if (!data || data.length === 0) return;

            let totalSoll = 0;
            let totalIst = 0;
            let okCount = 0;
            let underCount = 0;
            let overCount = 0;

            data.forEach(item => {
                const soll = getItemProp(item, 'sollArea', 'SollArea', 0);
                const ist = getItemProp(item, 'istArea', 'IstArea', 0);
                const percentage = getItemProp(item, 'percentage', 'Percentage', 0);

                totalSoll += soll;
                totalIst += ist;

                const status = getStatus(percentage, soll, ist);
                if (status === 'Erf√ºllt') okCount++;
                else if (status === 'Unterschritten') underCount++;
                else if (status === '√úberschritten') overCount++;
            });

            const deviation = totalSoll > 0 ? ((totalIst / totalSoll) * 100 - 100).toFixed(1) : 0;

            document.getElementById('kpiSollTotal').textContent = totalSoll.toFixed(2) + ' m¬≤';
            document.getElementById('kpiIstTotal').textContent = totalIst.toFixed(2) + ' m¬≤';
            document.getElementById('kpiDeviation').textContent = (deviation >= 0 ? '+' : '') + deviation + '%';
            document.getElementById('kpiOkCount').textContent = okCount;
            document.getElementById('kpiUnderCount').textContent = underCount;
            document.getElementById('kpiOverCount').textContent = overCount;

            // Color the deviation based on value
            const deviationEl = document.getElementById('kpiDeviation');
            if (deviation < toleranceSettings.min) {
                deviationEl.style.color = '#D64545';
            } else if (deviation > toleranceSettings.max) {
                deviationEl.style.color = '#FFBF47';
            } else {
                deviationEl.style.color = '#2E8540';
            }
        }

        /**
         * Filters the analyse table by status (using API)
         */
        function filterAnalyseTable(filter) {
            // Update active button
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.filter-btn[data-filter="${filter}"]`)?.classList.add('active');
            
            // Set current filter and reload data
            currentStatusFilter = filter;
            loadAnalyseData();
        }

        /**
         * Searches the analyse table (legacy - now handled by API)
         */
        function searchAnalyseTable() {
            onAnalysisFilterChange();
        }

        /**
         * Sorts the analyse table by column
         */
        let sortDirection = {};
        function sortAnalyseTable(columnIndex) {
            const table = document.getElementById('analyseTable');
            const tbody = document.getElementById('analyseTableBody');
            const rows = Array.from(tbody.querySelectorAll('tr.analyse-row'));

            if (rows.length === 0) return;

            // Toggle sort direction
            sortDirection[columnIndex] = !sortDirection[columnIndex];
            const ascending = sortDirection[columnIndex];

            rows.sort((a, b) => {
                let aVal = (a.cells && a.cells[columnIndex] && a.cells[columnIndex].textContent) ? a.cells[columnIndex].textContent : '';
                let bVal = (b.cells && b.cells[columnIndex] && b.cells[columnIndex].textContent) ? b.cells[columnIndex].textContent : '';

                // Try to parse as numbers
                const aNum = parseFloat(aVal.replace(/[^0-9.-]/g, ''));
                const bNum = parseFloat(bVal.replace(/[^0-9.-]/g, ''));

                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return ascending ? aNum - bNum : bNum - aNum;
                }

                return ascending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            });

            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        /**
         * Saves analyse changes (comments, Raumkategorie, SOLL) to JSON config and Excel
         * Updates both Raumbuch sheet (all rooms by category) and Zusammenfassung sheet
         */
        async function saveAnalyseChanges() {
            showResult('analyseResult', 'loading', '‚è≥ Speichere √Ñnderungen...');

            try {
                // Collect all editable field values from inputs
                analyseData.forEach((item, index) => {
                    const kategorieInput = document.querySelector(`.kategorie-input[data-index="${index}"]`);
                    const sollInput = document.querySelector(`.soll-input[data-index="${index}"]`);
                    const commentInput = document.querySelector(`.comment-input[data-index="${index}"]`);

                    if (kategorieInput) {
                        item.raumkategorie = kategorieInput.value;
                        item.Raumkategorie = kategorieInput.value;
                    }
                    if (sollInput) {
                        item.sollArea = parseFloat(sollInput.value) || 0;
                        item.SollArea = item.sollArea;
                        // Recalculate percentage
                        const istArea = item.istArea || item.IstArea || 0;
                        item.percentage = item.sollArea > 0 ? (istArea / item.sollArea) * 100 : 0;
                        item.Percentage = item.percentage;
                    }
                    if (commentInput) {
                        item.comment = commentInput.value;
                        item.Comment = commentInput.value;
                    }

                    // Calculate status for saving
                    const status = getStatus(item.percentage, item.sollArea, item.istArea || item.IstArea);
                    item.status = status;
                    item.Status = status;
                });

                // Update config
                currentConfig.zusammenfassung = analyseData;

                // Save config to Azure
                const configName = document.getElementById('configName').value.trim();
                if (!configName) {
                    showResult('analyseResult', 'error', '‚ö†Ô∏è Bitte geben Sie einen Konfigurationsnamen ein');
                    return;
                }

                // Update the Excel file with all changes (Raumbuch + Zusammenfassung sheets)
                const token = getToken();
                const raumbuchFileId = document.getElementById('raumbuchFile')?.value;
                const targetFolderId = document.getElementById('targetFolder')?.value;

                let excelUpdateSuccess = false;
                if (token && raumbuchFileId && targetFolderId) {
                    try {
                        const updateResponse = await fetch(`${API_BASE}/update-zusammenfassung`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                accessToken: token,
                                raumbuchFileId: raumbuchFileId,
                                targetFolderId: targetFolderId,
                                zusammenfassung: analyseData,
                                toleranceMin: toleranceSettings.min,
                                toleranceMax: toleranceSettings.max
                            })
                        });

                        if (updateResponse.ok) {
                            const updateData = await updateResponse.json();
                            if (updateData.success) {
                                excelUpdateSuccess = true;
                                console.log('Excel updated successfully');
                            }
                        }
                    } catch (excelError) {
                        console.error('Error updating Excel:', excelError);
                        // Continue with JSON save even if Excel update fails
                    }
                }

                // Build full configuration and save to JSON
                await saveConfig();

                if (excelUpdateSuccess) {
                    showResult('analyseResult', 'success', '‚úÖ √Ñnderungen in Excel und Konfiguration gespeichert');
                } else {
                    showResult('analyseResult', 'success', '‚úÖ √Ñnderungen in Konfiguration gespeichert (Excel-Update nicht m√∂glich)');
                }
            } catch (error) {
                console.error('Error saving analyse changes:', error);
                showResult('analyseResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Auto-save configuration silently when certain actions are performed
         */
        async function autoSaveConfig() {
            const configName = document.getElementById('configName').value.trim();
            const projectId = getProjectId();

            if (!configName || !projectId) {
                console.log('Auto-save skipped: no config name or project ID');
                return;
            }

            try {
                // Build full configuration including all user choices
                const config = {
                    projectId: projectId,
                    projectName: configName,
                    lastUpdated: new Date().toISOString(),
                    targetFolder: getSelectedOption('targetFolder'),
                    files: {
                        template: getSelectedOption('templateFile'),
                        ifcModel: getSelectedOption('ifcFile'),
                        raumbuch: getSelectedOption('raumbuchFile')
                    },
                    bcfAssignees: getSelectedUsers(),
                    zusammenfassung: currentConfig.zusammenfassung || [],
                    toleranceMin: toleranceSettings.min,
                    toleranceMax: toleranceSettings.max,
                    toleranceProfiles: currentConfig.toleranceProfiles || [],
                    inventoryFolder: getSelectedOption('inventoryFolder'),
                    psetPartialName: document.getElementById('psetPartialName')?.value || 'Plancal nova',
                    roomPropertyName: document.getElementById('roomPropertyName')?.value || 'Room Nbr',
                    selectedIfcFiles: getSelectedIfcFiles(),
                    selectedProperties: getSelectedProperties()
                };

                // Update currentConfig
                Object.assign(currentConfig, config);

                const response = await fetch(`${API_PROJECT}/config/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        configName: configName,
                        configuration: config
                    })
                });

                if (response.ok) {
                    console.log('Config auto-saved successfully');
                }
            } catch (error) {
                console.error('Auto-save error:', error);
            }
        }

        /**
         * Gets selected IFC files from checkbox list
         */
        function getSelectedIfcFiles() {
            const checkboxes = document.querySelectorAll('#ifcFilesList input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => ({
                id: cb.value,
                name: cb.dataset.name || ''
            }));
        }

        /**
         * Gets selected properties from multi-select
         */
        function getSelectedProperties() {
            const select = document.getElementById('additionalProperties');
            if (!select) return [];
            return Array.from(select.selectedOptions).map(opt => opt.value);
        }

        /**
         * Escapes HTML to prevent XSS
         */
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        /**
         * Helper function to get property from item with both camelCase and PascalCase fallback
         * @param {object} item - The data item
         * @param {string} camelCase - Property name in camelCase (e.g., 'sollArea')
         * @param {string} pascalCase - Property name in PascalCase (e.g., 'SollArea')
         * @param {*} defaultValue - Default value if property not found
         */
        function getItemProp(item, camelCase, pascalCase, defaultValue) {
            if (!item) return defaultValue;
            return item[camelCase] ?? item[pascalCase] ?? defaultValue;
        }

        // Store column mappings
        let columnMappings = {
            raumtyp: '',
            raumkategorie: '',
            flaecheSoll: ''
        };

        // Store template headers
        let templateHeaders = [];

        /**
         * Loads template headers for column mapping
         */
        async function loadTemplateHeaders() {
            const token = getToken();
            const templateFileId = document.getElementById('templateFile').value;

            if (!token || !templateFileId) {
                showResult('step1Result', 'error', '‚ö† Bitte Vorlagendatei ausw√§hlen');
                return;
            }

            showResult('step1Result', 'loading', '‚è≥ Lade Spalten√ºberschriften...');

            try {
                const response = await fetch(`${API_BASE}/get-template-headers`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        templateFileId: templateFileId
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    templateHeaders = data.headers || [];

                    // Populate mapping dropdowns
                    const mappingSelects = ['mappingRaumtyp', 'mappingRaumkategorie', 'mappingFlaecheSoll'];
                    mappingSelects.forEach(selectId => {
                        const select = document.getElementById(selectId);
                        if (select) {
                            select.innerHTML = '<option value="">-- Spalte w√§hlen --</option>';
                            templateHeaders.forEach((header, index) => {
                                const option = document.createElement('option');
                                option.value = index.toString();
                                option.textContent = `${getColumnLetter(index)}: ${header}`;
                                select.appendChild(option);
                            });
                        }
                    });

                    // Set default mappings if columns exist - with validation
                    // Default: A=Raumtyp, F=Raumkategorie, G=Fl√§che Soll
                    if (templateHeaders.length >= 1) {
                        document.getElementById('mappingRaumtyp').value = '0'; // Column A
                    }
                    if (templateHeaders.length >= 6) {
                        document.getElementById('mappingRaumkategorie').value = '5'; // Column F
                    } else {
                        // Leave Raumkategorie unmapped if not enough columns - will use IFC LongName
                        console.log('Template has fewer than 6 columns - Raumkategorie will be derived from IFC');
                    }
                    if (templateHeaders.length >= 7) {
                        document.getElementById('mappingFlaecheSoll').value = '6'; // Column G
                    } else if (templateHeaders.length >= 4) {
                        // Fallback: try column D for Fl√§che Soll (older format)
                        document.getElementById('mappingFlaecheSoll').value = '3'; // Column D
                        console.log('Template has fewer than 7 columns - using column D for Fl√§che Soll');
                    }

                    // Show mapping table
                    document.getElementById('mappingTableContainer').style.display = 'block';

                    // Show helpful message with validation info
                    let message = `‚úÖ ${templateHeaders.length} Spalten geladen.`;
                    if (templateHeaders.length < 7) {
                        message += ` Hinweis: Weniger als 7 Spalten gefunden - bitte Zuordnung pr√ºfen.`;
                    } else {
                        message += ` Bitte Zuordnung pr√ºfen.`;
                    }
                    showResult('step1Result', 'success', message);
                } else {
                    const errorMsg = data.message || 'Fehler beim Laden';
                    showResult('step1Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error loading template headers:', error);
                showResult('step1Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Converts column index to Excel letter (0 = A, 1 = B, etc.)
         */
        function getColumnLetter(index) {
            let letter = '';
            while (index >= 0) {
                letter = String.fromCharCode((index % 26) + 65) + letter;
                index = Math.floor(index / 26) - 1;
            }
            return letter;
        }

        /**
         * Creates Raumbuch directly from template file using column mappings
         */
        async function createRaumbuch() {
            const token = getToken();
            const projectId = getProjectId();
            const templateFileId = document.getElementById('templateFile').value;
            const ifcFileId = document.getElementById('ifcFile').value;
            const targetFolder = getTargetFolder();

            // Get column mappings
            const raumtypCol = document.getElementById('mappingRaumtyp').value;
            const raumkategorieCol = document.getElementById('mappingRaumkategorie').value;
            const flaecheSollCol = document.getElementById('mappingFlaecheSoll').value;

            console.log('createRaumbuch() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Template File ID:', templateFileId);
            console.log('IFC File ID:', ifcFileId);
            console.log('Column mappings:', { raumtypCol, raumkategorieCol, flaecheSollCol });

            if (!token || !projectId || !templateFileId || !ifcFileId || !targetFolder) {
                let missingFields = [];
                if (!token) missingFields.push('Token');
                if (!projectId) missingFields.push('Project ID');
                if (!templateFileId) missingFields.push('Vorlagendatei');
                if (!ifcFileId) missingFields.push('IFC Datei');
                if (!targetFolder) missingFields.push('Zielordner');
                showResult('step3Result', 'error', `‚ö† Bitte alle Felder ausf√ºllen. Fehlende Felder: ${missingFields.join(', ')}`);
                return;
            }

            if (!raumtypCol || !flaecheSollCol) {
                showResult('step3Result', 'error', '‚ö† Bitte laden Sie die Vorlage und w√§hlen Sie mindestens Raumtyp und Fl√§che Soll Spalten aus');
                return;
            }

            showResult('step3Result', 'loading', '‚è≥ Erstelle Raumbuch... (kann einige Sekunden dauern)');

            try {
                const requestBody = {
                    accessToken: token,
                    projectId: projectId,
                    templateFileId: templateFileId,
                    ifcFileId: ifcFileId,
                    targetFolderId: targetFolder,
                    columnMappings: {
                        raumtypColumn: parseInt(raumtypCol),
                        raumkategorieColumn: raumkategorieCol ? parseInt(raumkategorieCol) : -1,
                        flaecheSollColumn: parseInt(flaecheSollCol)
                    }
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/create-raumbuch`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok) {
                    const fileName = data.raumbuchFileName || 'Raumbuch.xlsx';
                    const fileId = data.raumbuchFileId || 'N/A';

                    console.log('Raumbuch created successfully:', fileName, fileId);

                    // Save to config
                    currentConfig.files.raumbuch = {
                        id: fileId,
                        name: fileName
                    };

                    let message = `‚úÖ Raumbuch erstellt!<br>Datei: ${fileName}<br>‚è≥ Warte auf ID von Connect...`;
                    if (data.analysis && data.analysis.length > 0) {
                        message += '<br><br><strong>Analyse:</strong><br>';
                        data.analysis.forEach(a => {
                            const status = a.status || (a.percentage < 90 ? '‚ö†Ô∏è Zu wenig' : (a.percentage > 110 ? 'üìä Zu viel' : '‚úÖ OK'));
                            message += `- ${a.raumtyp || a.roomCategory}: ${a.percentage.toFixed(1)}% ${status}<br>`;
                        });
                    }

                    showResult('step3Result', 'loading', message);

                    // Poll for the file to get the actual Connect ID
                    const foundFile = await pollForFile(fileName);

                    if (foundFile) {
                        // Update config with correct ID
                        currentConfig.files.raumbuch.id = foundFile.id;

                        // Update dropdown
                        updateDropdownWithFile('raumbuchFile', foundFile);

                        message = `‚úÖ Raumbuch erfolgreich erstellt!<br>Datei: ${fileName}<br>ID: ${foundFile.id}<br>‚úÖ Raumbuch wurde zur Dropdown-Liste hinzugef√ºgt!`;
                        showResult('step3Result', 'success', message);
                    } else {
                        showResult('step3Result', 'warning', `‚ö†Ô∏è Raumbuch wurde erstellt, aber ID konnte nicht abgerufen werden. Bitte "Dateien laden" klicken.`);
                    }
                } else {
                    const errorMsg = data.message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step3Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in createRaumbuch:', error);
                showResult('step3Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Handles changes to SOLL values - recalculates percentage and status
         */
        function onSollChange(index) {
            const input = document.querySelector(`.soll-input[data-index="${index}"]`);
            if (!input || !analyseData[index]) return;

            const newSoll = parseFloat(input.value) || 0;
            const istArea = analyseData[index].istArea || analyseData[index].IstArea || 0;

            // Update the data
            analyseData[index].sollArea = newSoll;
            analyseData[index].SollArea = newSoll;

            // Recalculate percentage
            const newPercentage = newSoll > 0 ? (istArea / newSoll) * 100 : 0;
            analyseData[index].percentage = newPercentage;
            analyseData[index].Percentage = newPercentage;

            // Update the row
            updateAnalyseRow(index);
        }

        /**
         * Handles changes to other fields (Raumkategorie, Comment)
         */
        function onAnalyseFieldChange(index) {
            if (!analyseData[index]) return;

            // Update Raumkategorie
            const kategorieInput = document.querySelector(`.kategorie-input[data-index="${index}"]`);
            if (kategorieInput) {
                analyseData[index].raumkategorie = kategorieInput.value;
                analyseData[index].Raumkategorie = kategorieInput.value;
            }

            // Update Comment
            const commentInput = document.querySelector(`.comment-input[data-index="${index}"]`);
            if (commentInput) {
                analyseData[index].comment = commentInput.value;
                analyseData[index].Comment = commentInput.value;
            }
        }

        /**
         * Updates a single row in the analyse table
         */
        function updateAnalyseRow(index) {
            const row = document.querySelector(`.analyse-row[data-index="${index}"]`);
            if (!row || !analyseData[index]) return;

            const item = analyseData[index];
            const percentage = item.percentage || item.Percentage || 0;
            const sollArea = item.sollArea || item.SollArea || 0;
            const istArea = item.istArea || item.IstArea || 0;

            // Determine status
            const status = getStatus(percentage, sollArea, istArea);
            const statusClass = getStatusClass(status);

            // Color logic: Red for Unterschritten, Green for Erf√ºllt, Yellow for √úberschritten
            let rowClass = '';
            if (status === 'Unterschritten' || sollArea === 0) {
                rowClass = 'analyse-row-under';
            } else if (status === 'Erf√ºllt') {
                rowClass = 'analyse-row-ok';
            } else if (status === '√úberschritten') {
                rowClass = 'analyse-row-over';
            }

            // Update row class
            row.className = `analyse-row ${rowClass}`;
            row.dataset.status = status.toLowerCase();

            // Update status badge
            const statusBadge = row.querySelector('.status-badge');
            if (statusBadge) {
                statusBadge.className = `status-badge ${statusClass}`;
                statusBadge.textContent = status;
            }

            // Update progress bar (column index 4)
            const cells = row.cells;
            if (cells && cells.length > 4) {
                cells[4].innerHTML = createProgressBar(percentage);
            }

            // Update KPI widget
            updateKPIWidget(analyseData);
        }

        /**
         * Recalculates status for all rows
         */
        function recalculateStatus() {
            if (!analyseData || analyseData.length === 0) {
                showResult('analyseResult', 'warning', '‚ö†Ô∏è Keine Daten zum Aktualisieren');
                return;
            }

            // Collect current values from inputs
            analyseData.forEach((item, index) => {
                const sollInput = document.querySelector(`.soll-input[data-index="${index}"]`);
                const kategorieInput = document.querySelector(`.kategorie-input[data-index="${index}"]`);
                const commentInput = document.querySelector(`.comment-input[data-index="${index}"]`);

                if (sollInput) {
                    item.sollArea = parseFloat(sollInput.value) || 0;
                    item.SollArea = item.sollArea;
                }
                if (kategorieInput) {
                    item.raumkategorie = kategorieInput.value;
                    item.Raumkategorie = kategorieInput.value;
                }
                if (commentInput) {
                    item.comment = commentInput.value;
                    item.Comment = commentInput.value;
                }

                // Recalculate percentage
                const istArea = item.istArea || item.IstArea || 0;
                item.percentage = item.sollArea > 0 ? (istArea / item.sollArea) * 100 : 0;
                item.Percentage = item.percentage;
            });

            // Re-render the table
            renderAnalyseTable(analyseData);
            updateKPIWidget(analyseData);

            showResult('analyseResult', 'success', '‚úÖ Status aktualisiert');
        }

        /**
         * Updates IST values from IFC file
         */
        async function updateIstValues() {
            const token = getToken();
            const ifcFileId = document.getElementById('ifcFile').value;

            if (!token || !ifcFileId) {
                showResult('analyseResult', 'error', '‚ö†Ô∏è Bitte IFC-Datei in Einstellungen ausw√§hlen');
                return;
            }

            if (!analyseData || analyseData.length === 0) {
                showResult('analyseResult', 'error', '‚ö†Ô∏è Bitte zuerst Daten laden');
                return;
            }

            showResult('analyseResult', 'loading', '‚è≥ Aktualisiere IST-Werte aus IFC...');

            try {
                const response = await fetch(`${API_BASE}/get-ist-from-ifc`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        ifcFileId: ifcFileId
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    // Update IST values in analyseData based on Raumkategorie
                    const istByCategory = data.istByCategory || {};
                    let updatedCount = 0;

                    analyseData.forEach(item => {
                        const kategorie = item.raumkategorie || item.Raumkategorie || item.raumtyp || item.Raumtyp || item.roomCategory || item.RoomCategory;
                        if (kategorie && istByCategory[kategorie] !== undefined) {
                            item.istArea = istByCategory[kategorie];
                            item.IstArea = istByCategory[kategorie];

                            // Recalculate percentage
                            const sollArea = item.sollArea || item.SollArea || 0;
                            item.percentage = sollArea > 0 ? (item.istArea / sollArea) * 100 : 0;
                            item.Percentage = item.percentage;
                            updatedCount++;
                        }
                    });

                    // Re-render table
                    renderAnalyseTable(analyseData);
                    updateKPIWidget(analyseData);

                    showResult('analyseResult', 'success', `‚úÖ ${updatedCount} IST-Werte aktualisiert`);
                } else {
                    const errorMsg = data.message || 'Fehler beim Laden';
                    showResult('analyseResult', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error updating IST values:', error);
                showResult('analyseResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        // ====================================================================
        //  RAUMPROGRAMM TAB FUNCTIONS (SQL Database)
        // ====================================================================

        const API_RAUMPROGRAM = '/api';
        let currentRaumprogramPage = 1;
        const raumprogramPageSize = 50;

        /**
         * Refresh all master data (room types and inventory templates)
         */
        async function refreshAllMasterData() {
            await Promise.all([
                loadRoomTypes(),
                loadInventoryTemplates()
            ]);
        }

        /**
         * Load room types from database
         */
        async function loadRoomTypes() {
            try {
                const response = await fetch(`${API_RAUMPROGRAM}/roomtype`);
                const data = await response.json();

                if (response.ok && data.success) {
                    const select = document.getElementById('existingRoomTypes');
                    const filterSelect = document.getElementById('raumprogram-filter-roomtype');
                    const istFilterSelect = document.getElementById('ist-filter-roomtype');
                    const roomSelect = document.getElementById('roomRoomType');

                    select.innerHTML = '';
                    filterSelect.innerHTML = '<option value="">-- Alle --</option>';
                    if (istFilterSelect) istFilterSelect.innerHTML = '<option value="">-- Alle --</option>';
                    roomSelect.innerHTML = '<option value="">-- Raumtyp ausw√§hlen --</option>';

                    (data.roomTypes || []).forEach(rt => {
                        const option = document.createElement('option');
                        option.value = rt.roomTypeID;
                        // Display name with category if available
                        option.textContent = rt.roomCategory ? `${rt.name} (${rt.roomCategory})` : rt.name;
                        select.appendChild(option);

                        const filterOption = document.createElement('option');
                        filterOption.value = rt.roomTypeID;
                        filterOption.textContent = rt.name;
                        filterSelect.appendChild(filterOption);

                        if (istFilterSelect) {
                            istFilterSelect.appendChild(filterOption.cloneNode(true));
                        }

                        const roomOption = document.createElement('option');
                        roomOption.value = rt.roomTypeID;
                        roomOption.textContent = rt.name;
                        roomSelect.appendChild(roomOption);
                    });

                    console.log(`Loaded ${data.roomTypes?.length || 0} room types`);
                }
            } catch (error) {
                console.error('Error loading room types:', error);
            }
        }

        /**
         * Load inventory templates from database
         */
        async function loadInventoryTemplates() {
            try {
                const response = await fetch(`${API_RAUMPROGRAM}/inventorytemplate`);
                const data = await response.json();

                if (response.ok && data.success) {
                    const select = document.getElementById('existingInventoryTemplates');
                    const filterSelect = document.getElementById('raumprogram-filter-inventory');
                    const istFilterSelect = document.getElementById('ist-filter-inventory');

                    select.innerHTML = '';
                    filterSelect.innerHTML = '<option value="">-- Alle --</option>';
                    if (istFilterSelect) istFilterSelect.innerHTML = '<option value="">-- Alle --</option>';

                    // Store inventory templates globally for dynamic table columns
                    window.inventoryTemplates = data.inventoryTemplates || [];

                    (data.inventoryTemplates || []).forEach(it => {
                        const option = document.createElement('option');
                        option.value = it.inventoryTemplateID;
                        // Show DataType and Unit in the display
                        let displayText = it.propertyName;
                        if (it.dataType && it.dataType !== 'Text') {
                            displayText += ` [${it.dataType}]`;
                        }
                        if (it.unit) {
                            displayText += ` (${it.unit})`;
                        }
                        option.textContent = displayText;
                        select.appendChild(option);

                        const filterOption = document.createElement('option');
                        filterOption.value = it.inventoryTemplateID;
                        filterOption.textContent = it.propertyName;
                        filterSelect.appendChild(filterOption);

                        if (istFilterSelect) {
                            istFilterSelect.appendChild(filterOption.cloneNode(true));
                        }
                    });

                    console.log(`Loaded ${data.inventoryTemplates?.length || 0} inventory templates`);
                }
            } catch (error) {
                console.error('Error loading inventory templates:', error);
            }
        }

        /**
         * Create a new room type
         */
        async function createRoomType() {
            // Check if building exists first
            if (!requireBuilding('masterDataResult')) {
                return;
            }
            
            const name = document.getElementById('newRoomTypeName').value.trim();
            const roomCategory = document.getElementById('newRoomTypeCategory')?.value?.trim() || '';

            if (!name) {
                showResult('masterDataResult', 'error', '‚ö†Ô∏è Bitte geben Sie einen Namen ein');
                return;
            }

            showResult('masterDataResult', 'loading', '‚è≥ Erstelle Raumtyp...');

            try {
                const response = await fetch(`${API_RAUMPROGRAM}/roomtype`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        name: name,
                        roomCategory: roomCategory,
                        userId: getCurrentUserId(),
                        buildingId: currentBuildingId
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult('masterDataResult', 'success', `‚úÖ ${data.message}`);
                    document.getElementById('newRoomTypeName').value = '';
                    document.getElementById('newRoomTypeCategory').value = '';
                    await loadRoomTypes();
                } else {
                    showResult('masterDataResult', 'error', `‚ùå ${data.message || 'Fehler'}`);
                }
            } catch (error) {
                showResult('masterDataResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Delete selected room type
         */
        async function deleteSelectedRoomType() {
            const select = document.getElementById('existingRoomTypes');
            const selectedId = select.value;

            if (!selectedId) {
                showResult('masterDataResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie einen Raumtyp aus');
                return;
            }

            const selectedText = select.options[select.selectedIndex].textContent;
            if (!confirm(`M√∂chten Sie den Raumtyp "${selectedText}" wirklich l√∂schen?`)) {
                return;
            }

            showResult('masterDataResult', 'loading', '‚è≥ L√∂sche Raumtyp...');

            try {
                const userId = getCurrentUserId();
                const url = userId
                    ? `${API_RAUMPROGRAM}/roomtype/${selectedId}?userId=${encodeURIComponent(userId)}`
                    : `${API_RAUMPROGRAM}/roomtype/${selectedId}`;
                const response = await fetch(url, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult('masterDataResult', 'success', `‚úÖ ${data.message}`);
                    await loadRoomTypes();
                } else {
                    showResult('masterDataResult', 'error', `‚ùå ${data.message || 'Fehler'}`);
                }
            } catch (error) {
                showResult('masterDataResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Create a new inventory template
         */
        async function createInventoryTemplate() {
            // Check if building exists first
            if (!requireBuilding('masterDataResult')) {
                return;
            }
            
            const propertyName = document.getElementById('newInventoryPropertyName').value.trim();
            const dataType = document.getElementById('newInventoryDataType')?.value || 'Text';
            const unit = document.getElementById('newInventoryUnit')?.value?.trim() || '';

            if (!propertyName) {
                showResult('masterDataResult', 'error', '‚ö†Ô∏è Bitte geben Sie einen Eigenschaftsnamen ein');
                return;
            }

            showResult('masterDataResult', 'loading', '‚è≥ Erstelle Ausstattungseigenschaft...');

            try {
                const response = await fetch(`${API_RAUMPROGRAM}/inventorytemplate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        propertyName: propertyName,
                        dataType: dataType,
                        unit: unit || null,
                        userId: getCurrentUserId()
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult('masterDataResult', 'success', `‚úÖ ${data.message}`);
                    document.getElementById('newInventoryPropertyName').value = '';
                    document.getElementById('newInventoryUnit').value = '';
                    await loadInventoryTemplates();
                } else {
                    showResult('masterDataResult', 'error', `‚ùå ${data.message || 'Fehler'}`);
                }
            } catch (error) {
                showResult('masterDataResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Delete selected inventory template
         */
        async function deleteSelectedInventoryTemplate() {
            const select = document.getElementById('existingInventoryTemplates');
            const selectedId = select.value;

            if (!selectedId) {
                showResult('masterDataResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie eine Eigenschaft aus');
                return;
            }

            const selectedText = select.options[select.selectedIndex].textContent;
            if (!confirm(`M√∂chten Sie die Eigenschaft "${selectedText}" wirklich l√∂schen?`)) {
                return;
            }

            showResult('masterDataResult', 'loading', '‚è≥ L√∂sche Eigenschaft...');

            try {
                const userId = getCurrentUserId();
                const url = userId
                    ? `${API_RAUMPROGRAM}/inventorytemplate/${selectedId}?userId=${encodeURIComponent(userId)}`
                    : `${API_RAUMPROGRAM}/inventorytemplate/${selectedId}`;
                const response = await fetch(url, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult('masterDataResult', 'success', `‚úÖ ${data.message}`);
                    await loadInventoryTemplates();
                } else {
                    showResult('masterDataResult', 'error', `‚ùå ${data.message || 'Fehler'}`);
                }
            } catch (error) {
                showResult('masterDataResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Create a new room - SOLL only (IST values managed in Ausgef√ºhrt tab)
         */
        async function createRoom() {
            // Check if building exists first
            if (!requireBuilding('roomManagementResult')) {
                return;
            }
            
            const roomTypeId = document.getElementById('roomRoomType').value;
            const name = document.getElementById('roomName').value.trim();
            const areaPlanned = document.getElementById('roomAreaPlanned').value;

            if (!roomTypeId || !name) {
                showResult('roomManagementResult', 'error', '‚ö†Ô∏è Bitte Raumtyp und Name eingeben');
                return;
            }

            showResult('roomManagementResult', 'loading', '‚è≥ Erstelle Raum...');

            try {
                const response = await fetch(`${API_RAUMPROGRAM}/room`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        roomTypeID: parseInt(roomTypeId),
                        name: name,
                        netAreaPlanned: areaPlanned ? parseFloat(areaPlanned) : null,
                        netAreaActual: null, // IST values managed in Ausgef√ºhrt tab
                        grossAreaPlanned: null,
                        grossAreaActual: null,
                        userId: getCurrentUserId(),
                        buildingId: currentBuildingId
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult('roomManagementResult', 'success', `‚úÖ ${data.message}`);
                    document.getElementById('roomName').value = '';
                    document.getElementById('roomAreaPlanned').value = '';
                    await loadRaumprogramData();
                } else {
                    showResult('roomManagementResult', 'error', `‚ùå ${data.message || 'Fehler'}`);
                }
            } catch (error) {
                showResult('roomManagementResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Load Raumprogramm data with pagination and filters
         */
        async function loadRaumprogramData(page = 1) {
            // Check if building is selected
            if (!checkBuildingSelected()) {
                return;
            }
            
            if (page < 1) page = 1;
            currentRaumprogramPage = page;

            const roomTypeId = document.getElementById('raumprogram-filter-roomtype')?.value || '';
            const inventoryId = document.getElementById('raumprogram-filter-inventory')?.value || '';
            const search = document.getElementById('raumprogram-search')?.value?.trim() || '';

            showResult('raumprogramResult', 'loading', '‚è≥ Lade Raumprogramm-Daten...');

            // Handle multiple inventory selection
            const inventorySelect = document.getElementById('raumprogram-filter-inventory');
            const selectedInventories = Array.from(inventorySelect?.selectedOptions || [])
                .map(opt => opt.value)
                .filter(v => v);

            try {
                let url = `${API_RAUMPROGRAM}/raumprogram?page=${page}&pageSize=${raumprogramPageSize}`;
                if (currentBuildingId) url += `&buildingId=${currentBuildingId}`;
                if (roomTypeId) url += `&roomTypeId=${roomTypeId}`;

                if (selectedInventories.length === 1) {
                    url += `&inventoryTemplateId=${selectedInventories[0]}`;
                }

                if (search) url += `&search=${encodeURIComponent(search)}`;

                const response = await fetch(url);
                const data = await response.json();

                if (response.ok && data.success) {
                    // Store rooms for later use when saving changes
                    window.currentRooms = data.rooms || [];
                    renderRaumprogramTable(data.rooms || [], selectedInventories);
                    updateRaumprogramPagination(data);
                    showResult('raumprogramResult', 'success', `‚úÖ ${data.totalCount} R√§ume gefunden`);
                    
                    // Update indicators - need to fetch full data without search filter and without pagination
                    await updateSollIndicatorsFromApi(roomTypeId, selectedInventories);
                } else {
                    showResult('raumprogramResult', 'error', `‚ùå ${data.message || 'Fehler beim Laden'}`);
                }
            } catch (error) {
                console.error('Error loading Raumprogramm data:', error);
                showResult('raumprogramResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Fetch data for indicators - without search filter, with full result set
         * Only applies Raumtyp and Inventar filters
         * Note: Uses large pageSize to get all rooms. For very large datasets, 
         * consider implementing a dedicated backend endpoint for indicator calculations.
         */
        async function updateSollIndicatorsFromApi(roomTypeId, selectedInventories) {
            try {
                // Get current search filter to apply to indicators as well
                const search = document.getElementById('raumprogram-search')?.value?.trim() || '';
                
                // Fetch all rooms with the same filters (including search) for accurate indicator counts
                // Note: The inventory filter is applied client-side since the API only supports single inventory filtering
                let url = `${API_RAUMPROGRAM}/raumprogram?page=1&pageSize=10000`;
                if (roomTypeId) url += `&roomTypeId=${roomTypeId}`;
                if (search) url += `&search=${encodeURIComponent(search)}`;
                // Don't filter by inventory in API - we handle multiple selections client-side

                const response = await fetch(url);
                const data = await response.json();

                if (response.ok && data.success) {
                    updateSollIndicators(data.rooms || [], selectedInventories);
                }
            } catch (error) {
                console.error('Error updating indicators:', error);
            }
        }

        /**
         * Render Raumprogramm data table - SOLL only with EDITABLE columns
         */
        function renderRaumprogramTable(rooms, selectedInventoryIds = []) {
            const thead = document.getElementById('raumprogramTableHead');
            const tbody = document.getElementById('raumprogramTableBody');

            // Get column visibility settings
            const showRaumtyp = document.getElementById('col-raumtyp')?.checked ?? true;
            const showRaumkategorie = document.getElementById('col-raumkategorie')?.checked ?? true;
            const showRaum = document.getElementById('col-raum')?.checked ?? true;
            const showNetArea = document.getElementById('col-netarea')?.checked ?? true;
            const showGrossArea = document.getElementById('col-grossarea')?.checked ?? true;
            const showDescription = document.getElementById('col-description')?.checked ?? false;
            const showObjectType = document.getElementById('col-objecttype')?.checked ?? false;
            const showPredefinedType = document.getElementById('col-predefinedtype')?.checked ?? false;

            // Get selected inventory templates for column headers
            const templates = window.inventoryTemplates || [];
            const selectedTemplates = selectedInventoryIds.length > 0
                ? templates.filter(t => selectedInventoryIds.includes(String(t.inventoryTemplateID)))
                : [];

            // Show comment column only when single inventory selected
            const showComment = selectedInventoryIds.length === 1;

            // Build dynamic headers
            let headerHtml = '<tr>';
            if (showRaumtyp) headerHtml += '<th>Raumtyp</th>';
            if (showRaumkategorie) headerHtml += '<th>Raumkategorie</th>';
            if (showRaum) headerHtml += '<th>Raum</th>';
            if (showNetArea) headerHtml += '<th>Nettofl√§che (m¬≤)</th>';
            if (showGrossArea) headerHtml += '<th>Bruttofl√§che (m¬≤)</th>';
            if (showDescription) headerHtml += '<th>Beschreibung</th>';
            if (showObjectType) headerHtml += '<th>Objekttyp</th>';
            if (showPredefinedType) headerHtml += '<th>Vordefinierter Typ</th>';

            // Add inventory columns
            selectedTemplates.forEach(t => {
                const unit = t.unit ? ` (${t.unit})` : '';
                headerHtml += `<th>${escapeHtml(t.propertyName)}${unit}</th>`;
            });
            if (showComment) {
                headerHtml += '<th>Kommentar</th>';
            }
            headerHtml += '<th>Aktionen</th>';
            headerHtml += '</tr>';
            thead.innerHTML = headerHtml;

            // Calculate column count for empty message
            let colCount = 1; // For actions column
            if (showRaumtyp) colCount++;
            if (showRaumkategorie) colCount++;
            if (showRaum) colCount++;
            if (showNetArea) colCount++;
            if (showGrossArea) colCount++;
            if (showDescription) colCount++;
            if (showObjectType) colCount++;
            if (showPredefinedType) colCount++;
            colCount += selectedTemplates.length;
            if (showComment) colCount++;

            if (!rooms || rooms.length === 0) {
                tbody.innerHTML = `<tr><td colspan="${colCount || 6}" style="text-align:center; color:#666;">Keine Daten vorhanden.</td></tr>`;
                return;
            }

            // Get predefined types for dropdown
            const predefinedTypes = window.predefinedTypes || [];

            let html = '';
            rooms.forEach(room => {
                html += `<tr data-room-id="${room.roomID}">`;
                
                // Non-editable columns
                if (showRaumtyp) html += `<td>${escapeHtml(room.roomTypeName || '')}</td>`;
                if (showRaumkategorie) html += `<td>${escapeHtml(room.roomCategory || '')}</td>`;
                if (showRaum) html += `<td>${escapeHtml(room.name || '')}</td>`;
                
                // Editable columns
                if (showNetArea) {
                    html += `<td><input type="number" class="form-control soll-input" data-field="netAreaPlanned" value="${room.netAreaPlanned || ''}" step="0.01" style="width:100px;"></td>`;
                }
                if (showGrossArea) {
                    html += `<td><input type="number" class="form-control soll-input" data-field="grossAreaPlanned" value="${room.grossAreaPlanned || ''}" step="0.01" style="width:100px;"></td>`;
                }
                if (showDescription) {
                    html += `<td><input type="text" class="form-control soll-input" data-field="description" value="${escapeHtml(room.description || '')}" style="width:150px;"></td>`;
                }
                if (showObjectType) {
                    html += `<td><input type="text" class="form-control soll-input" data-field="objectType" value="${escapeHtml(room.objectType || '')}" style="width:120px;"></td>`;
                }
                if (showPredefinedType) {
                    // Dropdown for predefined type
                    html += `<td><select class="form-control soll-input" data-field="predefinedType" style="width:130px;">`;
                    html += '<option value="">--</option>';
                    predefinedTypes.forEach(pt => {
                        const selected = (room.predefinedType === pt.name) ? 'selected' : '';
                        html += `<option value="${escapeHtml(pt.name)}" ${selected}>${escapeHtml(pt.name)}</option>`;
                    });
                    html += '</select></td>';
                }

                // Add editable columns for each selected inventory
                selectedTemplates.forEach(t => {
                    const inv = (room.inventory || []).find(i => i.inventoryTemplateID === t.inventoryTemplateID);
                    const value = inv?.valuePlanned || '';
                    const inputType = getInputTypeForDataType(t.dataType);
                    const dataType = t.dataType?.toLowerCase() || 'text';
                    
                    if (dataType === 'boolean') {
                        // For boolean, use checkbox with checked attribute
                        const isChecked = isTruthyBooleanValue(value) ? 'checked' : '';
                        html += `<td style="text-align:center;"><input type="checkbox" class="soll-input inventory-input inventory-boolean" data-template-id="${t.inventoryTemplateID}" data-room-id="${room.roomID}" data-datatype="boolean" ${isChecked} style="width:20px; height:20px;"></td>`;
                    } else {
                        html += `<td><input type="${inputType}" class="form-control soll-input inventory-input" data-template-id="${t.inventoryTemplateID}" data-room-id="${room.roomID}" data-datatype="${dataType}" value="${escapeHtml(value)}" style="width:120px;"></td>`;
                    }
                });

                // Add comment column if single inventory selected
                if (showComment && selectedTemplates.length === 1) {
                    const inv = (room.inventory || []).find(i => i.inventoryTemplateID === selectedTemplates[0].inventoryTemplateID);
                    const comment = inv?.comment || '';
                    html += `<td><input type="text" class="form-control soll-input inventory-comment" data-template-id="${selectedTemplates[0].inventoryTemplateID}" data-room-id="${room.roomID}" value="${escapeHtml(comment)}" style="width:150px;"></td>`;
                }

                // Actions column with delete button
                html += `<td><button class="btn btn-danger btn-sm" onclick="deleteSollRoom(${room.roomID})" title="Raum l√∂schen">üóëÔ∏è</button></td>`;
                
                html += '</tr>';
            });

            tbody.innerHTML = html;
            
            // Attach autosave listeners after rendering
            attachAutosaveListeners();
        }

        /**
         * Update the SOLL page indicator cards based on current filtered data
         * Indicators update based on Raumtyp and Inventar filters AND search filter
         */
        function updateSollIndicators(rooms, selectedInventoryIds = []) {
            const templates = window.inventoryTemplates || [];
            
            // Filter inventory templates based on selection
            const selectedTemplates = selectedInventoryIds.length > 0
                ? templates.filter(t => selectedInventoryIds.includes(String(t.inventoryTemplateID)))
                : templates;
            
            // 1. Count distinct room types
            const uniqueRoomTypes = new Set(rooms.map(r => r.roomTypeID));
            const roomTypeCount = uniqueRoomTypes.size;
            
            // 2. Count total rooms
            const roomCount = rooms.length;
            
            // 3. Calculate inventory sum based on DataType interpretation
            let inventoryTotal = 0;
            
            rooms.forEach(room => {
                const inventoryItems = room.inventory || [];
                
                inventoryItems.forEach(inv => {
                    // Only count if in selected inventory templates (or all if none selected)
                    if (selectedInventoryIds.length > 0 && 
                        !selectedInventoryIds.includes(String(inv.inventoryTemplateID))) {
                        return;
                    }
                    
                    // Find the template to get DataType
                    const template = templates.find(t => t.inventoryTemplateID === inv.inventoryTemplateID);
                    const dataType = template?.dataType?.toLowerCase() || 'text';
                    const value = inv.valuePlanned;
                    
                    if (!value || value === '') {
                        return; // Empty values are ignored
                    }
                    
                    // Interpret based on DataType
                    switch(dataType) {
                        case 'number':
                        case 'integer':
                        case 'decimal':
                            // Parse as number using Number() for strict validation
                            const numValue = Number(value);
                            if (!isNaN(numValue) && isFinite(numValue)) {
                                inventoryTotal += numValue;
                            }
                            break;
                        case 'boolean':
                            // Check for truthy values
                            const boolVal = value.toString().toUpperCase().trim();
                            if (['JA', 'YES', 'TRUE', '1'].includes(boolVal)) {
                                inventoryTotal += 1;
                            }
                            // FALSE/NO/0 counts as 0 (no addition)
                            break;
                        case 'text':
                        default:
                            // Non-empty text counts as 1
                            if (value.toString().trim() !== '') {
                                inventoryTotal += 1;
                            }
                            break;
                    }
                });
            });
            
            // Update the indicator elements
            document.getElementById('sollKpiRoomTypes').textContent = roomTypeCount.toString();
            document.getElementById('sollKpiRooms').textContent = roomCount.toString();
            document.getElementById('sollKpiInventory').textContent = inventoryTotal.toString();
        }

        /**
         * Get HTML input type based on InventoryTemplate DataType
         */
        function getInputTypeForDataType(dataType) {
            switch(dataType?.toLowerCase()) {
                case 'number':
                case 'integer':
                case 'decimal':
                    return 'number';
                case 'boolean':
                    return 'checkbox';
                default:
                    return 'text';
            }
        }

        /**
         * Check if a value represents a truthy boolean
         * Used for interpreting stored boolean values from inventory
         */
        function isTruthyBooleanValue(value) {
            if (value === null || value === undefined || value === '') return false;
            const upperVal = String(value).toUpperCase().trim();
            return ['JA', 'YES', 'TRUE', '1'].includes(upperVal);
        }

        // ====================================================================
        // AUTOSAVE FUNCTIONALITY
        // ====================================================================
        
        // Autosave debounce timers - one per cell
        const autosaveTimers = new Map();
        const AUTOSAVE_DELAY = 800; // ms
        
        /**
         * Check if autosave is enabled
         */
        function isAutosaveEnabled() {
            return document.getElementById('soll-autosave')?.checked ?? true;
        }
        
        /**
         * Handle cell change for autosave
         * @param {HTMLElement} input - The input element that changed
         */
        function handleCellAutosave(input) {
            if (!isAutosaveEnabled()) return;
            
            const key = getCellKey(input);
            
            // Clear existing timer for this cell
            if (autosaveTimers.has(key)) {
                clearTimeout(autosaveTimers.get(key));
            }
            
            // Set new timer
            autosaveTimers.set(key, setTimeout(async () => {
                await saveSingleCell(input);
                autosaveTimers.delete(key);
            }, AUTOSAVE_DELAY));
        }
        
        /**
         * Get unique key for a cell
         */
        function getCellKey(input) {
            const row = input.closest('tr');
            const roomId = row?.dataset?.roomId || '';
            const field = input.dataset?.field || '';
            const templateId = input.dataset?.templateId || '';
            return `${roomId}-${field}-${templateId}`;
        }
        
        /**
         * Save a single cell value using partial update (PATCH)
         */
        async function saveSingleCell(input) {
            const row = input.closest('tr');
            const roomId = parseInt(row?.dataset?.roomId);
            if (isNaN(roomId) || roomId <= 0) return;
            
            // Save state for undo before making changes
            saveSollUndoState(roomId);
            
            try {
                // Show saving indicator
                input.style.backgroundColor = '#fff3cd';
                
                if (input.classList.contains('inventory-input')) {
                    // Save inventory value
                    const templateId = parseInt(input.dataset.templateId);
                    if (isNaN(templateId) || templateId <= 0) return;
                    
                    const dataType = input.dataset.datatype || 'text';
                    const value = getBooleanValueForInput(input, dataType);
                    
                    await updateRoomInventory(roomId, templateId, value, null);
                } else if (input.classList.contains('inventory-comment')) {
                    // Save inventory comment
                    const templateId = parseInt(input.dataset.templateId);
                    if (isNaN(templateId) || templateId <= 0) return;
                    
                    await updateRoomInventory(roomId, templateId, null, input.value);
                } else {
                    // Save room field using PATCH (partial update)
                    const field = input.dataset.field;
                    if (field) {
                        let value;
                        if (input.type === 'number') {
                            value = input.value || '';
                        } else if (input.type === 'checkbox') {
                            value = input.checked ? 'TRUE' : 'FALSE';
                        } else {
                            value = input.value || '';
                        }
                        
                        await patchRoomField(roomId, field, value);
                    }
                }
                
                // Show success
                input.style.backgroundColor = '#d4edda';
                setTimeout(() => {
                    input.style.backgroundColor = '';
                }, 1000);
                
            } catch (error) {
                console.error('Autosave error:', error);
                // Show error
                input.style.backgroundColor = '#f8d7da';
                setTimeout(() => {
                    input.style.backgroundColor = '';
                }, 2000);
            }
        }
        
        /**
         * Patch a single room field (partial update)
         * This only updates the specified field without affecting other fields
         */
        async function patchRoomField(roomId, field, value) {
            const response = await fetch(`${API_RAUMPROGRAM}/room/${roomId}/field`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    field: field,
                    value: value,
                    userId: getCurrentUserId()
                })
            });
            
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || 'Fehler beim Speichern');
            }
            
            return await response.json();
        }
        
        /**
         * Set up event delegation for autosave on the table body
         * This is more efficient than attaching listeners to each input
         */
        let autosaveListenersAttached = false;
        
        function attachAutosaveListeners() {
            if (autosaveListenersAttached) return;
            
            const tbody = document.getElementById('raumprogramTableBody');
            if (!tbody) return;
            
            // Use event delegation - single listener on parent
            tbody.addEventListener('input', (e) => {
                if (e.target.classList.contains('soll-input')) {
                    handleCellAutosave(e.target);
                }
            });
            
            tbody.addEventListener('change', (e) => {
                if (e.target.classList.contains('soll-input') && e.target.type === 'checkbox') {
                    handleCellAutosave(e.target);
                }
            });
            
            autosaveListenersAttached = true;
        }

        // ====================================================================
        // SOLL UNDO/REDO FUNCTIONALITY
        // ====================================================================
        
        // SOLL Undo/Redo stacks (limit to 5 records)
        const SOLL_UNDO_LIMIT = 5;
        let sollUndoStack = [];
        let sollRedoStack = [];
        
        /**
         * Save SOLL state for undo
         */
        function saveSollUndoState(roomId) {
            const room = window.currentRooms?.find(r => r.roomID === roomId);
            if (!room) return;
            
            // Clone the room state
            const state = JSON.parse(JSON.stringify(room));
            state._timestamp = Date.now();
            
            sollUndoStack.push(state);
            
            // Limit stack size
            while (sollUndoStack.length > SOLL_UNDO_LIMIT) {
                sollUndoStack.shift();
            }
            
            // Clear redo stack on new action
            sollRedoStack = [];
        }
        
        /**
         * Undo last SOLL change
         */
        async function sollUndo() {
            if (sollUndoStack.length === 0) {
                showResult('raumprogramResult', 'info', '‚ÑπÔ∏è Nichts zum R√ºckg√§ngig machen');
                return;
            }
            
            const state = sollUndoStack.pop();
            
            // Save current state to redo stack
            const currentRoom = window.currentRooms?.find(r => r.roomID === state.roomID);
            if (currentRoom) {
                sollRedoStack.push(JSON.parse(JSON.stringify(currentRoom)));
                while (sollRedoStack.length > SOLL_UNDO_LIMIT) {
                    sollRedoStack.shift();
                }
            }
            
            // Restore the state
            try {
                showResult('raumprogramResult', 'loading', '‚è≥ R√ºckg√§ngig machen...');
                
                const roomData = {
                    roomID: state.roomID,
                    name: state.name,
                    roomTypeID: state.roomTypeID,
                    netAreaPlanned: state.netAreaPlanned,
                    grossAreaPlanned: state.grossAreaPlanned,
                    description: state.description,
                    objectType: state.objectType,
                    predefinedType: state.predefinedType,
                    userId: getCurrentUserId()
                };
                
                await updateSollRoom(state.roomID, roomData);
                
                // Restore inventory values
                for (const inv of (state.inventory || [])) {
                    if (inv.valuePlanned !== undefined) {
                        await updateRoomInventory(state.roomID, inv.inventoryTemplateID, inv.valuePlanned, inv.comment);
                    }
                }
                
                await loadRaumprogramData(currentRaumprogramPage);
                showResult('raumprogramResult', 'success', '‚úÖ √Ñnderung r√ºckg√§ngig gemacht');
            } catch (error) {
                console.error('Undo error:', error);
                showResult('raumprogramResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Redo last undone SOLL change
         */
        async function sollRedo() {
            if (sollRedoStack.length === 0) {
                showResult('raumprogramResult', 'info', '‚ÑπÔ∏è Nichts zum Wiederholen');
                return;
            }
            
            const state = sollRedoStack.pop();
            
            // Save current state to undo stack
            const currentRoom = window.currentRooms?.find(r => r.roomID === state.roomID);
            if (currentRoom) {
                sollUndoStack.push(JSON.parse(JSON.stringify(currentRoom)));
            }
            
            // Apply the redo state
            try {
                showResult('raumprogramResult', 'loading', '‚è≥ Wiederholen...');
                
                const roomData = {
                    roomID: state.roomID,
                    name: state.name,
                    roomTypeID: state.roomTypeID,
                    netAreaPlanned: state.netAreaPlanned,
                    grossAreaPlanned: state.grossAreaPlanned,
                    description: state.description,
                    objectType: state.objectType,
                    predefinedType: state.predefinedType,
                    userId: getCurrentUserId()
                };
                
                await updateSollRoom(state.roomID, roomData);
                
                for (const inv of (state.inventory || [])) {
                    if (inv.valuePlanned !== undefined) {
                        await updateRoomInventory(state.roomID, inv.inventoryTemplateID, inv.valuePlanned, inv.comment);
                    }
                }
                
                await loadRaumprogramData(currentRaumprogramPage);
                showResult('raumprogramResult', 'success', '‚úÖ √Ñnderung wiederhergestellt');
            } catch (error) {
                console.error('Redo error:', error);
                showResult('raumprogramResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        // Add keyboard shortcuts for SOLL undo/redo
        document.addEventListener('keydown', (e) => {
            // Only handle if SOLL tab is active
            const sollTab = document.getElementById('tab-raumprogramm');
            if (!sollTab?.classList.contains('active')) return;
            
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') {
                    e.preventDefault();
                    sollUndo();
                } else if (e.key === 'y') {
                    e.preventDefault();
                    sollRedo();
                }
            }
        });

        /**
         * Load predefined types for dropdown
         */
        async function loadPredefinedTypes() {
            try {
                const response = await fetch(`${API_RAUMPROGRAM}/predefinedtypes`);
                const data = await response.json();
                
                if (response.ok && data.success) {
                    window.predefinedTypes = data.predefinedTypes || [];
                    console.log('Loaded predefined types:', window.predefinedTypes);
                }
            } catch (error) {
                console.error('Error loading predefined types:', error);
                window.predefinedTypes = [];
            }
        }

        /**
         * Load all SOLL data - refreshes room types, rooms, inventory templates, and predefined types
         * Shows progress bar during loading
         */
        async function loadAllSollData() {
            const resultDiv = document.getElementById('raumprogramResult');
            
            // Show progress bar
            resultDiv.innerHTML = `
                <div style="padding: 10px;">
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <div class="spinner"></div>
                        <span>Lade Daten...</span>
                    </div>
                    <div style="margin-top: 10px; background: #e0e0e0; border-radius: 4px; overflow: hidden;">
                        <div id="loadingProgress" style="height: 6px; background: linear-gradient(90deg, #0066cc, #00aaff); width: 0%; transition: width 0.3s ease;"></div>
                    </div>
                    <small id="loadingStatus" style="color: #666;">Initialisiere...</small>
                </div>
            `;
            resultDiv.className = 'result info';
            
            const progressBar = document.getElementById('loadingProgress');
            const statusText = document.getElementById('loadingStatus');
            
            try {
                // Step 1: Load room types (25%)
                statusText.textContent = 'Lade Raumtypen...';
                progressBar.style.width = '10%';
                await loadRoomTypes();
                progressBar.style.width = '25%';
                
                // Step 2: Load inventory templates (50%)
                statusText.textContent = 'Lade Inventarvorlagen...';
                await loadInventoryTemplates();
                progressBar.style.width = '50%';
                
                // Step 3: Load predefined types (65%)
                statusText.textContent = 'Lade vordefinierte Typen...';
                await loadPredefinedTypes();
                progressBar.style.width = '65%';
                
                // Step 4: Load room data (100%)
                statusText.textContent = 'Lade R√§ume...';
                await loadRaumprogramData();
                progressBar.style.width = '100%';
                
                // Show success message after short delay
                setTimeout(() => {
                    showResult('raumprogramResult', 'success', '‚úÖ Alle Daten erfolgreich geladen');
                }, 300);
            } catch (error) {
                console.error('Error loading all SOLL data:', error);
                showResult('raumprogramResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Save all changes made in the SOLL table
         */
        async function saveAllSollChanges() {
            showResult('raumprogramResult', 'loading', '‚è≥ Speichere √Ñnderungen...');
            
            const rows = document.querySelectorAll('#raumprogramTableBody tr[data-room-id]');
            let savedCount = 0;
            let errorCount = 0;
            
            for (const row of rows) {
                const roomId = parseInt(row.dataset.roomId);
                if (!roomId) continue;
                
                try {
                    // Collect room field changes
                    const roomData = {
                        roomID: roomId,
                        userId: getCurrentUserId()
                    };
                    
                    // Get all input values for room fields
                    const inputs = row.querySelectorAll('.soll-input:not(.inventory-input):not(.inventory-comment)');
                    inputs.forEach(input => {
                        const field = input.dataset.field;
                        if (field) {
                            if (input.type === 'number') {
                                roomData[field] = input.value ? parseFloat(input.value) : null;
                            } else if (input.type === 'checkbox') {
                                roomData[field] = input.checked;
                            } else {
                                roomData[field] = input.value || null;
                            }
                        }
                    });
                    
                    // We need to get the original room data to include required fields
                    const originalRoom = window.currentRooms?.find(r => r.roomID === roomId);
                    if (originalRoom) {
                        roomData.name = originalRoom.name;
                        roomData.roomTypeID = originalRoom.roomTypeID;
                    }
                    
                    // Update room
                    if (Object.keys(roomData).length > 2) {
                        await updateSollRoom(roomId, roomData);
                    }
                    
                    // Handle inventory inputs
                    const inventoryInputs = row.querySelectorAll('.inventory-input');
                    for (const invInput of inventoryInputs) {
                        const templateId = parseInt(invInput.dataset.templateId);
                        const invRoomId = parseInt(invInput.dataset.roomId);
                        const dataType = invInput.dataset.datatype || 'text';
                        
                        if (templateId && invRoomId) {
                            const value = getBooleanValueForInput(invInput, dataType);
                            await updateRoomInventory(invRoomId, templateId, value, null);
                        }
                    }
                    
                    // Handle inventory comments
                    const commentInputs = row.querySelectorAll('.inventory-comment');
                    for (const commentInput of commentInputs) {
                        const templateId = parseInt(commentInput.dataset.templateId);
                        const invRoomId = parseInt(commentInput.dataset.roomId);
                        if (templateId && invRoomId) {
                            await updateRoomInventory(invRoomId, templateId, null, commentInput.value);
                        }
                    }
                    
                    savedCount++;
                } catch (error) {
                    console.error(`Error saving room ${roomId}:`, error);
                    errorCount++;
                }
            }
            
            if (errorCount === 0) {
                showResult('raumprogramResult', 'success', `‚úÖ ${savedCount} R√§ume erfolgreich gespeichert`);
            } else {
                showResult('raumprogramResult', 'warning', `‚ö†Ô∏è ${savedCount} gespeichert, ${errorCount} Fehler`);
            }
            
            // Reload data to reflect changes
            await loadRaumprogramData();
        }

        /**
         * Update a single room's SOLL data
         */
        async function updateSollRoom(roomId, roomData) {
            const response = await fetch(`${API_RAUMPROGRAM}/room/${roomId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(roomData)
            });
            
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || 'Fehler beim Speichern');
            }
            
            return await response.json();
        }

        /**
         * Update room inventory value
         */
        async function updateRoomInventory(roomId, templateId, valuePlanned, comment) {
            const requestBody = {
                roomID: roomId,
                inventoryTemplateID: templateId,
                userId: getCurrentUserId()
            };
            
            if (valuePlanned !== null) {
                requestBody.valuePlanned = valuePlanned;
            }
            if (comment !== null) {
                requestBody.comment = comment;
            }
            
            const response = await fetch(`${API_RAUMPROGRAM}/roominventory`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || 'Fehler beim Speichern');
            }
            
            return await response.json();
        }

        /**
         * Delete a room from SOLL table
         */
        async function deleteSollRoom(roomId) {
            if (!confirm('M√∂chten Sie diesen Raum wirklich l√∂schen? Diese Aktion kann nicht r√ºckg√§ngig gemacht werden.')) {
                return;
            }
            
            showResult('raumprogramResult', 'loading', '‚è≥ L√∂sche Raum...');
            
            try {
                const userId = getCurrentUserId();
                const url = userId
                    ? `${API_RAUMPROGRAM}/room/${roomId}?userId=${encodeURIComponent(userId)}`
                    : `${API_RAUMPROGRAM}/room/${roomId}`;
                    
                const response = await fetch(url, {
                    method: 'DELETE'
                });
                
                const data = await response.json();
                
                if (response.ok && data.success) {
                    showResult('raumprogramResult', 'success', '‚úÖ Raum erfolgreich gel√∂scht');
                    await loadRaumprogramData();
                } else {
                    showResult('raumprogramResult', 'error', `‚ùå ${data.message || 'Fehler beim L√∂schen'}`);
                }
            } catch (error) {
                console.error('Error deleting room:', error);
                showResult('raumprogramResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Update pagination controls
         */
        function updateRaumprogramPagination(data) {
            const prevBtn = document.getElementById('raumprogramPrevPage');
            const nextBtn = document.getElementById('raumprogramNextPage');
            const info = document.getElementById('raumprogramPaginationInfo');

            prevBtn.disabled = data.page <= 1;
            nextBtn.disabled = data.page >= data.totalPages;
            info.textContent = `Seite ${data.page} von ${data.totalPages || 1} (${data.totalCount} Eintr√§ge)`;
        }

        /**
         * Delete a room
         */
        async function deleteRoom(roomId) {
            if (!confirm('M√∂chten Sie diesen Raum wirklich l√∂schen?')) {
                return;
            }

            showResult('raumprogramResult', 'loading', '‚è≥ L√∂sche Raum...');

            try {
                const userId = getCurrentUserId();
                const url = userId
                    ? `${API_RAUMPROGRAM}/room/${roomId}?userId=${encodeURIComponent(userId)}`
                    : `${API_RAUMPROGRAM}/room/${roomId}`;
                const response = await fetch(url, {
                    method: 'DELETE'
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult('raumprogramResult', 'success', `‚úÖ ${data.message}`);
                    await loadRaumprogramData(currentRaumprogramPage);
                } else {
                    showResult('raumprogramResult', 'error', `‚ùå ${data.message || 'Fehler'}`);
                }
            } catch (error) {
                showResult('raumprogramResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Import Raumprogramm from Excel
         */
        async function importRaumprogramFromExcel() {
            const token = getToken();
            const fileId = document.getElementById('raumprogramImportFile')?.value;

            if (!token || !fileId) {
                showResult('importExportResult', 'error', '‚ö†Ô∏è Bitte Token und Datei ausw√§hlen');
                return;
            }

            showResult('importExportResult', 'loading', '‚è≥ Importiere Daten aus Excel...');

            try {
                const response = await fetch(`${API_RAUMPROGRAM}/raumprogram/import`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        fileId: fileId,
                        columnMappings: {
                            raumtypColumn: 0,
                            roomNameColumn: 1,
                            areaPlannedColumn: 2,
                            areaActualColumn: 3
                        }
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    let msg = `‚úÖ ${data.message}<br>`;
                    msg += `Raumtypen erstellt: ${data.roomTypesCreated || 0}<br>`;
                    msg += `R√§ume erstellt: ${data.roomsCreated || 0}<br>`;
                    msg += `R√§ume aktualisiert: ${data.roomsUpdated || 0}`;
                    showResult('importExportResult', 'success', msg);
                    await refreshAllMasterData();
                    await loadRaumprogramData();
                } else {
                    showResult('importExportResult', 'error', `‚ùå ${data.message || 'Import fehlgeschlagen'}`);
                }
            } catch (error) {
                showResult('importExportResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Export Raumprogramm to Excel
         */
        async function exportRaumprogramToExcel() {
            const token = getToken();
            const targetFolder = getTargetFolder();

            if (!token || !targetFolder) {
                showResult('importExportResult', 'error', '‚ö†Ô∏è Bitte Token und Zielordner in Einstellungen konfigurieren');
                return;
            }

            showResult('importExportResult', 'loading', '‚è≥ Exportiere Daten nach Excel...');

            try {
                const response = await fetch(`${API_RAUMPROGRAM}/raumprogram/export`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        targetFolderId: targetFolder
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    showResult('importExportResult', 'success', `‚úÖ ${data.message}<br>Datei: ${data.fileName}`);
                } else {
                    showResult('importExportResult', 'error', `‚ùå ${data.message || 'Export fehlgeschlagen'}`);
                }
            } catch (error) {
                showResult('importExportResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        // ====================================================================
        //  AUSGEF√úHRT (IST) TAB FUNCTIONS
        // ====================================================================

        let currentIstPage = 1;
        const istPageSize = 50;
        
        // Store current IST rooms for reference
        window.currentIstRooms = [];
        
        // IST Undo/Redo stacks (limit to 5 records)
        const IST_UNDO_LIMIT = 5;
        let istUndoStack = [];
        let istRedoStack = [];
        
        // IST Autosave timers
        const istAutosaveTimers = new Map();
        const IST_AUTOSAVE_DELAY = 600; // ms

        /**
         * Load all IST data with progress bar
         */
        async function loadAllIstData() {
            const progressContainer = document.getElementById('istLoadingProgress');
            const progressBar = document.getElementById('istProgressBar');
            const statusText = document.getElementById('istLoadingStatus');
            
            // Show progress bar
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            statusText.textContent = 'Initialisiere...';
            
            try {
                // Step 1: Load room types (25%)
                statusText.textContent = 'Lade Raumtypen...';
                progressBar.style.width = '10%';
                await loadRoomTypes();
                progressBar.style.width = '25%';
                
                // Step 2: Load inventory templates (50%)
                statusText.textContent = 'Lade Inventarvorlagen...';
                await loadInventoryTemplates();
                progressBar.style.width = '50%';
                
                // Step 3: Load IST data (100%)
                statusText.textContent = 'Lade IST-Daten...';
                progressBar.style.width = '75%';
                await loadIstData();
                progressBar.style.width = '100%';
                
                // Hide progress bar after short delay
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                    showResult('istResult', 'success', '‚úÖ Alle Daten erfolgreich geladen');
                }, 300);
            } catch (error) {
                console.error('Error loading all IST data:', error);
                progressContainer.style.display = 'none';
                showResult('istResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Load IST data with pagination and filters
         */
        async function loadIstData(page = 1) {
            if (page < 1) page = 1;
            currentIstPage = page;

            const roomTypeId = document.getElementById('ist-filter-roomtype')?.value || '';
            const search = document.getElementById('ist-search')?.value?.trim() || '';

            showResult('istResult', 'loading', '‚è≥ Lade IST-Daten...');
            
            // Handle multiple inventory selection
            const inventorySelect = document.getElementById('ist-filter-inventory');
            const selectedInventoryIds = Array.from(inventorySelect?.selectedOptions || [])
                .map(opt => opt.value)
                .filter(v => v);

            try {
                let url = `${API_RAUMPROGRAM}/raumprogram?page=${page}&pageSize=${istPageSize}`;
                if (roomTypeId) url += `&roomTypeId=${roomTypeId}`;
                if (search) url += `&search=${encodeURIComponent(search)}`;
                
                // Only filter by single inventory if one is selected
                if (selectedInventoryIds.length === 1) {
                    url += `&inventoryTemplateId=${selectedInventoryIds[0]}`;
                }

                const response = await fetch(url);
                const data = await response.json();

                if (response.ok && data.success) {
                    window.currentIstRooms = data.rooms || [];
                    renderIstTable(data.rooms || [], selectedInventoryIds);
                    updateIstPagination(data);
                    showResult('istResult', 'success', `‚úÖ ${data.totalCount} R√§ume gefunden`);
                    
                    // Update IST indicators
                    await updateIstIndicatorsFromApi(roomTypeId, selectedInventoryIds);
                } else {
                    showResult('istResult', 'error', `‚ùå ${data.message || 'Fehler beim Laden'}`);
                }
            } catch (error) {
                console.error('Error loading IST data:', error);
                showResult('istResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Fetch data for IST indicators - compares IST vs SOLL values
         */
        async function updateIstIndicatorsFromApi(roomTypeId, selectedInventoryIds) {
            try {
                const search = document.getElementById('ist-search')?.value?.trim() || '';
                
                // Fetch all rooms for indicator calculation
                let url = `${API_RAUMPROGRAM}/raumprogram?page=1&pageSize=10000`;
                if (roomTypeId) url += `&roomTypeId=${roomTypeId}`;
                if (search) url += `&search=${encodeURIComponent(search)}`;

                const response = await fetch(url);
                const data = await response.json();

                if (response.ok && data.success) {
                    updateIstIndicators(data.rooms || [], selectedInventoryIds);
                }
            } catch (error) {
                console.error('Error updating IST indicators:', error);
            }
        }
        
        /**
         * Update IST page indicators (IST/SOLL comparison KPIs)
         */
        function updateIstIndicators(rooms, selectedInventoryIds = []) {
            const templates = window.inventoryTemplates || [];
            
            // Calculate totals
            let totalGrossIst = 0, totalGrossSoll = 0;
            let totalNetIst = 0, totalNetSoll = 0;
            let totalInventoryIst = 0, totalInventorySoll = 0;
            
            rooms.forEach(room => {
                // Gross Area
                totalGrossIst += Number(room.grossAreaActual) || 0;
                totalGrossSoll += Number(room.grossAreaPlanned) || 0;
                
                // Net Area
                totalNetIst += Number(room.netAreaActual) || 0;
                totalNetSoll += Number(room.netAreaPlanned) || 0;
                
                // Inventory calculation
                const inventoryItems = room.inventory || [];
                inventoryItems.forEach(inv => {
                    // Only count if in selected inventory templates (or all if none selected)
                    if (selectedInventoryIds.length > 0 && 
                        !selectedInventoryIds.includes(String(inv.inventoryTemplateID))) {
                        return;
                    }
                    
                    const template = templates.find(t => t.inventoryTemplateID === inv.inventoryTemplateID);
                    const dataType = template?.dataType?.toLowerCase() || 'text';
                    
                    // Calculate IST value
                    const istVal = inv.valueActual;
                    if (istVal && istVal !== '') {
                        totalInventoryIst += normalizeInventoryValue(istVal, dataType);
                    }
                    
                    // Calculate SOLL value
                    const sollVal = inv.valuePlanned;
                    if (sollVal && sollVal !== '') {
                        totalInventorySoll += normalizeInventoryValue(sollVal, dataType);
                    }
                });
            });
            
            // Update indicator elements
            const bruttoEl = document.getElementById('istKpiBrutto');
            const nettoEl = document.getElementById('istKpiNetto');
            const invEl = document.getElementById('istKpiInventory');
            
            if (bruttoEl) {
                bruttoEl.textContent = `${Math.round(totalGrossIst)} / ${Math.round(totalGrossSoll)} m¬≤`;
                applyIndicatorColor('istKpiBruttoContainer', totalGrossIst, totalGrossSoll);
            }
            if (nettoEl) {
                nettoEl.textContent = `${Math.round(totalNetIst)} / ${Math.round(totalNetSoll)} m¬≤`;
                applyIndicatorColor('istKpiNettoContainer', totalNetIst, totalNetSoll);
            }
            if (invEl) {
                invEl.textContent = `${Math.round(totalInventoryIst)} / ${Math.round(totalInventorySoll)}`;
                applyIndicatorColor('istKpiInventoryContainer', totalInventoryIst, totalInventorySoll);
            }
        }
        
        /**
         * Convert boolean input value to standardized string format
         * Used for consistent boolean storage and comparison
         * @param {HTMLInputElement} input - Checkbox or other input element
         * @param {string} dataType - The data type of the field
         * @returns {string} 'TRUE', 'FALSE', or the original value for non-boolean types
         */
        function getBooleanValueForInput(input, dataType) {
            if (dataType === 'boolean') {
                return input.checked ? 'TRUE' : 'FALSE';
            }
            return input.value;
        }
        
        /**
         * Normalize inventory value based on data type
         */
        function normalizeInventoryValue(value, dataType) {
            if (value === null || value === undefined || value === '') return 0;
            
            switch(dataType) {
                case 'number':
                case 'integer':
                case 'decimal':
                    const numValue = Number(value);
                    return !isNaN(numValue) ? numValue : 0;
                case 'boolean':
                    const boolVal = value.toString().toUpperCase().trim();
                    return ['JA', 'YES', 'TRUE', '1'].includes(boolVal) ? 1 : 0;
                case 'text':
                default:
                    return value.toString().trim() !== '' ? 1 : 0;
            }
        }
        
        /**
         * Apply color to indicator container based on IST vs SOLL comparison
         */
        function applyIndicatorColor(containerId, istValue, sollValue) {
            const container = document.getElementById(containerId);
            if (!container) return;
            
            // Reset classes
            container.classList.remove('kpi-status-ok', 'kpi-status-under', 'kpi-status-over');
            
            // If both values are 0, show as equal (green)
            // Only remain neutral if no meaningful data exists
            if (sollValue === 0 && istValue === 0) {
                container.classList.add('kpi-status-ok'); // Both zero is considered matching
                return;
            }
            
            if (istValue === sollValue) {
                container.classList.add('kpi-status-ok'); // Green
            } else if (istValue < sollValue) {
                container.classList.add('kpi-status-under'); // Red (too little)
            } else {
                container.classList.add('kpi-status-over'); // Yellow (too much)
            }
        }

        /**
         * Render IST data table - shows IST values for editing with SOLL comparison
         * Implements side-by-side SOLL + IST columns per requirement
         */
        function renderIstTable(rooms, selectedInventoryIds = []) {
            const thead = document.getElementById('istTableHead');
            const tbody = document.getElementById('istTableBody');

            // Get column visibility settings
            const showRaumtyp = document.getElementById('ist-col-raumtyp')?.checked ?? true;
            const showRaumkategorie = document.getElementById('ist-col-raumkategorie')?.checked ?? true;
            const showRaum = document.getElementById('ist-col-raum')?.checked ?? true;
            const showNetArea = document.getElementById('ist-col-netarea')?.checked ?? true;
            const showGrossArea = document.getElementById('ist-col-grossarea')?.checked ?? true;
            const showAllSoll = document.getElementById('ist-col-showallsoll')?.checked ?? false;

            // Get selected inventory templates for column headers
            const templates = window.inventoryTemplates || [];
            const selectedTemplates = selectedInventoryIds.length > 0
                ? templates.filter(t => selectedInventoryIds.includes(String(t.inventoryTemplateID)))
                : [];

            // Always show comment columns (SOLL read-only + IST editable)
            const showComment = true;

            // Build dynamic headers with SOLL/IST pairs
            let headerHtml = '<tr>';
            if (showRaumtyp) headerHtml += '<th>Raumtyp</th>';
            if (showRaumkategorie) headerHtml += '<th>Raumkategorie</th>';
            if (showRaum) headerHtml += '<th>Raum</th>';
            
            // Net Area SOLL/IST pair
            if (showNetArea) {
                headerHtml += '<th style="background:#e0e0e0;">Nettofl√§che SOLL</th>';
                headerHtml += '<th>Nettofl√§che IST</th>';
            }
            
            // Gross Area SOLL/IST pair
            if (showGrossArea) {
                headerHtml += '<th style="background:#e0e0e0;">Bruttofl√§che SOLL</th>';
                headerHtml += '<th>Bruttofl√§che IST</th>';
            }

            // Add inventory columns (SOLL/IST pairs)
            selectedTemplates.forEach(t => {
                const unit = t.unit ? ` (${t.unit})` : '';
                headerHtml += `<th style="background:#e0e0e0;">${escapeHtml(t.propertyName)}${unit} SOLL</th>`;
                headerHtml += `<th>${escapeHtml(t.propertyName)}${unit} IST</th>`;
            });
            
            // Comment columns (SOLL read-only + IST editable)
            if (showComment) {
                headerHtml += '<th style="background:#e0e0e0;">Kommentar SOLL</th>';
                headerHtml += '<th>Kommentar IST</th>';
            }
            
            headerHtml += '<th>Aktionen</th>';
            headerHtml += '</tr>';
            thead.innerHTML = headerHtml;

            // Calculate column count for empty message
            let colCount = 1; // For actions column
            if (showRaumtyp) colCount++;
            if (showRaumkategorie) colCount++;
            if (showRaum) colCount++;
            if (showNetArea) colCount += 2; // SOLL + IST
            if (showGrossArea) colCount += 2; // SOLL + IST
            colCount += selectedTemplates.length * 2; // SOLL + IST pairs
            if (showComment) colCount += 2; // SOLL + IST comments

            if (!rooms || rooms.length === 0) {
                tbody.innerHTML = `<tr><td colspan="${colCount}" style="text-align:center; color:#666;">Keine Daten vorhanden.</td></tr>`;
                return;
            }

            let html = '';
            rooms.forEach(room => {
                html += `<tr data-room-id="${room.roomID}">`;
                
                // Non-editable info columns
                if (showRaumtyp) html += `<td>${escapeHtml(room.roomTypeName || '')}</td>`;
                if (showRaumkategorie) html += `<td>${escapeHtml(room.roomCategory || '')}</td>`;
                if (showRaum) html += `<td>${escapeHtml(room.name || '')}</td>`;
                
                // Net Area SOLL/IST pair
                if (showNetArea) {
                    const netSoll = room.netAreaPlanned || 0;
                    const netIst = room.netAreaActual || 0;
                    const netSollClass = getSollCellClass(netIst, netSoll);
                    html += `<td class="soll-cell ${netSollClass}" data-soll-value="${netSoll}" style="background:#e8e8e8;">${netSoll}</td>`;
                    html += `<td><input type="number" class="form-control ist-input ist-area-input" data-field="netAreaActual" data-soll="${netSoll}" value="${netIst}" step="0.01" style="width:100px;" oninput="updateSollCellColor(this)"></td>`;
                }
                
                // Gross Area SOLL/IST pair
                if (showGrossArea) {
                    const grossSoll = room.grossAreaPlanned || 0;
                    const grossIst = room.grossAreaActual || 0;
                    const grossSollClass = getSollCellClass(grossIst, grossSoll);
                    html += `<td class="soll-cell ${grossSollClass}" data-soll-value="${grossSoll}" style="background:#e8e8e8;">${grossSoll}</td>`;
                    html += `<td><input type="number" class="form-control ist-input ist-area-input" data-field="grossAreaActual" data-soll="${grossSoll}" value="${grossIst}" step="0.01" style="width:100px;" oninput="updateSollCellColor(this)"></td>`;
                }

                // Inventory columns with SOLL/IST pairs
                selectedTemplates.forEach(t => {
                    const inv = (room.inventory || []).find(i => i.inventoryTemplateID === t.inventoryTemplateID);
                    const sollValue = inv?.valuePlanned || '';
                    const istValue = inv?.valueActual || '';
                    const dataType = t.dataType?.toLowerCase() || 'text';
                    
                    // SOLL cell (read-only)
                    const sollClass = getSollCellClassForInventory(istValue, sollValue, dataType);
                    
                    if (dataType === 'boolean') {
                        const sollChecked = isTruthyBooleanValue(sollValue);
                        html += `<td class="soll-cell ${sollClass}" data-soll-value="${sollValue}" style="background:#e8e8e8; text-align:center;">`;
                        html += sollChecked ? '‚úì Ja' : '‚úó Nein';
                        html += `</td>`;
                        
                        // IST cell (editable checkbox)
                        const istChecked = isTruthyBooleanValue(istValue) ? 'checked' : '';
                        html += `<td style="text-align:center;"><input type="checkbox" class="ist-input ist-inventory-input ist-inventory-boolean" data-template-id="${t.inventoryTemplateID}" data-room-id="${room.roomID}" data-datatype="boolean" data-soll="${sollValue}" ${istChecked} style="width:20px; height:20px;" onchange="updateSollCellColorForInventory(this)"></td>`;
                    } else {
                        html += `<td class="soll-cell ${sollClass}" data-soll-value="${sollValue}" style="background:#e8e8e8;">${escapeHtml(sollValue)}</td>`;
                        
                        // IST cell (editable) with correct input type
                        const inputType = getInputTypeForDataType(dataType);
                        const step = (dataType === 'integer') ? '1' : (dataType === 'decimal' || dataType === 'number') ? '0.01' : '';
                        const stepAttr = step ? `step="${step}"` : '';
                        html += `<td><input type="${inputType}" class="form-control ist-input ist-inventory-input" data-template-id="${t.inventoryTemplateID}" data-room-id="${room.roomID}" data-datatype="${dataType}" data-soll="${escapeHtml(sollValue)}" value="${escapeHtml(istValue)}" ${stepAttr} style="width:120px;" oninput="updateSollCellColorForInventory(this)"></td>`;
                    }
                });

                // Comment columns (SOLL read-only + IST editable)
                if (showComment) {
                    // For comments, use the first inventory item's comment or room-level comment
                    const firstInv = (room.inventory || [])[0];
                    const commentSoll = firstInv?.comment || room.commentSoll || '';
                    const commentIst = room.commentIst || firstInv?.commentActual || '';
                    
                    html += `<td class="soll-cell" style="background:#e8e8e8; max-width:150px; overflow:hidden; text-overflow:ellipsis;" title="${escapeHtml(commentSoll)}">${escapeHtml(commentSoll)}</td>`;
                    html += `<td><input type="text" class="form-control ist-input ist-comment-input" data-field="commentIst" value="${escapeHtml(commentIst)}" style="width:150px;" placeholder="IST Kommentar"></td>`;
                }

                // Actions column - Copy from SOLL button (replaces delete button per requirement)
                html += `<td><button class="btn btn-secondary btn-sm" onclick="copyIstFromSoll(${room.roomID})" title="IST von SOLL kopieren">üìã SOLL‚ÜíIST</button></td>`;
                
                html += '</tr>';
            });

            tbody.innerHTML = html;
            
            // Attach autosave and keyboard navigation listeners
            attachIstAutosaveListeners();
            attachIstKeyboardNavigation();
        }
        
        /**
         * Get CSS class for SOLL cell based on IST/SOLL comparison
         * Green: IST = SOLL, Red: IST < SOLL, Yellow: IST > SOLL
         */
        function getSollCellClass(istValue, sollValue) {
            // Check if IST value is actually set (not null/undefined/empty string)
            const istIsSet = istValue !== null && istValue !== undefined && istValue !== '';
            
            const ist = Number(istValue) || 0;
            const soll = Number(sollValue) || 0;
            
            // If IST is not set at all (empty input), keep grey
            if (!istIsSet) return '';
            
            // Now compare actual values - 0 is a valid value
            if (ist === soll) return 'soll-match-equal'; // Green
            if (ist < soll) return 'soll-match-under'; // Red (too little)
            return 'soll-match-over'; // Yellow (too much)
        }
        
        /**
         * Get CSS class for inventory SOLL cell based on IST/SOLL comparison
         */
        function getSollCellClassForInventory(istValue, sollValue, dataType) {
            // Check if IST value is actually set
            const istIsSet = istValue !== null && istValue !== undefined && istValue !== '';
            if (!istIsSet && dataType !== 'boolean') return ''; // IST not set, neutral grey
            
            // For boolean, check if checkbox has been interacted with
            // But since we always have a value for checkboxes, we compare
            if (dataType === 'boolean') {
                // For boolean, always compare - FALSE is a valid value
                const istNorm = normalizeInventoryValue(istValue, dataType);
                const sollNorm = normalizeInventoryValue(sollValue, dataType);
                
                if (istNorm === sollNorm) return 'soll-match-equal';
                if (istNorm < sollNorm) return 'soll-match-under';
                return 'soll-match-over';
            }
            
            const istNorm = normalizeInventoryValue(istValue, dataType);
            const sollNorm = normalizeInventoryValue(sollValue, dataType);
            
            if (istNorm === sollNorm) return 'soll-match-equal'; // Green
            if (istNorm < sollNorm) return 'soll-match-under'; // Red
            return 'soll-match-over'; // Yellow
        }
        
        /**
         * Update SOLL cell color when IST value changes (live during editing)
         */
        function updateSollCellColor(istInput) {
            const row = istInput.closest('tr');
            const sollCell = istInput.parentElement.previousElementSibling;
            if (!sollCell || !sollCell.classList.contains('soll-cell')) return;
            
            const sollValue = parseFloat(sollCell.dataset.sollValue) || 0;
            const istInputValue = istInput.value;
            const istValue = parseFloat(istInputValue) || 0;
            
            sollCell.classList.remove('soll-match-equal', 'soll-match-under', 'soll-match-over');
            
            // Only apply color if IST has been edited (not empty string)
            if (istInputValue === '') return;
            
            // 0 is a valid value that should be compared
            if (istValue === sollValue) {
                sollCell.classList.add('soll-match-equal');
            } else if (istValue < sollValue) {
                sollCell.classList.add('soll-match-under');
            } else {
                sollCell.classList.add('soll-match-over');
            }
        }
        
        /**
         * Update SOLL cell color for inventory items when IST value changes
         */
        function updateSollCellColorForInventory(istInput) {
            const sollCell = istInput.parentElement.previousElementSibling;
            if (!sollCell || !sollCell.classList.contains('soll-cell')) return;
            
            const dataType = istInput.dataset.datatype || 'text';
            const sollValue = istInput.dataset.soll || '';
            let istValue;
            
            if (dataType === 'boolean') {
                istValue = istInput.checked ? 'TRUE' : 'FALSE';
            } else {
                istValue = istInput.value;
            }
            
            sollCell.classList.remove('soll-match-equal', 'soll-match-under', 'soll-match-over');
            
            // For non-boolean types, empty string means not set
            if (dataType !== 'boolean' && (!istValue || istValue === '')) return;
            
            const sollNorm = normalizeInventoryValue(sollValue, dataType);
            const istNorm = normalizeInventoryValue(istValue, dataType);
            
            if (istNorm === sollNorm) {
                sollCell.classList.add('soll-match-equal');
            } else if (istNorm < sollNorm) {
                sollCell.classList.add('soll-match-under');
            } else {
                sollCell.classList.add('soll-match-over');
            }
        }
        
        /**
         * Copy IST values from SOLL for a specific row
         */
        async function copyIstFromSoll(roomId) {
            const room = window.currentIstRooms.find(r => r.roomID === roomId);
            if (!room) {
                showResult('istResult', 'error', '‚ùå Raum nicht gefunden');
                return;
            }
            
            // Save state for undo before making changes
            saveIstUndoState(roomId);
            
            showResult('istResult', 'loading', '‚è≥ Kopiere SOLL nach IST...');
            
            try {
                // Update room areas
                const roomData = {
                    roomID: roomId,
                    name: room.name,
                    roomTypeID: room.roomTypeID,
                    netAreaActual: room.netAreaPlanned,
                    grossAreaActual: room.grossAreaPlanned,
                    userId: getCurrentUserId()
                };
                
                await updateIstRoom(roomId, roomData);
                
                // Update inventory values
                for (const inv of (room.inventory || [])) {
                    if (inv.valuePlanned) {
                        await updateIstRoomInventory(roomId, inv.inventoryTemplateID, inv.valuePlanned);
                    }
                }
                
                // Reload data
                await loadIstData(currentIstPage);
                showResult('istResult', 'success', '‚úÖ SOLL-Werte nach IST kopiert');
            } catch (error) {
                console.error('Error copying SOLL to IST:', error);
                showResult('istResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Update a single room's IST data
         */
        async function updateIstRoom(roomId, roomData) {
            const response = await fetch(`${API_RAUMPROGRAM}/room/${roomId}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(roomData)
            });
            
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || 'Fehler beim Speichern');
            }
            
            return await response.json();
        }
        
        /**
         * Update room inventory IST value
         */
        async function updateIstRoomInventory(roomId, templateId, valueActual) {
            const requestBody = {
                roomID: roomId,
                inventoryTemplateID: templateId,
                valueActual: valueActual,
                userId: getCurrentUserId()
            };
            
            const response = await fetch(`${API_RAUMPROGRAM}/roominventory`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || 'Fehler beim Speichern');
            }
            
            return await response.json();
        }

        /**
         * Update IST pagination controls
         */
        function updateIstPagination(data) {
            const prevBtn = document.getElementById('istPrevPage');
            const nextBtn = document.getElementById('istNextPage');
            const info = document.getElementById('istPaginationInfo');

            if (prevBtn) prevBtn.disabled = data.page <= 1;
            if (nextBtn) nextBtn.disabled = data.page >= data.totalPages;
            if (info) info.textContent = `Seite ${data.page} von ${data.totalPages || 1} (${data.totalCount} Eintr√§ge)`;
        }
        
        // ====================================================================
        // IST AUTOSAVE FUNCTIONALITY
        // ====================================================================
        
        /**
         * Check if IST autosave is enabled
         */
        function isIstAutosaveEnabled() {
            return document.getElementById('ist-autosave')?.checked ?? true;
        }
        
        /**
         * Handle IST cell change for autosave
         */
        function handleIstCellAutosave(input) {
            if (!isIstAutosaveEnabled()) return;
            
            const key = getIstCellKey(input);
            
            // Clear existing timer for this cell
            if (istAutosaveTimers.has(key)) {
                clearTimeout(istAutosaveTimers.get(key));
            }
            
            // Set new timer
            istAutosaveTimers.set(key, setTimeout(async () => {
                await saveIstSingleCell(input);
                istAutosaveTimers.delete(key);
            }, IST_AUTOSAVE_DELAY));
        }
        
        /**
         * Get unique key for an IST cell
         */
        function getIstCellKey(input) {
            const row = input.closest('tr');
            const roomId = row?.dataset?.roomId || '';
            const field = input.dataset?.field || '';
            const templateId = input.dataset?.templateId || '';
            return `ist-${roomId}-${field}-${templateId}`;
        }
        
        /**
         * Save a single IST cell value using partial update (PATCH)
         */
        async function saveIstSingleCell(input) {
            const row = input.closest('tr');
            const roomId = parseInt(row?.dataset?.roomId);
            if (isNaN(roomId) || roomId <= 0) return;
            
            // Save state for undo before making changes
            saveIstUndoState(roomId);
            
            try {
                // Show saving indicator
                input.style.backgroundColor = '#fff3cd';
                
                if (input.classList.contains('ist-inventory-input')) {
                    // Save inventory IST value
                    const templateId = parseInt(input.dataset.templateId);
                    if (isNaN(templateId) || templateId <= 0) return;
                    
                    const dataType = input.dataset.datatype || 'text';
                    const value = getBooleanValueForInput(input, dataType);
                    
                    await updateIstRoomInventory(roomId, templateId, value);
                } else if (input.classList.contains('ist-area-input')) {
                    // Save room area field using PATCH (partial update)
                    const field = input.dataset.field;
                    if (field) {
                        const value = input.value || '';
                        await patchRoomField(roomId, field, value);
                    }
                } else if (input.classList.contains('ist-comment-input')) {
                    // Save IST comment
                    const templateId = parseInt(input.dataset.templateId);
                    if (isNaN(templateId) || templateId <= 0) return;
                    
                    await updateIstRoomInventoryComment(roomId, templateId, input.value);
                }
                
                // Show success
                input.style.backgroundColor = '#d4edda';
                setTimeout(() => {
                    input.style.backgroundColor = '';
                }, 1000);
                
                // Update indicators after save
                const roomTypeId = document.getElementById('ist-filter-roomtype')?.value || '';
                const inventorySelect = document.getElementById('ist-filter-inventory');
                const selectedInventoryIds = Array.from(inventorySelect?.selectedOptions || [])
                    .map(opt => opt.value)
                    .filter(v => v);
                await updateIstIndicatorsFromApi(roomTypeId, selectedInventoryIds);
                
            } catch (error) {
                console.error('IST autosave error:', error);
                // Show error
                input.style.backgroundColor = '#f8d7da';
                setTimeout(() => {
                    input.style.backgroundColor = '';
                }, 2000);
            }
        }
        
        /**
         * Update IST room inventory comment only
         */
        async function updateIstRoomInventoryComment(roomId, templateId, comment) {
            const requestBody = {
                roomID: roomId,
                inventoryTemplateID: templateId,
                comment: comment,
                userId: getCurrentUserId()
            };
            
            const response = await fetch(`${API_RAUMPROGRAM}/roominventory`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });
            
            if (!response.ok) {
                const data = await response.json();
                throw new Error(data.message || 'Fehler beim Speichern');
            }
            
            return await response.json();
        }
        
        /**
         * Attach autosave listeners to IST table
         */
        let istAutosaveListenersAttached = false;
        
        function attachIstAutosaveListeners() {
            const tbody = document.getElementById('istTableBody');
            if (!tbody || istAutosaveListenersAttached) return;
            
            // Use event delegation
            tbody.addEventListener('input', (e) => {
                if (e.target.classList.contains('ist-input')) {
                    handleIstCellAutosave(e.target);
                }
            });
            
            tbody.addEventListener('change', (e) => {
                if (e.target.classList.contains('ist-input') && e.target.type === 'checkbox') {
                    handleIstCellAutosave(e.target);
                }
            });
            
            istAutosaveListenersAttached = true;
        }
        
        /**
         * Save all IST changes manually
         */
        async function saveAllIstChanges() {
            showResult('istResult', 'loading', '‚è≥ Speichere alle √Ñnderungen...');
            
            const rows = document.querySelectorAll('#istTableBody tr[data-room-id]');
            let savedCount = 0;
            let errorCount = 0;
            
            for (const row of rows) {
                const roomId = parseInt(row.dataset.roomId);
                if (!roomId) continue;
                
                try {
                    const originalRoom = window.currentIstRooms?.find(r => r.roomID === roomId);
                    if (!originalRoom) continue;
                    
                    // Collect area changes
                    const roomData = {
                        roomID: roomId,
                        name: originalRoom.name,
                        roomTypeID: originalRoom.roomTypeID,
                        userId: getCurrentUserId()
                    };
                    
                    // Get area inputs
                    const areaInputs = row.querySelectorAll('.ist-area-input');
                    areaInputs.forEach(input => {
                        const field = input.dataset.field;
                        if (field) {
                            roomData[field] = input.value ? parseFloat(input.value) : null;
                        }
                    });
                    
                    await updateIstRoom(roomId, roomData);
                    
                    // Handle inventory inputs
                    const inventoryInputs = row.querySelectorAll('.ist-inventory-input');
                    for (const invInput of inventoryInputs) {
                        const templateId = parseInt(invInput.dataset.templateId);
                        const dataType = invInput.dataset.datatype || 'text';
                        
                        if (templateId) {
                            const value = getBooleanValueForInput(invInput, dataType);
                            await updateIstRoomInventory(roomId, templateId, value);
                        }
                    }
                    
                    savedCount++;
                } catch (error) {
                    console.error(`Error saving room ${roomId}:`, error);
                    errorCount++;
                }
            }
            
            if (errorCount === 0) {
                showResult('istResult', 'success', `‚úÖ ${savedCount} R√§ume erfolgreich gespeichert`);
            } else {
                showResult('istResult', 'warning', `‚ö†Ô∏è ${savedCount} gespeichert, ${errorCount} Fehler`);
            }
            
            // Reload to refresh
            await loadIstData(currentIstPage);
        }
        
        // ====================================================================
        // IST UNDO/REDO FUNCTIONALITY
        // ====================================================================
        
        /**
         * Save IST state for undo
         */
        function saveIstUndoState(roomId) {
            const room = window.currentIstRooms?.find(r => r.roomID === roomId);
            if (!room) return;
            
            // Clone the room state
            const state = JSON.parse(JSON.stringify(room));
            state._timestamp = Date.now();
            
            istUndoStack.push(state);
            
            // Limit stack size
            while (istUndoStack.length > IST_UNDO_LIMIT) {
                istUndoStack.shift();
            }
            
            // Clear redo stack on new action
            istRedoStack = [];
        }
        
        /**
         * Undo last IST change
         */
        async function istUndo() {
            if (istUndoStack.length === 0) {
                showResult('istResult', 'info', '‚ÑπÔ∏è Nichts zum R√ºckg√§ngig machen');
                return;
            }
            
            const state = istUndoStack.pop();
            
            // Save current state to redo stack
            const currentRoom = window.currentIstRooms?.find(r => r.roomID === state.roomID);
            if (currentRoom) {
                istRedoStack.push(JSON.parse(JSON.stringify(currentRoom)));
                while (istRedoStack.length > IST_UNDO_LIMIT) {
                    istRedoStack.shift();
                }
            }
            
            // Restore the state
            try {
                showResult('istResult', 'loading', '‚è≥ R√ºckg√§ngig machen...');
                
                const roomData = {
                    roomID: state.roomID,
                    name: state.name,
                    roomTypeID: state.roomTypeID,
                    netAreaActual: state.netAreaActual,
                    grossAreaActual: state.grossAreaActual,
                    userId: getCurrentUserId()
                };
                
                await updateIstRoom(state.roomID, roomData);
                
                // Restore inventory values
                for (const inv of (state.inventory || [])) {
                    if (inv.valueActual !== undefined) {
                        await updateIstRoomInventory(state.roomID, inv.inventoryTemplateID, inv.valueActual);
                    }
                }
                
                await loadIstData(currentIstPage);
                showResult('istResult', 'success', '‚úÖ √Ñnderung r√ºckg√§ngig gemacht');
            } catch (error) {
                console.error('Undo error:', error);
                showResult('istResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        /**
         * Redo last undone IST change
         */
        async function istRedo() {
            if (istRedoStack.length === 0) {
                showResult('istResult', 'info', '‚ÑπÔ∏è Nichts zum Wiederholen');
                return;
            }
            
            const state = istRedoStack.pop();
            
            // Save current state to undo stack
            const currentRoom = window.currentIstRooms?.find(r => r.roomID === state.roomID);
            if (currentRoom) {
                istUndoStack.push(JSON.parse(JSON.stringify(currentRoom)));
            }
            
            // Apply the redo state
            try {
                showResult('istResult', 'loading', '‚è≥ Wiederholen...');
                
                const roomData = {
                    roomID: state.roomID,
                    name: state.name,
                    roomTypeID: state.roomTypeID,
                    netAreaActual: state.netAreaActual,
                    grossAreaActual: state.grossAreaActual,
                    userId: getCurrentUserId()
                };
                
                await updateIstRoom(state.roomID, roomData);
                
                for (const inv of (state.inventory || [])) {
                    if (inv.valueActual !== undefined) {
                        await updateIstRoomInventory(state.roomID, inv.inventoryTemplateID, inv.valueActual);
                    }
                }
                
                await loadIstData(currentIstPage);
                showResult('istResult', 'success', '‚úÖ √Ñnderung wiederhergestellt');
            } catch (error) {
                console.error('Redo error:', error);
                showResult('istResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }
        
        // ====================================================================
        // IST KEYBOARD NAVIGATION (Excel-like)
        // ====================================================================
        
        /**
         * Attach keyboard navigation to IST table
         */
        function attachIstKeyboardNavigation() {
            const table = document.getElementById('istTable');
            if (!table) return;
            
            table.addEventListener('keydown', (e) => {
                if (!e.target.classList.contains('ist-input')) return;
                
                const cell = e.target.closest('td');
                const row = cell?.closest('tr');
                const rows = Array.from(table.querySelectorAll('tbody tr'));
                const cells = row ? Array.from(row.querySelectorAll('td')) : [];
                const rowIndex = rows.indexOf(row);
                const cellIndex = cells.indexOf(cell);
                
                let targetInput = null;
                
                switch(e.key) {
                    case 'Tab':
                        // Tab already works natively
                        break;
                    case 'Enter':
                        // Move to next row, same column
                        e.preventDefault();
                        if (rowIndex < rows.length - 1) {
                            const nextRow = rows[rowIndex + 1];
                            const nextCells = Array.from(nextRow.querySelectorAll('td'));
                            if (nextCells[cellIndex]) {
                                targetInput = nextCells[cellIndex].querySelector('.ist-input');
                            }
                        }
                        break;
                    case 'ArrowUp':
                        if (rowIndex > 0) {
                            e.preventDefault();
                            const prevRow = rows[rowIndex - 1];
                            const prevCells = Array.from(prevRow.querySelectorAll('td'));
                            if (prevCells[cellIndex]) {
                                targetInput = prevCells[cellIndex].querySelector('.ist-input');
                            }
                        }
                        break;
                    case 'ArrowDown':
                        if (rowIndex < rows.length - 1) {
                            e.preventDefault();
                            const nextRow = rows[rowIndex + 1];
                            const nextCells = Array.from(nextRow.querySelectorAll('td'));
                            if (nextCells[cellIndex]) {
                                targetInput = nextCells[cellIndex].querySelector('.ist-input');
                            }
                        }
                        break;
                }
                
                if (targetInput) {
                    targetInput.focus();
                    if (targetInput.select) targetInput.select();
                }
            });
            
            // Ctrl+Z and Ctrl+Y for undo/redo
            document.addEventListener('keydown', (e) => {
                // Only handle if IST tab is active
                const istTab = document.getElementById('tab-ausgefuehrt');
                if (!istTab?.classList.contains('active')) return;
                
                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') {
                        e.preventDefault();
                        istUndo();
                    } else if (e.key === 'y') {
                        e.preventDefault();
                        istRedo();
                    }
                }
            });
        }

        /**
         * Sync IST values from IFC
         */
        async function syncIstFromIfc() {
            showResult('istResult', 'info', '‚ö†Ô∏è IFC-Synchronisation wird in einer zuk√ºnftigen Version implementiert.');
        }

        /**
         * Extract IST values from IFC file
         */
        async function extractIstFromIfc() {
            showResult('ifcExtractionResult', 'info', '‚ö†Ô∏è IFC-Extraktion wird in einer zuk√ºnftigen Version implementiert.');
        }

        // Initialize date picker with today's date as default
        document.addEventListener('DOMContentLoaded', function () {
            const dueDateField = document.getElementById('bcfDueDate');
            if (dueDateField) {
                const today = new Date().toISOString().split('T')[0];
                dueDateField.value = today;
            }
            
            // Load building list on startup
            loadBuildingList();
        });

    </script>
</body>
</html>
