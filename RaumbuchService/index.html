<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raumbuch Manager - Lokal</title>
    <link rel="stylesheet" href="Content/Site.css">
    <!-- Trimble Workspace API -->
    <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
    <script src="Scripts/app.js"></script>
</head>



<body>
    <div class="container">
        <!-- =============================== -->
        <!-- TOP TAB NAVIGATION (Trimble Connect style) -->
        <!-- =============================== -->
        <nav class="tc-tabs">
            <div class="tc-tab active" onclick="openTab('tab-konfig')">
                <img src="img/book.png" class="tc-tab-icon" />
                <span>Raumbuch</span>
            </div>

            <div class="tc-tab" onclick="openTab('tab-analyse')">
                <img src="img/material.png" class="tc-tab-icon" />
                <span>Analyse</span>
            </div>

            <div class="tc-tab" onclick="openTab('tab-ausstattung')">
                <img src="img/material.png" class="tc-tab-icon" />
                <span>Ausstattungsverwaltung</span>
            </div>

            <div class="tc-tab" onclick="openTab('tab-bcf')">
                <img src="img/mail.png" class="tc-tab-icon" />
                <span>Nachricht</span>
            </div>
        </nav>

        <main>

            <!-- ========================================================= -->
            <!-- TAB 1 ‚Äì KONFIGURATION + STEP 1 + STEP 3 + STEP 4          -->
            <!-- ========================================================= -->
            <div id="tab-konfig" class="tab-content active">


                <!-- STEP 0 ‚Äì CONFIGURATION -->
                <section class="card">
                    <h2>Konfiguration</h2>

                    <!-- Authentication is managed by Trimble Connect Extension API -->
                    <!-- Manual token input field (commented out - authentication handled by extension API) -->
                    <!--
                    <div class="form-group">
                        <label for="accessToken">Access Token:</label>
                        <input type="text" id="accessToken" class="form-control" placeholder="Token hier einf√ºgen...">
                    </div>
                    -->

                    <!-- Project ID retrieved from Trimble Connect context -->
                    <!-- Manual project ID input field (commented out - project ID retrieved from extension context) -->
                    <!--
                    <div class="form-group">
                        <label for="projectId">Project ID:</label>
                        <input type="text" id="projectId" class="form-control" value="y7-N0uBcXNI">
                    </div>
                    -->

                    <div class="form-group">
                        <label for="configName">Konfigurationsname:</label>
                        <input type="text" id="configName" class="form-control" placeholder="z.B. 'MeinProjekt_Config'">
                        <small>Geben Sie einen Namen ein (wird beim ersten Speichern verwendet)</small>
                    </div>

                    <div class="form-group">
                        <label>Gespeicherte Konfigurationen (Azure):</label>
                        <div style="display:flex; gap:10px; align-items:flex-start;">
                            <select id="savedConfigs" class="form-control" style="flex:1;">
                                <option value="">-- Laden Sie Projektdaten um Konfigurationen zu sehen --</option>
                            </select>
                            <button class="btn btn-secondary" onclick="loadConfigFromAzure()">üì• Laden</button>
                            <button class="btn btn-danger" onclick="deleteConfigFromAzure()">üóëÔ∏è L√∂schen</button>
                        </div>
                        <small>Konfigurationen werden in Azure Blob Storage gespeichert</small>
                    </div>

                    <div class="form-group">
                        <button class="btn btn-secondary" onclick="saveConfig()">üíæ Konfiguration speichern</button>
                        <button class="btn btn-primary" onclick="loadProjectData()">üìÅ Projektdaten laden</button>
                    </div>

                    <hr>

                    <!-- Target Folder -->
                    <div class="form-group">
                        <label for="targetFolder">Zielordner:</label>
                        <select id="targetFolder" class="form-control">
                            <option value="">-- Klicken Sie auf "Projektdaten laden" --</option>
                        </select>
                        <button class="btn btn-secondary" onclick="fetchFiles()">üîÑ Dateien laden</button>
                    </div>

                    <div id="connectionResult" class="result"></div>
                </section>


                <!-- =============================== -->
                <!-- Kombinert: Vorlage + Raumbuch -->
                <!-- =============================== -->
                <section class="card">
                    <h2>Raumprogramm & Raumbuch</h2>
                    <p>Vorlage importieren und Raumbuch erzeugen/aktualisieren</p>

                    <!-- TEMPLATE -->
                    <div class="form-group">
                        <label for="templateFile">Vorlagendatei (.xlsx):</label>
                        <div style="display:flex; gap:10px; align-items:flex-start;">
                            <select id="templateFile" class="form-control">
                                <option value="">-- Vorlage ausw√§hlen nach "Dateien laden" --</option>
                            </select>

                            <!-- Import template moved here -->
                            <button class="btn btn-primary" onclick="importTemplate()">üì• Raumprogramm erstellen</button>
                        </div>

                    </div>

                    <!-- RAUMPROGRAMM -->
                    <div class="form-group">
                        <label for="raumprogrammFile">Raumprogramm-Datei (.xlsx):</label>
                        <select id="raumprogrammFile" class="form-control" style="flex:1;">
                            <option value="">-- Raumprogramm ausw√§hlen nach "Dateien laden" --</option>
                        </select>

                        <small>W√§hlen Sie die Raumprogramm.xlsx aus Schritt 1</small>
                    </div>

                    <!-- IFC FILE -->
                    <div class="form-group">
                        <label for="ifcFile">Datei mit IfcSpaces (.ifc):</label>
                        <select id="ifcFile" class="form-control">
                            <option value="">-- IFC ausw√§hlen nach "Dateien laden" --</option>
                        </select>
                    </div>



                    <!-- RAUMBUCH -->
                    <div class="form-group">
                        <label for="raumbuchFile">Raumbuch-Datei (.xlsx):</label>

                        <div style="display:flex; gap:10px; align-items:flex-start;">
                            <select id="raumbuchFile" class="form-control" style="flex:1;">
                                <option value="">-- Raumbuch ausw√§hlen nach "Dateien laden" --</option>
                            </select>

                            <!-- IFC -> Raumbuch -->
                            <button class="btn btn-primary" onclick="importIfc()">üèóÔ∏è Raumbuch erstellen</button>
                            <button class="btn btn-secondary" onclick="updateRaumbuch()">üîÑ Raumbuch aktualisieren</button>
                        </div>

                        <small>Wird automatisch ausgef√ºllt nach "IFC importieren"</small>
                    </div>

                    <div id="step1Result" class="result"></div>
                    <div id="step3Result" class="result"></div>
                </section>


            </div> <!-- END TAB 1 -->

            <!-- ========================================================= -->
            <!-- TAB 2 ‚Äì ANALYSE (SOLL/IST + ZUSAMMENFASSUNG)              -->
            <!-- ========================================================= -->
            <div id="tab-analyse" class="tab-content">

                <!-- KPI Summary Widget -->
                <section class="card kpi-widget">
                    <h2>üìä √úbersicht</h2>
                    <div class="kpi-container">
                        <div class="kpi-item">
                            <span class="kpi-label">SOLL Gesamt</span>
                            <span class="kpi-value" id="kpiSollTotal">- m¬≤</span>
                        </div>
                        <div class="kpi-item">
                            <span class="kpi-label">IST Gesamt</span>
                            <span class="kpi-value" id="kpiIstTotal">- m¬≤</span>
                        </div>
                        <div class="kpi-item">
                            <span class="kpi-label">Abweichung</span>
                            <span class="kpi-value" id="kpiDeviation">- %</span>
                        </div>
                        <div class="kpi-item kpi-status-ok">
                            <span class="kpi-label">Erf√ºllt</span>
                            <span class="kpi-value" id="kpiOkCount">0</span>
                        </div>
                        <div class="kpi-item kpi-status-under">
                            <span class="kpi-label">Unterschritten</span>
                            <span class="kpi-value" id="kpiUnderCount">0</span>
                        </div>
                        <div class="kpi-item kpi-status-over">
                            <span class="kpi-label">√úberschritten</span>
                            <span class="kpi-value" id="kpiOverCount">0</span>
                        </div>
                    </div>
                </section>

                <!-- Tolerance Configuration -->
                <section class="card">
                    <h2>‚öôÔ∏è Toleranz-Einstellungen</h2>
                    <div class="tolerance-controls">
                        <div class="form-group" style="display:inline-block; margin-right:20px;">
                            <label for="toleranceMin">Minimum Toleranz (%):</label>
                            <input type="number" id="toleranceMin" class="form-control" value="-10" min="-100" max="0" style="width:100px;">
                        </div>
                        <div class="form-group" style="display:inline-block; margin-right:20px;">
                            <label for="toleranceMax">Maximum Toleranz (%):</label>
                            <input type="number" id="toleranceMax" class="form-control" value="10" min="0" max="100" style="width:100px;">
                        </div>
                        <button class="btn btn-secondary" onclick="applyToleranceSettings()">Toleranz anwenden</button>
                    </div>
                </section>

                <!-- Filter and Search Controls -->
                <section class="card">
                    <h2>üîç Filter & Suche</h2>
                    <div class="filter-controls">
                        <div class="filter-buttons">
                            <button class="btn btn-secondary filter-btn active" data-filter="all" onclick="filterAnalyseTable('all')">Alle</button>
                            <button class="btn btn-secondary filter-btn" data-filter="ok" onclick="filterAnalyseTable('ok')">‚úÖ Erf√ºllt</button>
                            <button class="btn btn-secondary filter-btn" data-filter="under" onclick="filterAnalyseTable('under')">‚ö†Ô∏è Unterschritten</button>
                            <button class="btn btn-secondary filter-btn" data-filter="over" onclick="filterAnalyseTable('over')">üìä √úberschritten</button>
                        </div>
                        <div class="search-box">
                            <input type="text" id="analyseSearch" class="form-control" placeholder="Suche nach Raumtyp..." onkeyup="searchAnalyseTable()">
                        </div>
                    </div>
                </section>

                <!-- Zusammenfassung Table -->
                <section class="card">
                    <h2>üìã Zusammenfassung (SOLL/IST-Analyse)</h2>
                    <p>√úbersicht der Fl√§chenanalyse nach Raumkategorie</p>
                    
                    <div class="analyse-table-container">
                        <table class="analyse-table" id="analyseTable">
                            <thead>
                                <tr>
                                    <th onclick="sortAnalyseTable(0)">Raumtyp ‚Üï</th>
                                    <th onclick="sortAnalyseTable(1)">SOLL (m¬≤) ‚Üï</th>
                                    <th onclick="sortAnalyseTable(2)">IST (m¬≤) ‚Üï</th>
                                    <th>Abweichung</th>
                                    <th onclick="sortAnalyseTable(4)">Status ‚Üï</th>
                                    <th>Kommentar</th>
                                </tr>
                            </thead>
                            <tbody id="analyseTableBody">
                                <tr>
                                    <td colspan="6" style="text-align:center; color:#666;">
                                        Keine Daten vorhanden. Bitte laden Sie eine Konfiguration oder erstellen Sie ein Raumbuch.
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                    
                    <div style="margin-top:15px;">
                        <button class="btn btn-primary" onclick="loadAnalyseData()">üì• Daten laden</button>
                        <button class="btn btn-primary" onclick="saveAnalyseChanges()">üíæ √Ñnderungen speichern</button>
                    </div>
                    <div id="analyseResult" class="result"></div>
                </section>

                <!-- Soll/Ist-Pr√ºfung (moved from Raumbuch tab) -->
                <section class="card">
                    <h2>Soll/Ist-Pr√ºfung</h2>
                    <p>Die Differenz in der Fl√§che zwischen Raumprogramm (SOLL) und Raumbuch (IST) wird f√ºr jede Raumkategorie in Pset Raumbuch geschrieben.</p>

                    <button class="btn btn-primary" onclick="writePset()">üìù Pset schreiben</button>
                    <button class="btn btn-secondary" onclick="updatePset()">üîÑ Pset aktualisieren</button>
                    <button class="btn btn-secondary" onclick="deletePset()">üóëÔ∏è Pset l√∂schen</button>
                    <div id="step4Result" class="result"></div>
                </section>

            </div> <!-- END TAB 2 (ANALYSE) -->

            <!-- ========================================================= -->
            <!-- TAB 3 ‚Äì AUSSTATTUNGSVERWALTUNG (STEP 5)                   -->
            <!-- ========================================================= -->
            <div id="tab-ausstattung" class="tab-content">

                <section class="card">

                    <!-- Subsection: Room sheets -->
                    <div class="subsection">
                        <h2>Raumbl√§tter erstellen</h2>
                        <p>Erstellt ein Raumblatt pro Raum im Raumbuch</p>

                        <button class="btn btn-primary" onclick="createRoomSheets()">üìã Raumbl√§tter erstellen</button>
                        <button class="btn btn-secondary" onclick="deleteRoomLists()">üóëÔ∏è Raumbl√§tter l√∂schen</button>

                        <div id="step5_1Result" class="result"></div>
                    </div>

                    <hr style="margin:20px 0;">

                    <!-- Subsection: Inventory -->
                    <div class="subsection">
                        <h2>Ausstattung erstellen</h2>
                        <p>Raumbl√§tter mit Ausstattungen f√ºllen</p>

                        <div class="form-group">
                            <label for="inventoryFolder">Zielordner f√ºr IFC-Dateien:</label>
                            <select id="inventoryFolder" class="form-control">
                                <option value="">-- Klicken Sie auf "Projektdaten laden" --</option>
                            </select>
                        </div>

                        <button class="btn btn-primary" onclick="loadIfcFilesForInventory()">üìÅ IFC-Dateien laden</button>

                        <div class="form-group">
                            <label>IFC-Dateien ausw√§hlen:</label>
                            <div id="ifcFilesList" class="file-selection-list">
                                <p style="color:#666;">Klicken Sie auf "IFC-Dateien laden"</p>
                            </div>
                        </div>

                        <div class="form-group">
                            <label for="psetPartialName">Pset Name (teilweise):</label>
                            <input type="text" id="psetPartialName" class="form-control" value="Plancal nova">
                        </div>

                        <div class="form-group">
                            <label for="roomPropertyName">Eigenschaft f√ºr Raumnummer:</label>
                            <input type="text" id="roomPropertyName" class="form-control" value="Room Nbr">
                        </div>

                        <button class="btn btn-primary" onclick="discoverProperties()">üîç Eigenschaften laden</button>

                        <div class="form-group">
                            <label for="additionalProperties">Zus√§tzliche Eigenschaften:</label>
                            <select id="additionalProperties" class="form-control" multiple size="8">
                                <option value="">-- Klicken Sie auf "Verf√ºgbare Eigenschaften laden" --</option>
                            </select>
                        </div>

                        <button class="btn btn-primary" onclick="fillInventory()">üì¶ Ausstattungen erstellen</button>
                        <button class="btn btn-secondary" onclick="updateInventory()">üîÑ Ausstattungen aktualisieren</button>

                        <div id="step5_2Result" class="result"></div>

                    </div>
                </section>

            </div> <!-- END TAB 2 -->
            <!-- ========================================================= -->
            <!-- TAB 3 ‚Äì BCF TOPIC (STEP 2)                                -->
            <!-- ========================================================= -->
            <div id="tab-bcf" class="tab-content">

                <section class="card">
                    <h2>BCF-Themen erstellen</h2>

                    <div class="form-group">
                        <label for="bcfTitle">Titel:</label>
                        <input type="text" id="bcfTitle" class="form-control" value="Raumbuch">
                    </div>

                    <div class="form-group">
                        <label for="bcfAssignees">Zuweisen an (E-Mail):</label>
                        <select id="bcfAssignees" class="form-control" multiple size="5">
                            <option value="">-- Klicken Sie auf "Projektdaten laden" --</option>
                        </select>
                        <small>Mehrfachauswahl: Strg/Cmd</small>
                    </div>

                    <div class="form-group">
                        <label for="bcfDescription">Beschreibung:</label>
                        <textarea id="bcfDescription" class="form-control" rows="3">
Das Raumprogramm wurde erstellt. Den Link zum Ordner f√ºr die weitere Arbeit finden Sie unter ‚ÄûVerweise‚Äù.
                </textarea>
                    </div>

                    <div class="form-group">
                        <label for="bcfPriority">Priorit√§t:</label>
                        <select id="bcfPriority" class="form-control">
                            <option value="">-- Keine Priorit√§t --</option>
                            <option value="Low">Niedrig</option>
                            <option value="Normal">Normal</option>
                            <option value="High">Hoch</option>
                            <option value="Critical">Kritisch</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label for="bcfDueDate">F√§lligkeitsdatum:</label>
                        <input type="date" id="bcfDueDate" class="form-control">
                        <small>Wird automatisch auf heute gesetzt</small>
                    </div>

                    <button class="btn btn-primary" onclick="createBcfTopic()">üìã BCF-Themen erstellen</button>

                    <div id="step2Result" class="result"></div>

                </section>

            </div> <!-- END TAB 3 -->

        </main>



        <footer>
            <p>Raumbuch Manager v2.0 - Buildingpoint Schweiz AG</p>
            <p id="apiEndpoint"></p>
        </footer>
    </div>

    <script>
        // Use relative URLs to work in both local development and Azure deployment
        const API_BASE = '/api/raumbuch';
        const API_PROJECT = '/api/project';

        // Display the current API endpoint in footer
        document.getElementById('apiEndpoint').textContent = `API: ${window.location.origin}`;

        // ====================================================================
        // TRIMBLE CONNECT WORKSPACE & EXTENSION API INTEGRATION
        // ====================================================================
        
        // Store authentication and context from Trimble Connect
        let trimbleConnect = {
            accessToken: null,
            projectId: null,
            isEmbedded: false,
            isWorkspaceApp: false, // New flag for Workspace API
            consentStatus: 'pending' // pending, granted, denied
        };

        // Helper functions to expose to app.js for Workspace API integration
        window.setWorkspaceToken = function(token) {
            console.log('Setting workspace token from app.js');
            trimbleConnect.accessToken = token;
            trimbleConnect.isWorkspaceApp = true;
            trimbleConnect.consentStatus = 'granted';
            
            // Try to auto-load configs if we also have project ID
            tryAutoLoadConfigs();
        };

        window.setWorkspaceProjectId = function(projectId) {
            console.log('Setting workspace project ID from app.js:', projectId);
            trimbleConnect.projectId = projectId;
            trimbleConnect.isWorkspaceApp = true;
            
            // Try to auto-load configs if we also have token
            tryAutoLoadConfigs();
        };
        
        // Auto-load saved configurations when both token and projectId are available
        async function tryAutoLoadConfigs() {
            const token = getToken();
            const projectId = getProjectId();
            
            if (token && projectId) {
                console.log('Auto-loading saved configurations for project:', projectId);
                try {
                    await loadSavedConfigurations(projectId);
                    showResult('connectionResult', 'success', '‚úÖ Konfigurationen geladen. Klicken Sie "Projektdaten laden" f√ºr weitere Daten.');
                } catch (error) {
                    console.error('Error auto-loading configurations:', error);
                }
            }
        }

        // Check if running inside Trimble Connect as an extension
        function isInsideTrimbleConnect() {
            try {
                return window.parent !== window && 
                       window.parent.TrimbleConnectWorkspace !== undefined &&
                       window.parent.TrimbleConnectWorkspace !== null;
            } catch (e) {
                return false;
            }
        }

        // Initialize Trimble Connect Extension API
        function initializeTrimbleConnectExtension() {
            // Check if Workspace API is being initialized (app.js will handle authentication)
            // Check for both old WorkspaceAPI and new TrimbleConnectWorkspace
            if (window.WorkspaceAPI || window.TrimbleConnectWorkspace) {
                console.log('Workspace API detected - waiting for app.js to initialize');
                trimbleConnect.isEmbedded = true;
                trimbleConnect.isWorkspaceApp = true;
                // app.js will call setWorkspaceToken and setWorkspaceProjectId
                return;
            }
            
            trimbleConnect.isEmbedded = isInsideTrimbleConnect();
            
            if (trimbleConnect.isEmbedded) {
                console.log('Running inside Trimble Connect - initializing legacy extension API');
                
                try {
                    const workspace = window.parent.TrimbleConnectWorkspace;
                    
                    // Request permission to use access token
                    workspace.extension.requestPermission()
                        .then(result => {
                            console.log('Extension permission result:', result);
                            
                            if (result === 'granted') {
                                trimbleConnect.consentStatus = 'granted';
                                console.log('Permission granted - waiting for accessToken event');
                            } else if (result === 'denied') {
                                trimbleConnect.consentStatus = 'denied';
                                console.error('Permission denied by user');
                                showResult('connectionResult', 'error', '‚ùå Zugriff verweigert. Bitte erlauben Sie den Zugriff in den Extension-Einstellungen.');
                            } else if (result === 'pending') {
                                trimbleConnect.consentStatus = 'pending';
                                console.log('Permission pending - user needs to grant consent');
                            }
                        })
                        .catch(error => {
                            console.error('Error requesting permission:', error);
                            showResult('connectionResult', 'error', '‚ùå Fehler beim Anfordern der Berechtigung: ' + error.message);
                        });
                    
                    // Listen for accessToken event (fired when token is available/refreshed)
                    workspace.extension.addEventListener('accessToken', (event) => {
                        console.log('Received accessToken event from Trimble Connect');
                        
                        if (event && event.detail && event.detail.token) {
                            trimbleConnect.accessToken = event.detail.token;
                            trimbleConnect.consentStatus = 'granted';
                            console.log('Access token received and stored');
                            
                            // Automatically load project data when token is received
                            if (trimbleConnect.projectId) {
                                console.log('Auto-loading project data with token and project ID');
                                loadProjectData().catch(error => {
                                    console.error('Error auto-loading project data:', error);
                                    showResult('connectionResult', 'error', '‚ö† Fehler beim automatischen Laden der Projektdaten. Bitte versuchen Sie "Projektdaten laden".');
                                });
                            }
                        } else {
                            console.error('Invalid accessToken event - missing token');
                        }
                    });
                    
                    // Get project context (project ID)
                    workspace.getContext()
                        .then(context => {
                            console.log('Trimble Connect context:', context);
                            if (context && context.project && context.project.id) {
                                trimbleConnect.projectId = context.project.id;
                                console.log('Project ID retrieved from context:', trimbleConnect.projectId);
                                
                                // If we already have the token, auto-load project data
                                if (trimbleConnect.accessToken) {
                                    console.log('Auto-loading project data with both token and project ID');
                                    loadProjectData().catch(error => {
                                        console.error('Error auto-loading project data:', error);
                                        showResult('connectionResult', 'error', '‚ö† Fehler beim automatischen Laden der Projektdaten. Bitte versuchen Sie "Projektdaten laden".');
                                    });
                                }
                            } else {
                                console.warn('No project context available from Trimble Connect');
                            }
                        })
                        .catch(error => {
                            console.error('Error getting Trimble Connect context:', error);
                            showResult('connectionResult', 'error', '‚ö† Fehler beim Abrufen des Projekt-Kontexts von Trimble Connect.');
                        });
                        
                } catch (error) {
                    console.error('Error initializing Trimble Connect Extension API:', error);
                    showResult('connectionResult', 'error', '‚ùå Fehler beim Initialisieren der Trimble Connect Extension API: ' + error.message);
                }
            } else {
                console.log('Not running inside Trimble Connect - standalone mode');
                // For local development/testing, fallback to manual input fields would be used
                // (currently commented out in HTML)
            }
        }

        // Initialize on page load - but after app.js has had a chance to load
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializeTrimbleConnectExtension);
        } else {
            // DOM already loaded, wait a bit for app.js to initialize
            setTimeout(initializeTrimbleConnectExtension, 100);
        }

        function openTab(tabId) {
            // hide all tabs
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));

            // deactivate tabs
            document.querySelectorAll('.tc-tab').forEach(t => t.classList.remove('active'));

            // show selected tab
            document.getElementById(tabId).classList.add('active');

            // activate tab button
            const index = ['tab-konfig', 'tab-analyse', 'tab-ausstattung', 'tab-bcf'].indexOf(tabId);
            document.querySelectorAll('.tc-tab')[index].classList.add('active');
            
            // Auto-load data when Analyse tab is opened
            if (tabId === 'tab-analyse') {
                const raumbuchFileId = document.getElementById('raumbuchFile')?.value;
                if (raumbuchFileId && getToken()) {
                    loadAnalyseData();
                }
            }
        }

        // Global configuration object
        let currentConfig = {
            projectId: '',
            projectName: '',
            targetFolder: null,
            files: {
                template: null,
                raumprogramm: null,
                ifcModel: null,
                raumbuch: null
            },
            bcfAssignees: [],
            // New: Summary data for Analyse tab
            zusammenfassung: [],
            // Tolerance settings
            toleranceMin: -10,
            toleranceMax: 10,
            toleranceProfiles: [
                { name: 'Strenge Kontrolle (¬±5%)', min: -5, max: 5 },
                { name: 'Normal (¬±10%)', min: -10, max: 10 },
                { name: 'Fr√ºhe Projektphase (¬±20%)', min: -20, max: 20 }
            ]
        };

        function getToken() {
            // Use Trimble Connect token if available (from Workspace API or Extension API)
            if ((trimbleConnect.isEmbedded || trimbleConnect.isWorkspaceApp) && trimbleConnect.accessToken) {
                return trimbleConnect.accessToken;
            }
            
            // Fallback to manual input field (for local development)
            const tokenField = document.getElementById('accessToken');
            if (tokenField) {
                return tokenField.value.trim();
            }
            
            return '';
        }

        function getProjectId() {
            // Use Trimble Connect project ID if available (from Workspace API or Extension API)
            if ((trimbleConnect.isEmbedded || trimbleConnect.isWorkspaceApp) && trimbleConnect.projectId) {
                return trimbleConnect.projectId;
            }
            
            // Fallback to manual input field (for local development)
            const projectField = document.getElementById('projectId');
            if (projectField) {
                return projectField.value.trim();
            }
            
            return '';
        }

        function getTargetFolder() {
            const select = document.getElementById('targetFolder');
            const value = select.value;
            console.log('getTargetFolder() - selected value:', value);
            console.log('getTargetFolder() - selected index:', select.selectedIndex);
            console.log('getTargetFolder() - selected option:', select.options[select.selectedIndex]);
            return value;
        }

        function showResult(elementId, type, message) {
            const el = document.getElementById(elementId);
            el.className = `result ${type}`;
            el.innerHTML = message;
        }

        // ====================================================================
        //  CONFIGURATION MANAGEMENT
        // ====================================================================

        async function loadProjectData() {
            const token = getToken();
            const projectId = getProjectId();

            // Skip validation if we're waiting for credentials from Workspace/Extension API
            if (!token || !projectId) {
                // If we have neither token nor project ID, show a loading message instead of error
                // The app is likely still initializing via Workspace API
                if (trimbleConnect.isEmbedded || trimbleConnect.isWorkspaceApp) {
                    console.log('Waiting for Workspace API to provide token and project ID...');
                    showResult('connectionResult', 'loading', '‚è≥ Warte auf Authentifizierung...');
                } else {
                    showResult('connectionResult', 'error', '‚ö† Bitte authentifizieren Sie sich √ºber Trimble Connect');
                }
                return;
            }

            showResult('connectionResult', 'loading', '‚è≥ Projektdaten werden geladen...');

            try {
                // Load folders
                console.log('Loading folders...');
                const foldersResponse = await fetch(`${API_PROJECT}/folders`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessToken: token, projectId: projectId })
                });

                const contentType = foldersResponse.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const textResponse = await foldersResponse.text();
                    console.error('Non-JSON response:', textResponse);
                    showResult('connectionResult', 'error', '‚ùå Ung√ºltige Antwort vom Server (kein JSON)');
                    return;
                }

                const foldersData = await foldersResponse.json();
                console.log('Folders response:', foldersData);

                if (foldersResponse.ok && foldersData.success) {
                    const select = document.getElementById('targetFolder');

                    if (!foldersData.folders || !Array.isArray(foldersData.folders)) {
                        showResult('connectionResult', 'error', '‚ùå Keine Ordner-Daten in Antwort');
                        return;
                    }

                    select.innerHTML = '<option value="">-- Ordner ausw√§hlen --</option>';

                    // Also populate inventory folder dropdown
                    const inventoryFolderSelect = document.getElementById('inventoryFolder');
                    if (inventoryFolderSelect) {
                        inventoryFolderSelect.innerHTML = '<option value="">-- Ordner ausw√§hlen --</option>';
                    }

                    if (foldersData.folders.length === 0) {
                        showResult('connectionResult', 'error', '‚ö† Keine Ordner gefunden');
                        return;
                    }

                    foldersData.folders.forEach((folder) => {
                        const option = document.createElement('option');
                        option.value = folder.id || '';
                        option.textContent = folder.path || folder.name || 'Unnamed folder';
                        option.dataset.name = folder.name || '';
                        option.dataset.path = folder.path || '';
                        select.appendChild(option);

                        // Add to inventory folder dropdown
                        if (inventoryFolderSelect) {
                            const inventoryOption = document.createElement('option');
                            inventoryOption.value = folder.id || '';
                            inventoryOption.textContent = folder.path || folder.name || 'Unnamed folder';
                            inventoryOption.dataset.name = folder.name || '';
                            inventoryOption.dataset.path = folder.path || '';
                            inventoryFolderSelect.appendChild(inventoryOption);
                        }
                    });

                    console.log('Folders loaded:', foldersData.folders.length);
                } else {
                    const errorMsg = foldersData.message || foldersData.Message || 'Unbekannter Fehler';
                    showResult('connectionResult', 'error', `‚ùå ${errorMsg}`);
                    return;
                }

                // Load users
                console.log('Loading users...');
                const usersResponse = await fetch(`${API_PROJECT}/users`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessToken: token, projectId: projectId })
                });

                const usersData = await usersResponse.json();
                console.log('Users response:', usersData);

                if (usersResponse.ok && usersData.success) {
                    const select = document.getElementById('bcfAssignees');
                    select.innerHTML = '';

                    if (!usersData.users || !Array.isArray(usersData.users)) {
                        showResult('connectionResult', 'warning', `‚úÖ ${foldersData.folders.length} Ordner geladen, aber keine Benutzer gefunden`);
                        return;
                    }

                    usersData.users.forEach(user => {
                        const option = document.createElement('option');
                        option.value = user.email;
                        option.textContent = `${user.displayName} (${user.email})`;
                        option.dataset.id = user.id;
                        option.dataset.displayName = user.displayName;
                        select.appendChild(option);
                    });

                    console.log('Users loaded:', usersData.users.length);
                    showResult('connectionResult', 'success', `‚úÖ ${foldersData.folders.length} Ordner und ${usersData.users.length} Benutzer geladen!`);
                } else {
                    const errorMsg = usersData.message || usersData.Message || 'Unbekannter Fehler';
                    showResult('connectionResult', 'warning', `‚úÖ ${foldersData.folders.length} Ordner geladen, aber Fehler beim Laden der Benutzer: ${errorMsg}`);
                }

                // Load saved configurations from Azure
                await loadSavedConfigurations(projectId);
            } catch (error) {
                console.error('Error in loadProjectData:', error);
                showResult('connectionResult', 'error', '‚ùå Fehler bei der Authentifizierung mit Trimble Connect');
            }
        }

        async function loadSavedConfigurations(projectId) {
            try {
                console.log('Loading saved configurations for project:', projectId);
                const response = await fetch(`${API_PROJECT}/config/list`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ projectId: projectId })
                });

                if (!response.ok) {
                    console.warn('Failed to load configurations:', response.status);
                    return;
                }

                const data = await response.json();
                const configSelect = document.getElementById('savedConfigs');
                configSelect.innerHTML = '<option value="">-- Konfiguration ausw√§hlen --</option>';

                if (data.success && data.configurations && data.configurations.length > 0) {
                    data.configurations.forEach(config => {
                        const option = document.createElement('option');
                        option.value = config.name;
                        const dateStr = config.lastModified ? new Date(config.lastModified).toLocaleDateString('de-DE') : '';
                        option.textContent = `${config.name} ${dateStr ? '(' + dateStr + ')' : ''}`;
                        configSelect.appendChild(option);
                    });
                    console.log(`Loaded ${data.configurations.length} saved configurations`);
                } else {
                    configSelect.innerHTML = '<option value="">-- Keine gespeicherten Konfigurationen --</option>';
                }
            } catch (error) {
                console.error('Error loading saved configurations:', error);
            }
        }

        async function fetchFolders() {
            // This function is now replaced by loadProjectData()
            // Keeping it for backward compatibility if called from elsewhere
            await loadProjectData();
        }

        async function fetchUsers() {
            // This function is now replaced by loadProjectData()
            // Keeping it for backward compatibility if called from elsewhere
            await loadProjectData();
        }

        async function fetchFiles() {
            const token = getToken();
            const folderId = getTargetFolder();

            console.log('fetchFiles() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Folder ID:', folderId);

            if (!token || !folderId) {
                if (!token) {
                    showResult('connectionResult', 'error', '‚ö† Authentifizierung l√§uft... Bitte warten Sie, bis Trimble Connect die Verbindung hergestellt hat.');
                } else {
                    showResult('connectionResult', 'error', '‚ö† Bitte w√§hlen Sie zuerst einen Zielordner aus');
                }
                console.error('Missing token or folderId');
                return;
            }

            showResult('connectionResult', 'loading', '‚è≥ Dateien werden geladen...');

            try {
                // Fetch Excel files for all dropdowns (template, raumprogramm, raumbuch)
                console.log('Fetching Excel files from folder:', folderId);
                const excelResponse = await fetch(`${API_PROJECT}/files`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        folderId: folderId,
                        fileExtensions: ['xlsx']
                    })
                });

                console.log('Excel response status:', excelResponse.status);
                const excelData = await excelResponse.json();
                console.log('Excel response data:', excelData);

                if (excelResponse.ok && excelData.success) {
                    // Populate template dropdown
                    const templateSelect = document.getElementById('templateFile');
                    templateSelect.innerHTML = '<option value="">-- Vorlage ausw√§hlen --</option>';

                    // Populate raumprogramm dropdown (Step 3)
                    const raumprogrammSelect = document.getElementById('raumprogrammFile');
                    raumprogrammSelect.innerHTML = '<option value="">-- Raumprogramm ausw√§hlen --</option>';

                    // Populate raumbuch dropdown (Step 4)
                    const raumbuchSelect = document.getElementById('raumbuchFile');
                    raumbuchSelect.innerHTML = '<option value="">-- Raumbuch ausw√§hlen --</option>';

                    console.log('Excel files found:', excelData.files?.length || 0);

                    if (excelData.files && excelData.files.length > 0) {
                        excelData.files.forEach(file => {
                            console.log('Adding Excel file:', file.name);

                            // Add to template dropdown
                            const templateOption = document.createElement('option');
                            templateOption.value = file.id;
                            templateOption.textContent = file.name;
                            templateOption.dataset.name = file.name;
                            templateOption.dataset.versionId = file.versionId;
                            templateSelect.appendChild(templateOption);

                            // Add to raumprogramm dropdown
                            const raumprogrammOption = document.createElement('option');
                            raumprogrammOption.value = file.id;
                            raumprogrammOption.textContent = file.name;
                            raumprogrammOption.dataset.name = file.name;
                            raumprogrammOption.dataset.versionId = file.versionId;
                            raumprogrammSelect.appendChild(raumprogrammOption);

                            // Add to raumbuch dropdown (used by both Step 3 update and Step 4 pset operations)
                            const raumbuchOption = document.createElement('option');
                            raumbuchOption.value = file.id;
                            raumbuchOption.textContent = file.name;
                            raumbuchOption.dataset.name = file.name;
                            raumbuchOption.dataset.versionId = file.versionId;
                            raumbuchSelect.appendChild(raumbuchOption);
                        });
                    }
                } else {
                    console.error('Excel fetch failed:', excelData);
                }

                // Fetch IFC files for IFC dropdown
                console.log('Fetching IFC files from folder:', folderId);
                const ifcResponse = await fetch(`${API_PROJECT}/files`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        folderId: folderId,
                        fileExtensions: ['ifc']
                    })
                });

                console.log('IFC response status:', ifcResponse.status);
                const ifcData = await ifcResponse.json();
                console.log('IFC response data:', ifcData);

                if (ifcResponse.ok && ifcData.success) {
                    const ifcSelect = document.getElementById('ifcFile');

                    ifcSelect.innerHTML = '<option value="">-- IFC ausw√§hlen --</option>';

                    console.log('IFC files found:', ifcData.files?.length || 0);

                    if (ifcData.files && ifcData.files.length > 0) {
                        ifcData.files.forEach(file => {
                            console.log('Adding IFC file:', file.name);
                            const option = document.createElement('option');
                            option.value = file.id;
                            option.textContent = file.name;
                            option.dataset.name = file.name;
                            ifcSelect.appendChild(option);
                        });
                    }
                } else {
                    console.error('IFC fetch failed:', ifcData);
                }

                const excelCount = excelData.files?.length || 0;
                const ifcCount = ifcData.files?.length || 0;

                console.log('Total files:', excelCount, 'Excel,', ifcCount, 'IFC');
                showResult('connectionResult', 'success', `‚úÖ Dateien geladen! ${excelCount} Excel, ${ifcCount} IFC`);
            } catch (error) {
                console.error('Error in fetchFiles:', error);
                console.error('Error stack:', error.stack);
                showResult('connectionResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function fetchUsers() {
            const token = getToken();
            const projectId = getProjectId();

            if (!token || !projectId) {
                showResult('step2Result', 'error', '‚ö† Bitte warten Sie auf die Authentifizierung √ºber Trimble Connect');
                return;
            }

            showResult('step2Result', 'loading', '‚è≥ Benutzer werden geladen...');

            try {
                const response = await fetch(`${API_PROJECT}/users`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessToken: token, projectId: projectId })
                });

                console.log('Response status:', response.status);
                const contentType = response.headers.get('content-type');
                console.log('Content-Type:', contentType);

                if (!contentType || !contentType.includes('application/json')) {
                    const textResponse = await response.text();
                    console.error('Non-JSON response:', textResponse);
                    showResult('step2Result', 'error', '‚ùå Ung√ºltige Antwort vom Server (kein JSON)');
                    return;
                }

                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    const select = document.getElementById('bcfAssignees');
                    select.innerHTML = '';

                    const users = data.users || data.Users;
                    if (!users || !Array.isArray(users)) {
                        showResult('step2Result', 'error', '‚ö† Keine Benutzer-Daten in Antwort');
                        return;
                    }

                    console.log('Number of users:', users.length);

                    users.forEach(user => {
                        console.log('Adding user:', user.email, user.displayName);
                        const option = document.createElement('option');
                        option.value = user.email || user.Email;
                        option.textContent = `${user.displayName || user.DisplayName} (${user.email || user.Email})`;
                        option.dataset.id = user.id || user.Id;
                        option.dataset.displayName = user.displayName || user.DisplayName;
                        select.appendChild(option);
                    });

                    showResult('step2Result', 'success', `‚úÖ ${users.length} Benutzer geladen!`);
                } else {
                    console.error('Response not OK or success=false');
                    const errorMsg = data.message || data.Message || 'Unbekannter Fehler';
                    showResult('step2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in fetchUsers:', error);
                console.error('Error stack:', error.stack);
                showResult('step2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function saveConfig() {
            const configName = document.getElementById('configName').value.trim();
            const projectId = getProjectId();

            if (!configName) {
                alert('‚ö† Bitte geben Sie einen Konfigurations-Namen ein!');
                return;
            }

            if (!projectId) {
                alert('‚ö† Warte auf Projekt-ID von Trimble Connect. Bitte versuchen Sie es in wenigen Sekunden erneut.');
                return;
            }

            // Build configuration object including all user choices
            const config = {
                projectId: projectId,
                projectName: configName,
                lastUpdated: new Date().toISOString(),
                targetFolder: getSelectedOption('targetFolder'),
                files: {
                    template: getSelectedOption('templateFile'),
                    raumprogramm: getSelectedOption('raumprogrammFile'),
                    ifcModel: getSelectedOption('ifcFile'),
                    raumbuch: getSelectedOption('raumbuchFile')
                },
                bcfAssignees: getSelectedUsers(),
                // Analyse tab settings
                zusammenfassung: currentConfig.zusammenfassung || [],
                toleranceMin: toleranceSettings.min,
                toleranceMax: toleranceSettings.max,
                toleranceProfiles: currentConfig.toleranceProfiles || [],
                // Ausstattung tab settings
                inventoryFolder: getSelectedOption('inventoryFolder'),
                psetPartialName: document.getElementById('psetPartialName')?.value || 'Plancal nova',
                roomPropertyName: document.getElementById('roomPropertyName')?.value || 'Room Nbr',
                selectedIfcFiles: getSelectedIfcFiles(),
                selectedProperties: getSelectedProperties()
            };

            try {
                showResult('connectionResult', 'info', 'üîÑ Speichere Konfiguration...');

                // Try to save to Azure
                const response = await fetch(`${API_PROJECT}/config/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        configName: configName,
                        configuration: config
                    })
                });

                // Check if response is OK first
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Server error response:', response.status, errorText);
                    throw new Error(`Server error (${response.status}): ${errorText.substring(0, 200)}`);
                }

                const data = await response.json();
                console.log('Save config response:', data);

                if (data.success) {
                    if (data.savedToAzure) {
                        showResult('connectionResult', 'success', `‚úÖ ${data.message}`);
                        // Reload the configurations list
                        await loadSavedConfigurations(projectId);
                    } else {
                        // Azure not configured, download as file
                        const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${configName}.json`;
                        a.click();
                        URL.revokeObjectURL(url);
                        showResult('connectionResult', 'success', `‚úÖ Konfiguration "${configName}.json" heruntergeladen (lokaler Modus)!`);
                    }
                } else {
                    throw new Error(data.message || 'Fehler beim Speichern (keine Fehlermeldung vom Server)');
                }
            } catch (error) {
                console.error('Error saving config:', error);
                showResult('connectionResult', 'error', `‚ùå Fehler beim Speichern: ${error.message}`);
            }
        }

        async function loadConfigFromAzure() {
            const configName = document.getElementById('savedConfigs').value;
            const projectId = getProjectId();

            if (!configName) {
                alert('‚ö† Bitte w√§hlen Sie eine Konfiguration aus!');
                return;
            }

            if (!projectId) {
                alert('‚ö† Project ID nicht gefunden!');
                return;
            }

            try {
                showResult('connectionResult', 'info', 'üîÑ Lade Konfiguration...');

                const response = await fetch(`${API_PROJECT}/config/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId: projectId,
                        configName: configName
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.success && data.configuration) {
                    applyConfiguration(data.configuration);
                    showResult('connectionResult', 'success', `‚úÖ ${data.message}`);
                } else {
                    throw new Error(data.message || 'Fehler beim Laden');
                }
            } catch (error) {
                console.error('Error loading config from Azure:', error);
                showResult('connectionResult', 'error', `‚ùå Fehler beim Laden: ${error.message}`);
            }
        }

        async function deleteConfigFromAzure() {
            const configName = document.getElementById('savedConfigs').value;
            const projectId = getProjectId();

            if (!configName) {
                alert('‚ö† Bitte w√§hlen Sie eine Konfiguration aus!');
                return;
            }

            if (!projectId) {
                alert('‚ö† Project ID nicht gefunden!');
                return;
            }

            // Confirm deletion
            if (!confirm(`M√∂chten Sie die Konfiguration "${configName}" wirklich l√∂schen?`)) {
                return;
            }

            try {
                showResult('connectionResult', 'info', 'üîÑ L√∂sche Konfiguration...');

                const response = await fetch(`${API_PROJECT}/config/delete`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId: projectId,
                        configName: configName
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (data.success) {
                    showResult('connectionResult', 'success', `‚úÖ ${data.message}`);
                    // Reload the configurations list
                    await loadSavedConfigurations(projectId);
                } else {
                    throw new Error(data.message || 'Fehler beim L√∂schen');
                }
            } catch (error) {
                console.error('Error deleting config from Azure:', error);
                showResult('connectionResult', 'error', `‚ùå Fehler beim L√∂schen: ${error.message}`);
            }
        }

        function applyConfiguration(config) {
            currentConfig = config;

            // Fill Project ID and Name (only if fields exist - they may be hidden in extension mode)
            const projectIdField = document.getElementById('projectId');
            if (projectIdField) {
                projectIdField.value = config.projectId || '';
            }
            document.getElementById('configName').value = config.projectName || '';

            // Fill Target Folder (display name in readonly field if not in dropdown yet)
            if (config.targetFolder) {
                const folderSelect = document.getElementById('targetFolder');
                // Try to find and select the folder
                let found = false;
                for (let i = 0; i < folderSelect.options.length; i++) {
                    if (folderSelect.options[i].value === config.targetFolder.id) {
                        folderSelect.selectedIndex = i;
                        found = true;
                        break;
                    }
                }
                if (!found && config.targetFolder.id) {
                    // Add as option if not found
                    const option = document.createElement('option');
                    option.value = config.targetFolder.id;
                    option.textContent = config.targetFolder.path || config.targetFolder.name;
                    option.dataset.name = config.targetFolder.name;
                    option.dataset.path = config.targetFolder.path;
                    folderSelect.appendChild(option);
                    folderSelect.value = config.targetFolder.id;
                }
            }

            // Fill Template
            if (config.files?.template) {
                setSelectValue('templateFile', config.files.template.id, config.files.template.name);
            }

            // Fill Raumprogramm (changed from readonly to dropdown)
            if (config.files?.raumprogramm) {
                setSelectValue('raumprogrammFile', config.files.raumprogramm.id, config.files.raumprogramm.name);
            }

            // Fill IFC
            if (config.files?.ifcModel) {
                setSelectValue('ifcFile', config.files.ifcModel.id, config.files.ifcModel.name);
            }

            // Fill Raumbuch (changed from readonly to dropdown)
            if (config.files?.raumbuch) {
                setSelectValue('raumbuchFile', config.files.raumbuch.id, config.files.raumbuch.name);
            }

            // Fill BCF Assignees
            if (config.bcfAssignees && config.bcfAssignees.length > 0) {
                const select = document.getElementById('bcfAssignees');
                // Pre-select users if they exist in dropdown
                for (let i = 0; i < select.options.length; i++) {
                    const option = select.options[i];
                    const isSelected = config.bcfAssignees.some(u => u.email === option.value);
                    option.selected = isSelected;
                }
            }
        }

        function getSelectedOption(selectId) {
            const select = document.getElementById(selectId);
            const option = select.options[select.selectedIndex];
            if (!option || !option.value) return null;

            return {
                id: option.value,
                name: option.dataset.name || option.textContent,
                path: option.dataset.path || ''
            };
        }

        function getSelectedUsers() {
            const select = document.getElementById('bcfAssignees');
            const users = [];
            for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].selected) {
                    users.push({
                        id: select.options[i].dataset.id || '',
                        email: select.options[i].value,
                        displayName: select.options[i].dataset.displayName || select.options[i].textContent
                    });
                }
            }
            return users;
        }

        function setSelectValue(selectId, value, name) {
            const select = document.getElementById(selectId);
            let found = false;

            // Try to find existing option
            for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].value === value) {
                    select.selectedIndex = i;
                    found = true;
                    return;
                }
            }

            // If not found, add as option
            if (!found && value && name) {
                const option = document.createElement('option');
                option.value = value;
                option.textContent = name;
                option.dataset.name = name;
                select.appendChild(option);
                select.value = value;
            }
        }

        // ====================================================================
        //  POLLING HELPER FUNCTION
        // ====================================================================

        /**
         * Polls the folder for a newly created file by name.
         * Tries up to 5 times with 500ms intervals.
         * Returns the file ID if found, or null if not found.
         */
        async function pollForFile(fileName, maxAttempts = 5, delayMs = 500) {
            const token = getToken();
            const folderId = getTargetFolder();

            console.log(`Starting polling for file: ${fileName}`);

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                console.log(`Poll attempt ${attempt}/${maxAttempts}`);
                //
                // Wait before querying
                await new Promise(resolve => setTimeout(resolve, delayMs));

                try {
                    const response = await fetch(`${API_PROJECT}/files`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            accessToken: token,
                            folderId: folderId,
                            fileExtensions: ['xlsx']
                        })
                    });

                    if (!response.ok) {
                        console.warn(`Folder query failed with status ${response.status}`);
                        continue;
                    }

                    const data = await response.json();

                    if ((data.success || data.Success) && (data.files || data.Files)) {
                        // Find the file by name (case-insensitive)
                        const files = data.files || data.Files;
                        const foundFile = files.find(f =>
                            (f.name || f.Name).toLowerCase() === fileName.toLowerCase()
                        );

                        if (foundFile && (foundFile.id || foundFile.Id)) {
                            const fileId = foundFile.id || foundFile.Id;
                            const fileName = foundFile.name || foundFile.Name;
                            console.log(`Found file: ${fileName}, ID: ${fileId}`);
                            return foundFile;
                        }
                    }

                    console.log(`File '${fileName}' not found yet. Will retry...`);
                } catch (error) {
                    console.error(`Error during poll attempt ${attempt}:`, error);
                }
            }

            console.warn(`File '${fileName}' not found after ${maxAttempts} attempts.`);
            return null;
        }

        /**
         * Updates a dropdown with a new file option and selects it.
         */
        function updateDropdownWithFile(selectId, file) {
            const select = document.getElementById(selectId);

            // Check if file already exists in dropdown
            let optionExists = false;
            for (let i = 0; i < select.options.length; i++) {
                if (select.options[i].value === file.id) {
                    select.selectedIndex = i;
                    optionExists = true;
                    break;
                }
            }

            // If not exists, add it
            if (!optionExists) {
                const option = document.createElement('option');
                option.value = file.id;
                option.textContent = file.name;
                option.dataset.name = file.name;
                select.appendChild(option);
                select.value = file.id;
            }

            console.log(`Updated dropdown ${selectId} with file: ${file.name}`);
        }

        // ====================================================================
        //  EXISTING FUNCTIONS (updated to use polling)
        // ====================================================================

        async function testConnection() {
            const token = getToken();
            const projectId = getProjectId();

            if (!token || !projectId) {
                showResult('connectionResult', 'error', '‚ö† Bitte warten Sie auf die Authentifizierung √ºber Trimble Connect');
                return;
            }

            showResult('connectionResult', 'loading', '‚è≥ Teste Verbindung...');

            try {
                const response = await fetch(`${API_BASE}/test-project`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ accessToken: token, projectId: projectId })
                });

                const data = await response.json();

                if (response.ok) {
                    showResult('connectionResult', 'success', `‚úÖ Verbindung OK! Projekt: ${data.projectId || projectId}`);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('connectionResult', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('connectionResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function importTemplate() {
            const token = getToken();
            const projectId = getProjectId();
            const templateFileId = document.getElementById('templateFile').value;
            const targetFolder = getTargetFolder();

            console.log('importTemplate() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('ProjectId:', projectId);
            console.log('Template File ID:', templateFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !templateFileId || !targetFolder || !projectId) {
                showResult('step1Result', 'error', '‚ö† Bitte alle Felder ausf√ºllen');
                return;
            }

            showResult('step1Result', 'loading', '‚è≥ Importiere Vorlage...');

            try {
                const requestBody = {
                    accessToken: token,
                    projectId: projectId,
                    templateFileId: templateFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/import-template`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok) {
                    const fileName = data.raumprogrammFileName || 'Raumprogramm.xlsx';
                    const fileId = data.raumprogrammFileId || 'N/A';

                    console.log('Raumprogramm created successfully:', fileName, fileId);

                    // Save to config
                    currentConfig.files.raumprogramm = {
                        id: fileId,
                        name: fileName
                    };

                    console.log('Updated currentConfig.files.raumprogramm:', currentConfig.files.raumprogramm);

                    showResult('step1Result', 'loading', `‚úÖ Raumprogramm erstellt!<br>‚è≥ Warte auf ID von Connect...`);

                    // Poll for the file to get the actual Connect ID
                    const foundFile = await pollForFile(fileName);

                    if (foundFile) {
                        // Update config with correct ID
                        currentConfig.files.raumprogramm.id = foundFile.id;

                        // Update dropdown in Step 3
                        updateDropdownWithFile('raumprogrammFile', foundFile);

                        showResult('step1Result', 'success',
                            `‚úÖ Erfolgreich!<br>Datei: ${fileName}<br>ID: ${foundFile.id}<br>‚úÖ Raumprogramm wurde zur Dropdown-Liste hinzugef√ºgt!`);
                    } else {
                        // File not found after polling, use backend ID
                        showResult('step1Result', 'warning',
                            `‚ö†Ô∏è Raumprogramm wurde erstellt, aber ID konnte nicht sofort abgerufen werden.<br>Datei: ${fileName}<br>Bitte klicken Sie auf "Dateien laden" um die Liste zu aktualisieren.`);
                    }
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    console.error('Import template failed:', errorMsg);
                    showResult('step1Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in importTemplate:', error);
                showResult('step1Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function createBcfTopic() {
            const token = getToken();
            const projectId = getProjectId();
            const folderId = getTargetFolder();
            const title = document.getElementById('bcfTitle').value.trim();
            const description = document.getElementById('bcfDescription').value.trim();
            const priority = document.getElementById('bcfPriority').value;
            const dueDate = document.getElementById('bcfDueDate').value;

            // Get selected users
            const selectedUsers = getSelectedUsers();
            if (selectedUsers.length === 0) {
                showResult('step2Result', 'error', '‚ö† Bitte mindestens einen Benutzer ausw√§hlen');
                return;
            }

            const assignedTo = selectedUsers.map(u => u.email).join(',');

            if (!token || !projectId || !folderId) {
                showResult('step2Result', 'error', '‚ö† Bitte Token, Project ID und Folder ausw√§hlen');
                return;
            }

            showResult('step2Result', 'loading', '‚è≥ Erstelle BCF Topic...');

            try {
                const response = await fetch(`${API_BASE}/create-bcf-topic`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        projectId: projectId,
                        folderId: folderId,
                        title: title,
                        description: description,
                        assignedTo: assignedTo,
                        createMultipleTopics: false,
                        priority: priority || null,
                        dueDate: dueDate || null
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    let resultHtml = `‚úÖ BCF Topic erfolgreich erstellt!<br>Topic GUID: ${data.topicGuid || 'N/A'}`;

                    if (data.documentReferenceGuid) {
                        resultHtml += `<br>Dokumentreferenz GUID: ${data.documentReferenceGuid}`;
                    }

                    resultHtml += `<br><br>‚ö†Ô∏è Bitte pr√ºfen Sie die Benutzerzuweisungen und Berechtigungen in Trimble Connect.`;

                    showResult('step2Result', 'success', resultHtml);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function importIfc() {
            const token = getToken();
            const projectId = getProjectId();
            const ifcFileId = document.getElementById('ifcFile').value;
            const raumprogrammFileSelect = document.getElementById('raumprogrammFile');
            const raumprogrammFileId = raumprogrammFileSelect.value;
            const targetFolder = getTargetFolder();

            console.log('importIfc() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('ProjectId:', projectId);
            console.log('IFC File ID:', ifcFileId);
            console.log('Raumprogramm File ID:', raumprogrammFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !projectId || !ifcFileId || !raumprogrammFileId || !targetFolder) {
                let missingFields = [];
                if (!token) missingFields.push('Token');
                if (!projectId) missingFields.push('Project ID');
                if (!ifcFileId) missingFields.push('IFC File');
                if (!raumprogrammFileId) missingFields.push('Raumprogramm File');
                if (!targetFolder) missingFields.push('Target Folder');

                showResult('step3Result', 'error', `‚ö† Bitte alle Felder ausf√ºllen. Fehlende Felder: ${missingFields.join(', ')}`);
                return;
            }

            showResult('step3Result', 'loading', '‚è≥ Importiere IFC und erstelle Raumbuch... (kann einige Sekunden dauern)');

            try {
                const requestBody = {
                    accessToken: token,
                    projectId: projectId,
                    ifcFileId: ifcFileId,
                    raumprogrammFileId: raumprogrammFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/import-ifc`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok) {
                    const fileName = data.raumbuchFileName || 'Raumbuch.xlsx';
                    const fileId = data.raumbuchFileId || 'N/A';

                    console.log('Raumbuch created successfully:', fileName, fileId);

                    // Save to config
                    currentConfig.files.raumbuch = {
                        id: fileId,
                        name: fileName
                    };

                    let message = `‚úÖ Raumbuch erstellt!<br>Datei: ${fileName}<br>‚è≥ Warte auf ID von Connect...<br><br><strong>Analyse:</strong><br>`;
                    if (data.analysis && data.analysis.length > 0) {
                        data.analysis.forEach(a => {
                            // Use new status logic: OK, Zu wenig, Zu viel
                            const status = a.status || (a.isUnderLimit ? '‚ö†Ô∏è Zu wenig' : (a.isOverLimit ? 'üìä Zu viel' : '‚úÖ OK'));
                            message += `- ${a.roomCategory}: ${a.percentage.toFixed(1)}% ${status}<br>`;
                        });
                    }

                    showResult('step3Result', 'loading', message);

                    // Poll for the file to get the actual Connect ID
                    const foundFile = await pollForFile(fileName);

                    if (foundFile) {
                        // Update config with correct ID
                        currentConfig.files.raumbuch.id = foundFile.id;

                        // Update dropdown (used by both Step 3 update and Step 4 pset operations)
                        updateDropdownWithFile('raumbuchFile', foundFile);

                        message = `‚úÖ Raumbuch erfolgreich erstellt!<br>Datei: ${fileName}<br>ID: ${foundFile.id}<br>‚úÖ Raumbuch wurde zur Dropdown-Liste hinzugef√ºgt!`;
                        showResult('step3Result', 'success', message);
                    } else {
                        // File not found after polling, use backend ID
                        message = `‚ö†Ô∏è Raumbuch wurde erstellt, aber ID konnte nicht sofort abgerufen werden.<br>Datei: ${fileName}<br>Bitte klicken Sie auf "Dateien laden" um die Liste zu aktualisieren.<br><br><strong>Analyse:</strong><br>`;
                        if (data.analysis && data.analysis.length > 0) {
                            data.analysis.forEach(a => {
                                // Use new status logic: OK, Zu wenig, Zu viel
                                const status = a.status || (a.isUnderLimit ? '‚ö†Ô∏è Zu wenig' : (a.isOverLimit ? 'üìä Zu viel' : '‚úÖ OK'));
                                message += `- ${a.roomCategory}: ${a.percentage.toFixed(1)}% ${status}<br>`;
                            });
                        }
                        showResult('step3Result', 'warning', message);
                    }
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step3Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in importIfc:', error);
                showResult('step3Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function updateRaumbuch() {
            const token = getToken();
            const projectId = getProjectId();
            const ifcFileId = document.getElementById('ifcFile').value;
            const raumprogrammFileId = document.getElementById('raumprogrammFile').value;
            const existingRaumbuchFileId = document.getElementById('raumbuchFile').value; // Use Step 4 dropdown
            const targetFolder = getTargetFolder();

            console.log('updateRaumbuch() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('ProjectId:', projectId);
            console.log('IFC File ID:', ifcFileId);
            console.log('Raumprogramm File ID:', raumprogrammFileId);
            console.log('Existing Raumbuch File ID:', existingRaumbuchFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !projectId || !ifcFileId || !raumprogrammFileId || !existingRaumbuchFileId || !targetFolder) {
                let missingFields = [];
                if (!token) missingFields.push('Token');
                if (!projectId) missingFields.push('Project ID');
                if (!ifcFileId) missingFields.push('IFC File');
                if (!raumprogrammFileId) missingFields.push('Raumprogramm File');
                if (!existingRaumbuchFileId) missingFields.push('Raumbuch File (siehe Schritt 4)');
                if (!targetFolder) missingFields.push('Target Folder');

                showResult('step3Result', 'error', `‚ö† Bitte alle Felder ausf√ºllen. Fehlende Felder: ${missingFields.join(', ')}`);
                return;
            }

            showResult('step3Result', 'loading', '‚è≥ Aktualisiere Raumbuch... (kann einige Sekunden dauern)');

            try {
                const requestBody = {
                    accessToken: token,
                    projectId: projectId,
                    raumbuchFileId: existingRaumbuchFileId,
                    ifcFileId: ifcFileId,
                    raumprogrammFileId: raumprogrammFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/update-raumbuch`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok) {
                    const fileName = data.raumbuchFileName || 'Raumbuch.xlsx';
                    const fileId = data.raumbuchFileId || 'N/A';

                    console.log('Raumbuch updated successfully:', fileName, fileId);

                    // Save to config
                    currentConfig.files.raumbuch = {
                        id: fileId,
                        name: fileName
                    };

                    let message = `‚úÖ Raumbuch aktualisiert!<br>Datei: ${fileName}<br>`;
                    message += `R√§ume hinzugef√ºgt: ${data.RoomsAdded || 0}<br>`;
                    message += `R√§ume aktualisiert: ${data.RoomsUpdated || 0}<br>`;
                    message += `R√§ume unver√§ndert: ${data.RoomsUnchanged || 0}`;

                    showResult('step3Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step3Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in updateRaumbuch:', error);
                showResult('step3Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function writePset() {
            const token = getToken();
            const ifcFileId = document.getElementById('ifcFile').value; // Read from Step 3
            const raumbuchFileId = document.getElementById('raumbuchFile').value; // Read from Step 3
            const targetFolder = getTargetFolder();

            if (!token || !ifcFileId || !raumbuchFileId || !targetFolder) {
                showResult('step4Result', 'error', '‚ö† Bitte alle Felder ausf√ºllen (IFC und Raumbuch aus Schritt 3 erforderlich)');
                return;
            }

            showResult('step4Result', 'loading', '‚è≥ Schreibe Pset "Raumbuch" in IFC... (kann einige Sekunden dauern)');

            try {
                const response = await fetch(`${API_BASE}/write-raumbuch-pset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        ifcFileId: ifcFileId,
                        raumbuchFileId: raumbuchFileId,
                        targetFolderId: targetFolder
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    let message = `‚úÖ ${data.Message || data.message || 'Pset erfolgreich geschrieben!'}<br>`;
                    message += `R√§ume aktualisiert: ${data.RoomsUpdated || data.roomsUpdated || 0}<br>`;
                    message += `R√§ume √ºbersprungen: ${data.RoomsSkipped || data.roomsSkipped || 0}`;

                    if (data.Warnings && data.Warnings.length > 0) {
                        message += '<br><br><strong>Warnungen:</strong><br>';
                        data.Warnings.forEach(w => {
                            message += `- ${w}<br>`;
                        });
                    }

                    showResult('step4Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step4Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step4Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function updatePset() {
            const token = getToken();
            const ifcFileId = document.getElementById('ifcFile').value; // Read from Step 3
            const raumbuchFileId = document.getElementById('raumbuchFile').value; // Read from Step 3
            const targetFolder = getTargetFolder();

            if (!token || !ifcFileId || !raumbuchFileId || !targetFolder) {
                showResult('step4Result', 'error', '‚ö† Bitte alle Felder ausf√ºllen (IFC und Raumbuch aus Schritt 3 erforderlich)');
                return;
            }

            showResult('step4Result', 'loading', '‚è≥ Aktualisiere Pset "Raumbuch" in IFC...');

            try {
                const response = await fetch(`${API_BASE}/update-raumbuch-pset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        ifcFileId: ifcFileId,
                        raumbuchFileId: raumbuchFileId,
                        targetFolderId: targetFolder
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    let message = `‚úÖ ${data.Message || data.message || 'Pset erfolgreich aktualisiert!'}<br>`;
                    message += `R√§ume aktualisiert: ${data.RoomsUpdated || data.roomsUpdated || 0}<br>`;
                    message += `R√§ume √ºbersprungen: ${data.RoomsSkipped || data.roomsSkipped || 0}`;

                    showResult('step4Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step4Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step4Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function deletePset() {
            const token = getToken();
            const ifcFileId = document.getElementById('ifcFile').value; // Read from Step 3
            const targetFolder = getTargetFolder();

            if (!token || !ifcFileId || !targetFolder) {
                showResult('step4Result', 'error', '‚ö† Bitte IFC File aus Schritt 3 ausw√§hlen');
                return;
            }

            if (!confirm('Sind Sie sicher, dass Sie das Pset "Raumbuch" aus der IFC-Datei l√∂schen m√∂chten?')) {
                return;
            }

            showResult('step4Result', 'loading', '‚è≥ L√∂sche Pset "Raumbuch" aus IFC...');

            try {
                const response = await fetch(`${API_BASE}/delete-raumbuch-pset`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        ifcFileId: ifcFileId,
                        targetFolderId: targetFolder
                    })
                });

                const data = await response.json();

                if (response.ok) {
                    let message = `‚úÖ ${data.Message || data.message || 'Pset erfolgreich gel√∂scht!'}<br>`;
                    message += `Psets entfernt: ${data.PsetsRemoved || data.psetsRemoved || 0}`;

                    showResult('step4Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.exceptionMessage || data.Message || `HTTP ${response.status}`;
                    showResult('step4Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step4Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function createRoomSheets() {
            const token = getToken();
            const raumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();

            console.log('createRoomSheets() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Raumbuch File ID:', raumbuchFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !raumbuchFileId || !targetFolder) {
                showResult('step5_1Result', 'error', '‚ö† Bitte Token, Raumbuch-Datei und Zielordner ausw√§hlen');
                return;
            }

            showResult('step5_1Result', 'loading', '‚è≥ Erstelle Raumlisten...');

            try {
                const requestBody = {
                    accessToken: token,
                    raumbuchFileId: raumbuchFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/create-room-sheets`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    let message = `‚úÖ ${data.message || data.Message}<br>`;
                    message += `Raumlisten erstellt: ${data.roomSheetsCreated || data.RoomSheetsCreated || 0}`;

                    showResult('step5_1Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.Message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step5_1Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_1Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function loadIfcFilesForInventory() {
            const token = getToken();
            const inventoryFolderId = document.getElementById('inventoryFolder').value;

            console.log('loadIfcFilesForInventory() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Inventory Folder ID:', inventoryFolderId);

            if (!token || !inventoryFolderId) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Token und IFC-Ordner ausw√§hlen');
                return;
            }

            showResult('step5_2Result', 'loading', '‚è≥ IFC-Dateien werden geladen...');

            try {
                const response = await fetch(`${API_PROJECT}/files`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        folderId: inventoryFolderId,
                        fileExtensions: ['ifc']
                    })
                });

                console.log('IFC files response status:', response.status);
                const data = await response.json();
                console.log('IFC files response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    const ifcFilesList = document.getElementById('ifcFilesList');

                    const files = data.files || data.Files;
                    if (files && files.length > 0) {
                        // Create checkboxes for each IFC file
                        let html = '';
                        files.forEach(file => {
                            const fileId = file.id || file.Id;
                            const fileName = file.name || file.Name;
                            html += `
                                    <label class="file-checkbox-label">
                                        <input type="checkbox" id="ifc_${fileId}" value="${fileId}" class="ifc-file-checkbox file-checkbox">
                                        <span>${fileName}</span>
                                    </label>
                                `;
                        });
                        ifcFilesList.innerHTML = html;
                        showResult('step5_2Result', 'success', `‚úÖ ${files.length} IFC-Datei(en) gefunden`);
                    } else {
                        ifcFilesList.innerHTML = '<p style="color: #666;">Keine IFC-Dateien gefunden</p>';
                        showResult('step5_2Result', 'warning', '‚ö† Keine IFC-Dateien im ausgew√§hlten Ordner gefunden');
                    }
                } else {
                    const errorMsg = data.message || data.Message || `HTTP ${response.status}`;
                    showResult('step5_2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function discoverProperties() {
            const token = getToken();
            const psetPartialName = document.getElementById('psetPartialName').value;

            // Get selected IFC file IDs
            const selectedCheckboxes = document.querySelectorAll('.ifc-file-checkbox:checked');
            const ifcFileIds = Array.from(selectedCheckboxes).map(cb => cb.value);

            console.log('discoverProperties() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('IFC File IDs:', ifcFileIds);
            console.log('Pset Partial Name:', psetPartialName);

            if (!token || ifcFileIds.length === 0) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Token und mindestens eine IFC-Datei ausw√§hlen');
                return;
            }

            if (!psetPartialName) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Pset-Name angeben');
                return;
            }

            showResult('step5_2Result', 'loading', '‚è≥ Eigenschaften werden geladen...');

            try {
                const requestBody = {
                    accessToken: token,
                    ifcFileIds: ifcFileIds,
                    psetPartialName: psetPartialName
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/discover-properties`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    const select = document.getElementById('additionalProperties');
                    select.innerHTML = '';

                    const properties = data.properties || data.Properties;
                    if (properties && properties.length > 0) {
                        properties.forEach(prop => {
                            const option = document.createElement('option');
                            option.value = prop.propertyName || prop.PropertyName;
                            option.textContent = `${prop.propertyName || prop.PropertyName} (${prop.psetName || prop.PsetName})`;
                            select.appendChild(option);
                        });
                        showResult('step5_2Result', 'success', `‚úÖ ${properties.length} Eigenschaft(en) gefunden`);
                    } else {
                        select.innerHTML = '<option value="">-- Keine Eigenschaften gefunden --</option>';
                        showResult('step5_2Result', 'warning', '‚ö† Keine Eigenschaften gefunden');
                    }
                } else {
                    const errorMsg = data.message || data.Message || `HTTP ${response.status}`;
                    showResult('step5_2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                console.error('Error in discoverProperties:', error);
                showResult('step5_2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function fillInventory() {
            const token = getToken();
            const raumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();
            const psetPartialName = document.getElementById('psetPartialName').value;
            const roomPropertyName = document.getElementById('roomPropertyName').value;

            // Get selected IFC file IDs
            const selectedCheckboxes = document.querySelectorAll('.ifc-file-checkbox:checked');
            const ifcFileIds = Array.from(selectedCheckboxes).map(cb => cb.value);

            // Get selected additional properties
            const additionalPropertiesSelect = document.getElementById('additionalProperties');
            const additionalProperties = Array.from(additionalPropertiesSelect.selectedOptions).map(opt => opt.value).filter(v => v);

            console.log('fillInventory() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Raumbuch File ID:', raumbuchFileId);
            console.log('IFC File IDs:', ifcFileIds);
            console.log('Pset Partial Name:', psetPartialName);
            console.log('Additional Properties:', additionalProperties);
            console.log('Room Property Name:', roomPropertyName);

            if (!token || !raumbuchFileId || !targetFolder || ifcFileIds.length === 0) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Token, Raumbuch-Datei, Zielordner und mindestens eine IFC-Datei ausw√§hlen');
                return;
            }

            if (!psetPartialName || !roomPropertyName) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Pset-Name und Raumnummer-Eigenschaft angeben');
                return;
            }

            showResult('step5_2Result', 'loading', '‚è≥ Inventar wird erstellt...');

            try {
                const requestBody = {
                    accessToken: token,
                    raumbuchFileId: raumbuchFileId,
                    ifcFileIds: ifcFileIds,
                    psetPartialName: psetPartialName,
                    roomPropertyName: roomPropertyName,
                    targetFolderId: targetFolder,
                    additionalProperties: additionalProperties.length > 0 ? additionalProperties : null
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/fill-inventory`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    let message = `‚úÖ ${data.message || data.Message}<br>`;
                    message += `R√§ume aktualisiert: ${data.roomsUpdated || data.RoomsUpdated || 0}<br>`;
                    message += `Objekte hinzugef√ºgt: ${data.totalItems || data.TotalItems || 0}`;

                    const warnings = data.warnings || data.Warnings;
                    if (warnings && warnings.length > 0) {
                        message += '<br><br><strong>Warnungen:</strong><br>';
                        warnings.forEach(w => {
                            message += `‚ö† ${w}<br>`;
                        });
                    }

                    showResult('step5_2Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.Message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step5_2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function deleteRoomLists() {
            const token = getToken();
            const raumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();

            console.log('deleteRoomLists() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Raumbuch File ID:', raumbuchFileId);
            console.log('Target Folder:', targetFolder);

            if (!token || !raumbuchFileId || !targetFolder) {
                showResult('step5_1Result', 'error', '‚ö† Bitte Token, Raumbuch-Datei und Zielordner ausw√§hlen');
                return;
            }

            showResult('step5_1Result', 'loading', '‚è≥ L√∂sche Raumlisten...');

            try {
                const requestBody = {
                    accessToken: token,
                    raumbuchFileId: raumbuchFileId,
                    targetFolderId: targetFolder
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/delete-room-lists`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    let message = `‚úÖ ${data.message || data.Message}<br>`;
                    message += `${data.sheetsDeleted || data.SheetsDeleted || 0} Raumbl√§tter gel√∂scht<br>`;
                    message += `${data.hyperlinksRemoved || data.HyperlinksRemoved || 0} Hyperlinks entfernt`;

                    showResult('step5_1Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.Message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step5_1Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_1Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        async function updateInventory() {
            const token = getToken();
            const raumbuchFileId = document.getElementById('raumbuchFile').value;
            const targetFolder = getTargetFolder();
            const psetPartialName = document.getElementById('psetPartialName').value;
            const roomPropertyName = document.getElementById('roomPropertyName').value;

            // Get selected IFC file IDs
            const selectedCheckboxes = document.querySelectorAll('.ifc-file-checkbox:checked');
            const ifcFileIds = Array.from(selectedCheckboxes).map(cb => cb.value);

            // Get selected additional properties
            const additionalPropertiesSelect = document.getElementById('additionalProperties');
            const additionalProperties = Array.from(additionalPropertiesSelect.selectedOptions).map(opt => opt.value).filter(v => v);

            console.log('updateInventory() called');
            console.log('Token length:', token ? token.length : 0);
            console.log('Raumbuch File ID:', raumbuchFileId);
            console.log('IFC File IDs:', ifcFileIds);
            console.log('Pset Partial Name:', psetPartialName);
            console.log('Room Property Name:', roomPropertyName);
            console.log('Additional Properties:', additionalProperties);

            if (!token || !raumbuchFileId || !targetFolder || ifcFileIds.length === 0) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Token, Raumbuch-Datei, Zielordner und mindestens eine IFC-Datei ausw√§hlen');
                return;
            }

            if (!psetPartialName || !roomPropertyName) {
                showResult('step5_2Result', 'error', '‚ö† Bitte Pset-Name und Raumnummer-Eigenschaft angeben');
                return;
            }

            showResult('step5_2Result', 'loading', '‚è≥ Inventar wird aktualisiert...');

            try {
                const requestBody = {
                    accessToken: token,
                    raumbuchFileId: raumbuchFileId,
                    ifcFileIds: ifcFileIds,
                    psetPartialName: psetPartialName,
                    roomPropertyName: roomPropertyName,
                    targetFolderId: targetFolder,
                    additionalProperties: additionalProperties.length > 0 ? additionalProperties : null
                };

                console.log('Sending request body:', requestBody);

                const response = await fetch(`${API_BASE}/update-inventory`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestBody)
                });

                console.log('Response status:', response.status);
                const data = await response.json();
                console.log('Response data:', data);

                if (response.ok && (data.success || data.Success)) {
                    let message = `‚úÖ ${data.message || data.Message}<br>`;
                    message += `R√§ume aktualisiert: ${data.roomsUpdated || data.RoomsUpdated || 0}<br>`;
                    message += `Objekte gel√∂scht: ${data.itemsDeleted || data.ItemsDeleted || 0}<br>`;
                    message += `Objekte hinzugef√ºgt: ${data.itemsAdded || data.ItemsAdded || 0}`;

                    const warnings = data.warnings || data.Warnings;
                    if (warnings && warnings.length > 0) {
                        message += '<br><br><strong>Warnungen:</strong><br>';
                        warnings.forEach(w => {
                            message += `‚ö† ${w}<br>`;
                        });
                    }

                    showResult('step5_2Result', 'success', message);
                } else {
                    const errorMsg = data.message || data.Message || data.exceptionMessage || `HTTP ${response.status}`;
                    showResult('step5_2Result', 'error', `‚ùå ${errorMsg}`);
                }
            } catch (error) {
                showResult('step5_2Result', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        // ====================================================================
        //  ANALYSE TAB FUNCTIONS
        // ====================================================================

        // Store current tolerance settings
        let toleranceSettings = {
            min: -10,
            max: 10
        };

        // Store current analyse data
        let analyseData = [];

        /**
         * Loads analyse data from Zusammenfassung (from loaded config or API)
         */
        async function loadAnalyseData() {
            showResult('analyseResult', 'loading', '‚è≥ Lade Analysedaten...');

            try {
                const token = getToken();
                const raumbuchFileId = document.getElementById('raumbuchFile')?.value;

                if (!token || !raumbuchFileId) {
                    showResult('analyseResult', 'error', '‚ö†Ô∏è Bitte zuerst ein Raumbuch ausw√§hlen');
                    return;
                }

                // Load data from the Raumbuch Excel file (Zusammenfassung sheet)
                const response = await fetch(`${API_BASE}/get-zusammenfassung`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        accessToken: token,
                        raumbuchFileId: raumbuchFileId
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.zusammenfassung) {
                        analyseData = data.zusammenfassung;
                        currentConfig.zusammenfassung = data.zusammenfassung;
                        renderAnalyseTable(data.zusammenfassung);
                        updateKPIWidget(data.zusammenfassung);
                        showResult('analyseResult', 'success', `‚úÖ ${data.zusammenfassung.length} Kategorien geladen`);
                    } else {
                        showResult('analyseResult', 'warning', '‚ö†Ô∏è Keine Zusammenfassung gefunden');
                    }
                } else {
                    // Try to use cached data from config
                    if (currentConfig.zusammenfassung && currentConfig.zusammenfassung.length > 0) {
                        analyseData = currentConfig.zusammenfassung;
                        renderAnalyseTable(currentConfig.zusammenfassung);
                        updateKPIWidget(currentConfig.zusammenfassung);
                        showResult('analyseResult', 'success', `‚úÖ ${currentConfig.zusammenfassung.length} Kategorien aus Konfiguration geladen`);
                    } else {
                        showResult('analyseResult', 'error', '‚ùå Fehler beim Laden der Daten');
                    }
                }
            } catch (error) {
                console.error('Error loading analyse data:', error);
                showResult('analyseResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Renders the analyse table with the given data
         */
        function renderAnalyseTable(data) {
            const tbody = document.getElementById('analyseTableBody');
            if (!tbody) return;

            if (!data || data.length === 0) {
                tbody.innerHTML = '<tr><td colspan="7" style="text-align:center; color:#666;">Keine Daten vorhanden.</td></tr>';
                return;
            }

            let html = '';
            data.forEach((item, index) => {
                const percentage = item.percentage || item.Percentage || 0;
                const sollArea = item.sollArea || item.SollArea || 0;
                const istArea = item.istArea || item.IstArea || 0;
                const category = item.roomCategory || item.RoomCategory || '-';
                const comment = item.comment || item.Comment || '';
                
                // Determine status based on tolerance settings
                const status = getStatus(percentage, sollArea, istArea);
                const statusClass = getStatusClass(status);
                // Light green for Erf√ºllt (within tolerance), red for Unterschritten
                const rowClass = status === 'Unterschritten' ? 'analyse-row-under' : (status === 'Erf√ºllt' ? 'analyse-row-ok' : '');
                
                // Create visual bar
                const barHtml = createProgressBar(percentage);
                
                html += `
                    <tr class="analyse-row ${rowClass}" data-status="${status.toLowerCase()}" data-index="${index}">
                        <td>${escapeHtml(category)}</td>
                        <td>${sollArea.toFixed(2)}</td>
                        <td>${istArea.toFixed(2)}</td>
                        <td>${barHtml}</td>
                        <td><span class="status-badge ${statusClass}">${status}</span></td>
                        <td><input type="text" class="comment-input" value="${escapeHtml(comment)}" data-index="${index}" placeholder="Kommentar..."></td>
                    </tr>
                `;
            });

            tbody.innerHTML = html;
        }

        /**
         * Determines the status based on percentage and tolerance settings
         * Status values: Erf√ºllt (within tolerance), Unterschritten (IST < SOLL), √úberschritten (IST > SOLL)
         */
        function getStatus(percentage, sollArea, istArea) {
            // Handle null/undefined/NaN cases
            if (percentage == null || isNaN(percentage)) return 'Erf√ºllt';
            if (sollArea <= 0 && istArea <= 0) return 'Erf√ºllt';
            
            const deviation = percentage - 100;
            
            if (deviation < toleranceSettings.min) {
                return 'Unterschritten';
            } else if (deviation > toleranceSettings.max) {
                return '√úberschritten';
            }
            return 'Erf√ºllt';
        }

        /**
         * Gets the CSS class for status badge
         */
        function getStatusClass(status) {
            switch(status) {
                case 'Unterschritten': return 'status-under';
                case '√úberschritten': return 'status-over';
                default: return 'status-ok';
            }
        }

        // Constants for progress bar visualization
        const PROGRESS_BAR_MAX_PERCENT = 150;
        const DEVIATION_INTENSITY_DIVISOR = 30;

        /**
         * Creates a visual progress bar for SOLL/IST comparison
         */
        function createProgressBar(percentage) {
            // Handle null/undefined/NaN cases
            if (percentage == null || isNaN(percentage)) percentage = 0;
            
            const width = Math.min(Math.max(percentage, 0), PROGRESS_BAR_MAX_PERCENT);
            const barWidth = (width / PROGRESS_BAR_MAX_PERCENT) * 100;
            const markerPos = (100 / PROGRESS_BAR_MAX_PERCENT) * 100; // 100% marker position
            
            let barColor = '#2E8540'; // Green for OK
            if (percentage < 100 - Math.abs(toleranceSettings.min)) {
                barColor = '#D64545'; // Red for under
            } else if (percentage > 100 + toleranceSettings.max) {
                barColor = '#FFBF47'; // Yellow for over
            }
            
            // Color intensity based on deviation
            const deviation = Math.abs(percentage - 100);
            const intensity = Math.min(deviation / DEVIATION_INTENSITY_DIVISOR, 1);
            
            return `
                <div class="progress-bar-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill" style="width:${barWidth}%; background-color:${barColor}; opacity:${0.4 + intensity * 0.6};"></div>
                        <div class="progress-bar-marker" style="left:${markerPos}%;"></div>
                    </div>
                    <span class="progress-bar-label">${percentage.toFixed(0)}%</span>
                </div>
            `;
        }

        /**
         * Updates the KPI widget with summary data
         */
        function updateKPIWidget(data) {
            if (!data || data.length === 0) return;

            let totalSoll = 0;
            let totalIst = 0;
            let okCount = 0;
            let underCount = 0;
            let overCount = 0;

            data.forEach(item => {
                const soll = item.sollArea || item.SollArea || 0;
                const ist = item.istArea || item.IstArea || 0;
                const percentage = item.percentage || item.Percentage || 0;
                
                totalSoll += soll;
                totalIst += ist;
                
                const status = getStatus(percentage, soll, ist);
                if (status === 'Erf√ºllt') okCount++;
                else if (status === 'Unterschritten') underCount++;
                else if (status === '√úberschritten') overCount++;
            });

            const deviation = totalSoll > 0 ? ((totalIst / totalSoll) * 100 - 100).toFixed(1) : 0;

            document.getElementById('kpiSollTotal').textContent = totalSoll.toFixed(2) + ' m¬≤';
            document.getElementById('kpiIstTotal').textContent = totalIst.toFixed(2) + ' m¬≤';
            document.getElementById('kpiDeviation').textContent = (deviation >= 0 ? '+' : '') + deviation + '%';
            document.getElementById('kpiOkCount').textContent = okCount;
            document.getElementById('kpiUnderCount').textContent = underCount;
            document.getElementById('kpiOverCount').textContent = overCount;

            // Color the deviation based on value
            const deviationEl = document.getElementById('kpiDeviation');
            if (deviation < toleranceSettings.min) {
                deviationEl.style.color = '#D64545';
            } else if (deviation > toleranceSettings.max) {
                deviationEl.style.color = '#FFBF47';
            } else {
                deviationEl.style.color = '#2E8540';
            }
        }

        /**
         * Applies tolerance settings and re-renders the table
         */
        async function applyToleranceSettings() {
            toleranceSettings.min = parseFloat(document.getElementById('toleranceMin').value) || -10;
            toleranceSettings.max = parseFloat(document.getElementById('toleranceMax').value) || 10;
            
            // Save tolerance settings to config
            currentConfig.toleranceMin = toleranceSettings.min;
            currentConfig.toleranceMax = toleranceSettings.max;
            
            if (analyseData.length > 0) {
                renderAnalyseTable(analyseData);
                updateKPIWidget(analyseData);
                showResult('analyseResult', 'success', '‚úÖ Toleranz-Einstellungen angewendet');
            }
            
            // Auto-save config if configName is set
            await autoSaveConfig();
        }

        /**
         * Filters the analyse table by status
         */
        function filterAnalyseTable(filter) {
            // Update active button
            document.querySelectorAll('.filter-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.filter-btn[data-filter="${filter}"]`)?.classList.add('active');
            
            // Filter rows
            const rows = document.querySelectorAll('.analyse-row');
            rows.forEach(row => {
                const status = row.dataset.status;
                if (filter === 'all') {
                    row.style.display = '';
                } else if (filter === 'ok' && status === 'erf√ºllt') {
                    row.style.display = '';
                } else if (filter === 'under' && status === 'unterschritten') {
                    row.style.display = '';
                } else if (filter === 'over' && status === '√ºberschritten') {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        /**
         * Searches the analyse table
         */
        function searchAnalyseTable() {
            const searchTerm = document.getElementById('analyseSearch').value.toLowerCase();
            const rows = document.querySelectorAll('.analyse-row');
            
            rows.forEach(row => {
                const category = (row.cells && row.cells[0] && row.cells[0].textContent) ? row.cells[0].textContent.toLowerCase() : '';
                if (category.includes(searchTerm)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }

        /**
         * Sorts the analyse table by column
         */
        let sortDirection = {};
        function sortAnalyseTable(columnIndex) {
            const table = document.getElementById('analyseTable');
            const tbody = document.getElementById('analyseTableBody');
            const rows = Array.from(tbody.querySelectorAll('tr.analyse-row'));
            
            if (rows.length === 0) return;
            
            // Toggle sort direction
            sortDirection[columnIndex] = !sortDirection[columnIndex];
            const ascending = sortDirection[columnIndex];
            
            rows.sort((a, b) => {
                let aVal = (a.cells && a.cells[columnIndex] && a.cells[columnIndex].textContent) ? a.cells[columnIndex].textContent : '';
                let bVal = (b.cells && b.cells[columnIndex] && b.cells[columnIndex].textContent) ? b.cells[columnIndex].textContent : '';
                
                // Try to parse as numbers
                const aNum = parseFloat(aVal.replace(/[^0-9.-]/g, ''));
                const bNum = parseFloat(bVal.replace(/[^0-9.-]/g, ''));
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return ascending ? aNum - bNum : bNum - aNum;
                }
                
                return ascending ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
            });
            
            // Re-append sorted rows
            rows.forEach(row => tbody.appendChild(row));
        }

        /**
         * Saves analyse changes (comments) to JSON config
         */
        async function saveAnalyseChanges() {
            showResult('analyseResult', 'loading', '‚è≥ Speichere √Ñnderungen...');
            
            try {
                // Collect comments from input fields
                const commentInputs = document.querySelectorAll('.comment-input');
                commentInputs.forEach(input => {
                    const index = parseInt(input.dataset.index);
                    if (analyseData[index]) {
                        analyseData[index].comment = input.value;
                    }
                });
                
                // Update config
                currentConfig.zusammenfassung = analyseData;
                
                // Save config to Azure
                const configName = document.getElementById('configName').value.trim();
                if (!configName) {
                    showResult('analyseResult', 'error', '‚ö†Ô∏è Bitte geben Sie einen Konfigurationsnamen ein');
                    return;
                }
                
                // Build full configuration
                await saveConfig();
                showResult('analyseResult', 'success', '‚úÖ √Ñnderungen gespeichert');
            } catch (error) {
                console.error('Error saving analyse changes:', error);
                showResult('analyseResult', 'error', `‚ùå Fehler: ${error.message}`);
            }
        }

        /**
         * Auto-save configuration silently when certain actions are performed
         */
        async function autoSaveConfig() {
            const configName = document.getElementById('configName').value.trim();
            const projectId = getProjectId();
            
            if (!configName || !projectId) {
                console.log('Auto-save skipped: no config name or project ID');
                return;
            }
            
            try {
                // Build full configuration including all user choices
                const config = {
                    projectId: projectId,
                    projectName: configName,
                    lastUpdated: new Date().toISOString(),
                    targetFolder: getSelectedOption('targetFolder'),
                    files: {
                        template: getSelectedOption('templateFile'),
                        raumprogramm: getSelectedOption('raumprogrammFile'),
                        ifcModel: getSelectedOption('ifcFile'),
                        raumbuch: getSelectedOption('raumbuchFile')
                    },
                    bcfAssignees: getSelectedUsers(),
                    zusammenfassung: currentConfig.zusammenfassung || [],
                    toleranceMin: toleranceSettings.min,
                    toleranceMax: toleranceSettings.max,
                    toleranceProfiles: currentConfig.toleranceProfiles || [],
                    inventoryFolder: getSelectedOption('inventoryFolder'),
                    psetPartialName: document.getElementById('psetPartialName')?.value || 'Plancal nova',
                    roomPropertyName: document.getElementById('roomPropertyName')?.value || 'Room Nbr',
                    selectedIfcFiles: getSelectedIfcFiles(),
                    selectedProperties: getSelectedProperties()
                };
                
                // Update currentConfig
                Object.assign(currentConfig, config);
                
                const response = await fetch(`${API_PROJECT}/config/save`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        configName: configName,
                        configuration: config
                    })
                });
                
                if (response.ok) {
                    console.log('Config auto-saved successfully');
                }
            } catch (error) {
                console.error('Auto-save error:', error);
            }
        }

        /**
         * Gets selected IFC files from checkbox list
         */
        function getSelectedIfcFiles() {
            const checkboxes = document.querySelectorAll('#ifcFilesList input[type="checkbox"]:checked');
            return Array.from(checkboxes).map(cb => ({
                id: cb.value,
                name: cb.dataset.name || ''
            }));
        }

        /**
         * Gets selected properties from multi-select
         */
        function getSelectedProperties() {
            const select = document.getElementById('additionalProperties');
            if (!select) return [];
            return Array.from(select.selectedOptions).map(opt => opt.value);
        }

        /**
         * Escapes HTML to prevent XSS
         */
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Initialize date picker with today's date as default
        document.addEventListener('DOMContentLoaded', function () {
            const dueDateField = document.getElementById('bcfDueDate');
            if (dueDateField) {
                const today = new Date().toISOString().split('T')[0];
                dueDateField.value = today;
            }
        });

    </script>
</body>
</html>
