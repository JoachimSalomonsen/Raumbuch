<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raumbuch 3D Viewer Extension</title>
    <link rel="stylesheet" href="Content/Site.css">
    <!-- Trimble Workspace API -->
    <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
    <style>
        /* Additional styles for 3D Viewer extension */
        .viewer-container {
            padding: 15px;
        }
        
        .category-section {
            background: var(--tc-bg-card);
            border: 1px solid var(--tc-border);
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 12px;
        }
        
        .category-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .category-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .color-green { background-color: #2E8540; }
        .color-yellow { background-color: #FFBF47; }
        .color-red { background-color: #D64545; }
        
        .category-title {
            font-weight: 600;
            color: var(--tc-text-primary);
            flex: 1;
        }
        
        .category-count {
            font-size: 0.85em;
            color: var(--tc-text-muted);
            padding: 2px 8px;
            background: var(--tc-bg-neutral);
            border-radius: 10px;
        }
        
        .toggle-controls {
            display: flex;
            gap: 16px;
            margin-top: 8px;
        }
        
        .toggle-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
            color: var(--tc-text-secondary);
        }
        
        .toggle-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--tc-primary-blue);
            cursor: pointer;
        }
        
        .toggle-item label {
            cursor: pointer;
            font-weight: 400;
            margin: 0;
        }
        
        .file-input-section {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .file-input-section .form-group {
            flex: 1;
            min-width: 200px;
        }
        
        #jsonFileInput {
            max-width: none;
            width: 100%;
        }
        
        .room-list {
            margin-top: 8px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.85em;
            color: var(--tc-text-muted);
            padding: 8px;
            background: var(--tc-bg-neutral);
            border-radius: 4px;
        }
        
        .room-list-item {
            padding: 2px 0;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .status-connected { background-color: #2E8540; }
        .status-disconnected { background-color: #D64545; }
        .status-connecting { background-color: #FFBF47; }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--tc-bg-neutral);
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 0.9em;
        }
        
        .btn-reset {
            background-color: var(--tc-text-muted);
            color: white;
        }
        
        .btn-reset:hover {
            background-color: #6a6e72;
        }
        
        .expand-toggle {
            cursor: pointer;
            font-size: 0.85em;
            color: var(--tc-primary-blue);
            display: inline-block;
            margin-top: 4px;
            background: none;
            border: none;
            padding: 4px 0;
            font-family: inherit;
        }
        
        .expand-toggle:hover {
            text-decoration: underline;
        }
        
        .expand-toggle:focus {
            outline: 2px solid var(--tc-primary-blue);
            outline-offset: 2px;
        }
        
        .room-list.collapsed {
            display: none;
        }
        
        /* KPI Overview - Row-based layout for narrow panel */
        .kpi-overview {
            background: linear-gradient(135deg, var(--tc-dark-blue) 0%, var(--tc-primary-blue) 100%);
            color: white;
        }
        
        .kpi-overview h2 {
            color: white;
            margin-bottom: 12px;
        }
        
        .kpi-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin-bottom: 6px;
        }
        
        .kpi-row:last-child {
            margin-bottom: 0;
        }
        
        .kpi-row-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .kpi-row-value {
            font-size: 1.1em;
            font-weight: bold;
        }
        
        .kpi-row-ok {
            border-left: 3px solid #2E8540;
        }
        
        .kpi-row-under {
            border-left: 3px solid #D64545;
        }
        
        .kpi-row-over {
            border-left: 3px solid #FFBF47;
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <!-- Connection Status -->
        <div class="connection-status" id="connectionStatus">
            <span class="status-indicator status-connecting" id="statusIndicator"></span>
            <span id="statusText">Verbinde mit 3D Viewer...</span>
        </div>

        <!-- Configuration Selection Section -->
        <section class="card">
            <h2>üìÅ Raumbuch Konfiguration laden</h2>
            <p>W√§hlen Sie eine gespeicherte Konfiguration aus Azure Storage.</p>
            
            <div class="file-input-section">
                <div class="form-group">
                    <label for="savedConfigs">Gespeicherte Konfigurationen:</label>
                    <select id="savedConfigs" class="form-control" style="max-width: none; width: 100%;">
                        <option value="">-- Verbinde mit Trimble Connect... --</option>
                    </select>
                </div>
                <button class="btn btn-primary" id="loadBtn" onclick="loadConfiguration()">üì• Laden</button>
                <button class="btn btn-secondary" id="refreshBtn" onclick="loadSavedConfigurations()">üîÑ Aktualisieren</button>
            </div>
            
            <div id="loadResult" class="result"></div>
        </section>

        <!-- KPI Overview Widget (row-based for narrow panel) -->
        <section class="card kpi-overview" id="kpiSection" style="display: none;">
            <h2>üìä √úbersicht</h2>
            <div class="kpi-row">
                <span class="kpi-row-label">SOLL Gesamt</span>
                <span class="kpi-row-value" id="kpiSollTotal">- m¬≤</span>
            </div>
            <div class="kpi-row">
                <span class="kpi-row-label">IST Gesamt</span>
                <span class="kpi-row-value" id="kpiIstTotal">- m¬≤</span>
            </div>
            <div class="kpi-row">
                <span class="kpi-row-label">Abweichung</span>
                <span class="kpi-row-value" id="kpiDeviation">- %</span>
            </div>
            <div class="kpi-row kpi-row-ok">
                <span class="kpi-row-label">‚úÖ Erf√ºllt</span>
                <span class="kpi-row-value" id="kpiOkCount">0</span>
            </div>
            <div class="kpi-row kpi-row-under">
                <span class="kpi-row-label">‚ö†Ô∏è Unterschritten</span>
                <span class="kpi-row-value" id="kpiUnderCount">0</span>
            </div>
            <div class="kpi-row kpi-row-over">
                <span class="kpi-row-label">üìä √úberschritten</span>
                <span class="kpi-row-value" id="kpiOverCount">0</span>
            </div>
        </section>

        <!-- Category Sections -->
        <section class="card" id="categoriesSection" style="display: none;">
            <h2>üé® Raumkategorien</h2>
            <p>Steuern Sie Farben und Sichtbarkeit der IfcSpace-Objekte nach Kategorie.</p>
            
            <!-- Erf√ºllt (Green) -->
            <div class="category-section" id="categoryErfuellt">
                <div class="category-header">
                    <div class="category-color color-green"></div>
                    <span class="category-title">‚úÖ Erf√ºllt</span>
                    <span class="category-count" id="countErfuellt">0 R√§ume</span>
                </div>
                <div class="toggle-controls">
                    <div class="toggle-item">
                        <input type="checkbox" id="colorErfuellt" checked onchange="toggleColor('erfuellt')">
                        <label for="colorErfuellt">Farbe anzeigen</label>
                    </div>
                    <div class="toggle-item">
                        <input type="checkbox" id="visibilityErfuellt" checked onchange="toggleVisibility('erfuellt')">
                        <label for="visibilityErfuellt">Sichtbar</label>
                    </div>
                </div>
                <button type="button" class="expand-toggle" aria-expanded="false" aria-controls="roomListErfuellt" onclick="toggleRoomList('erfuellt')">‚ñ∂ R√§ume anzeigen</button>
                <div class="room-list collapsed" id="roomListErfuellt" role="region">
                    <!-- Room list will be populated dynamically -->
                </div>
            </div>

            <!-- Unterschritten (Yellow) -->
            <div class="category-section" id="categoryUnterschritten">
                <div class="category-header">
                    <div class="category-color color-yellow"></div>
                    <span class="category-title">‚ö†Ô∏è Unterschritten</span>
                    <span class="category-count" id="countUnterschritten">0 R√§ume</span>
                </div>
                <div class="toggle-controls">
                    <div class="toggle-item">
                        <input type="checkbox" id="colorUnterschritten" checked onchange="toggleColor('unterschritten')">
                        <label for="colorUnterschritten">Farbe anzeigen</label>
                    </div>
                    <div class="toggle-item">
                        <input type="checkbox" id="visibilityUnterschritten" checked onchange="toggleVisibility('unterschritten')">
                        <label for="visibilityUnterschritten">Sichtbar</label>
                    </div>
                </div>
                <button type="button" class="expand-toggle" aria-expanded="false" aria-controls="roomListUnterschritten" onclick="toggleRoomList('unterschritten')">‚ñ∂ R√§ume anzeigen</button>
                <div class="room-list collapsed" id="roomListUnterschritten" role="region">
                    <!-- Room list will be populated dynamically -->
                </div>
            </div>

            <!-- √úberschritten (Red) -->
            <div class="category-section" id="categoryUeberschritten">
                <div class="category-header">
                    <div class="category-color color-red"></div>
                    <span class="category-title">üî¥ √úberschritten</span>
                    <span class="category-count" id="countUeberschritten">0 R√§ume</span>
                </div>
                <div class="toggle-controls">
                    <div class="toggle-item">
                        <input type="checkbox" id="colorUeberschritten" checked onchange="toggleColor('ueberschritten')">
                        <label for="colorUeberschritten">Farbe anzeigen</label>
                    </div>
                    <div class="toggle-item">
                        <input type="checkbox" id="visibilityUeberschritten" checked onchange="toggleVisibility('ueberschritten')">
                        <label for="visibilityUeberschritten">Sichtbar</label>
                    </div>
                </div>
                <button type="button" class="expand-toggle" aria-expanded="false" aria-controls="roomListUeberschritten" onclick="toggleRoomList('ueberschritten')">‚ñ∂ R√§ume anzeigen</button>
                <div class="room-list collapsed" id="roomListUeberschritten" role="region">
                    <!-- Room list will be populated dynamically -->
                </div>
            </div>

            <!-- Reset Button -->
            <div style="margin-top: 16px;">
                <button class="btn btn-reset" onclick="resetAllColors()">üîÑ Alle Farben zur√ºcksetzen</button>
            </div>
        </section>

        <footer>
            <p>Raumbuch 3D Viewer Extension v1.0 - Buildingpoint Schweiz AG</p>
        </footer>
    </div>

    <script>
        // ====================================================================
        // TRIMBLE CONNECT 3D VIEWER EXTENSION
        // ====================================================================
        
        // API endpoints
        const API_PROJECT = '/api/project';
        const API_RAUMBUCH = '/api/raumbuch';
        
        // Configuration constants
        // FALLBACK_BATCH_SIZE: Balance between getting enough data for functionality
        // while avoiding API rate limits and keeping load times reasonable
        const FALLBACK_BATCH_SIZE = 50;
        // UUID_PATTERN: Matches standard UUIDs with or without hyphens
        const UUID_PATTERN = /^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i;
        
        // API reference and state
        let API = null;
        let viewerAPI = null;
        let isConnected = false;
        let workspaceToken = null;
        let workspaceProjectId = null;
        let currentConfig = null;
        
        // Category data structure
        let categoryData = {
            erfuellt: { rooms: [], objectIds: [], color: '#2E8540' },
            unterschritten: { rooms: [], objectIds: [], color: '#FFBF47' },
            ueberschritten: { rooms: [], objectIds: [], color: '#D64545' }
        };
        
        // All IfcSpace objects from the model
        let allIfcSpaces = [];
        
        // ====================================================================
        // INITIALIZATION
        // ====================================================================
        
        /**
         * Helper function to set connected state and update UI
         */
        function setConnectedState(status, message) {
            isConnected = (status === 'connected');
            updateConnectionStatus(status, message);
        }
        
        async function init() {
            console.log("Initializing Raumbuch 3D Viewer Extension...");
            setConnectedState('connecting', 'Verbinde mit 3D Viewer...');
            
            try {
                // Connect to Trimble Workspace API
                API = await window.TrimbleConnectWorkspace.connect(
                    window.parent,
                    eventHandler,
                    30000
                );
                
                console.log("Connected to Workspace API:", API);
                
                // Get access token and project info
                try {
                    workspaceToken = await API.extension.requestPermission("accesstoken");
                    console.log("Access token received from Workspace API");
                    
                    const project = await API.project.getCurrentProject();
                    console.log("Current project:", project);
                    
                    if (project && project.id) {
                        workspaceProjectId = project.id;
                        console.log("Project ID from Workspace API:", workspaceProjectId);
                    }
                } catch (tokenError) {
                    console.warn("Could not get token/project:", tokenError);
                }
                
                // Initialize 3D Viewer
                if (API && API.embed && typeof API.embed.init3DViewer === 'function') {
                    viewerAPI = await API.embed.init3DViewer({});
                    console.log("3D Viewer initialized:", viewerAPI);
                    setConnectedState('connected', 'Verbunden mit 3D Viewer');
                    await loadIfcSpaces();
                } else if (API && API.viewer) {
                    // Alternative: viewer might be directly available
                    viewerAPI = API.viewer;
                    console.log("Viewer API obtained directly:", viewerAPI);
                    setConnectedState('connected', 'Verbunden mit 3D Viewer');
                    await loadIfcSpaces();
                } else {
                    console.warn("embed.init3DViewer not available, trying alternative methods...");
                    // Try to use the viewer API directly if available
                    viewerAPI = API;
                    setConnectedState('connected', 'Verbunden (eingeschr√§nkter Modus)');
                }
                
                // Load saved configurations from Azure
                if (workspaceProjectId) {
                    await loadSavedConfigurations();
                }
                
            } catch (error) {
                console.error("Error initializing extension:", error);
                setConnectedState('disconnected', 'Fehler: ' + error.message);
            }
        }
        
        function eventHandler(event, args) {
            console.log("Workspace event:", event, args);
            
            if (event === "extension.command") {
                handleCommand(args.data);
            }
            if (event === "extension.accessToken") {
                console.log("Access token event received");
                workspaceToken = args.data;
            }
            if (event === "viewer.selectionChanged") {
                console.log("Selection changed:", args);
            }
        }
        
        function handleCommand(command) {
            console.log("Command received:", command);
        }
        
        // ====================================================================
        // CONNECTION STATUS
        // ====================================================================
        
        function updateConnectionStatus(status, message) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            indicator.className = 'status-indicator';
            
            switch(status) {
                case 'connected':
                    indicator.classList.add('status-connected');
                    break;
                case 'disconnected':
                    indicator.classList.add('status-disconnected');
                    break;
                case 'connecting':
                    indicator.classList.add('status-connecting');
                    break;
            }
            
            text.textContent = message;
        }
        
        // ====================================================================
        // LOAD IFC SPACES
        // ====================================================================
        
        async function loadIfcSpaces() {
            try {
                console.log("Loading IfcSpace objects...");
                
                // Get all objects from the viewer
                if (viewerAPI && typeof viewerAPI.getObjects === 'function') {
                    const allObjects = await viewerAPI.getObjects();
                    console.log("All objects loaded:", allObjects?.length || 0);
                    
                    // Filter for IfcSpace objects
                    if (allObjects && Array.isArray(allObjects)) {
                        allIfcSpaces = allObjects.filter(obj => 
                            obj.class === 'IfcSpace' || 
                            obj.type === 'IfcSpace' ||
                            (obj.className && obj.className.includes('IfcSpace'))
                        );
                        console.log("IfcSpace objects found:", allIfcSpaces.length);
                    }
                } else if (viewerAPI && typeof viewerAPI.objects === 'object') {
                    // Alternative method using objects property
                    const objectsResult = await viewerAPI.objects.getAll();
                    if (objectsResult && Array.isArray(objectsResult)) {
                        allIfcSpaces = objectsResult.filter(obj => 
                            obj.class === 'IfcSpace' || obj.type === 'IfcSpace'
                        );
                    }
                }
                
                console.log("IfcSpace objects loaded:", allIfcSpaces.length);
                
            } catch (error) {
                console.error("Error loading IfcSpace objects:", error);
            }
        }
        
        // ====================================================================
        // AZURE CONFIGURATION LOADING
        // ====================================================================
        
        function showResult(elementId, type, message) {
            const el = document.getElementById(elementId);
            el.className = `result ${type}`;
            el.innerHTML = message;
        }
        
        /**
         * Loads saved configurations from Azure Storage
         */
        async function loadSavedConfigurations() {
            try {
                console.log('Loading saved configurations for project:', workspaceProjectId);
                
                const response = await fetch(`${API_PROJECT}/config/list`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ projectId: workspaceProjectId })
                });

                if (!response.ok) {
                    console.warn('Failed to load configurations:', response.status);
                    return;
                }

                const data = await response.json();
                const configSelect = document.getElementById('savedConfigs');
                configSelect.innerHTML = '<option value="">-- Konfiguration ausw√§hlen --</option>';

                if (data.success && data.configurations && data.configurations.length > 0) {
                    data.configurations.forEach(config => {
                        const option = document.createElement('option');
                        option.value = config.name;
                        const dateStr = config.lastModified ? new Date(config.lastModified).toLocaleDateString('de-DE') : '';
                        option.textContent = `${config.name} ${dateStr ? '(' + dateStr + ')' : ''}`;
                        configSelect.appendChild(option);
                    });
                    console.log(`Loaded ${data.configurations.length} saved configurations`);
                } else {
                    configSelect.innerHTML = '<option value="">-- Keine gespeicherten Konfigurationen --</option>';
                }
            } catch (error) {
                console.error('Error loading saved configurations:', error);
                const configSelect = document.getElementById('savedConfigs');
                configSelect.innerHTML = '<option value="">-- Fehler beim Laden --</option>';
            }
        }
        
        /**
         * Loads configuration from Azure and applies viewer data
         */
        async function loadConfiguration() {
            const configName = document.getElementById('savedConfigs').value;
            
            if (!configName) {
                showResult('loadResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie eine Konfiguration aus.');
                return;
            }
            
            if (!workspaceProjectId) {
                showResult('loadResult', 'error', '‚ö†Ô∏è Project ID nicht gefunden. Bitte Seite neu laden.');
                return;
            }
            
            showResult('loadResult', 'loading', '‚è≥ Lade Konfiguration aus Azure...');
            
            try {
                // Load configuration from Azure
                const response = await fetch(`${API_PROJECT}/config/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId: workspaceProjectId,
                        configName: configName
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText || 'Verbindungsfehler'}`);
                }

                const data = await response.json();

                if (!data.success || !data.configuration) {
                    throw new Error(data.message || 'Fehler beim Laden');
                }
                
                currentConfig = data.configuration;
                console.log("Loaded configuration:", currentConfig);
                
                // Check if we have viewer data in the config
                if (currentConfig.viewerData) {
                    // Use pre-saved viewer data
                    processViewerData(currentConfig.viewerData);
                } else if (currentConfig.files && currentConfig.files.raumbuch && (currentConfig.files.raumbuch.id || currentConfig.files.raumbuch) && workspaceToken) {
                    // Load viewer data from Raumbuch file
                    await loadViewerDataFromRaumbuch(currentConfig);
                } else {
                    // Try to use zusammenfassung data if available
                    if (currentConfig.zusammenfassung && currentConfig.zusammenfassung.length > 0) {
                        processZusammenfassungData(currentConfig.zusammenfassung, currentConfig.toleranceMin || -10, currentConfig.toleranceMax || 10);
                    } else {
                        showResult('loadResult', 'error', '‚ö†Ô∏è Keine Raumbuch-Daten in der Konfiguration gefunden.');
                        return;
                    }
                }
                
                // Update KPI widget with zusammenfassung data
                if (currentConfig.zusammenfassung && currentConfig.zusammenfassung.length > 0) {
                    updateKPIWidget(currentConfig.zusammenfassung, currentConfig.toleranceMin || -10, currentConfig.toleranceMax || 10);
                }
                
                // Show categories section
                document.getElementById('categoriesSection').style.display = 'block';
                
                // Apply colors to 3D viewer
                await applyAllColors();
                
                showResult('loadResult', 'success', 
                    `‚úÖ Konfiguration geladen!<br>` +
                    `Erf√ºllt: ${categoryData.erfuellt.rooms.length} Raumtypen<br>` +
                    `Unterschritten: ${categoryData.unterschritten.rooms.length} Raumtypen<br>` +
                    `√úberschritten: ${categoryData.ueberschritten.rooms.length} Raumtypen`
                );
                
            } catch (error) {
                console.error("Error loading configuration:", error);
                showResult('loadResult', 'error', '‚ùå Fehler beim Laden: ' + error.message);
            }
        }
        
        /**
         * Loads viewer data from Raumbuch file via API
         */
        async function loadViewerDataFromRaumbuch(config) {
            // config.files.raumbuch is an object with id and name properties
            const raumbuchFile = config.files?.raumbuch;
            const raumbuchFileId = raumbuchFile?.id || raumbuchFile;
            
            if (!raumbuchFileId || !workspaceToken) {
                throw new Error('Raumbuch-Datei ID oder Token fehlt');
            }
            
            console.log('Loading viewer data for Raumbuch file:', raumbuchFileId);
            
            const response = await fetch(`${API_RAUMBUCH}/get-viewer-data`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    accessToken: workspaceToken,
                    raumbuchFileId: raumbuchFileId,
                    toleranceMin: config.toleranceMin || -10,
                    toleranceMax: config.toleranceMax || 10
                })
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('API error response:', errorText);
                throw new Error(`Fehler beim Laden der Viewer-Daten: HTTP ${response.status} ${response.statusText || ''}`);
            }
            
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.message || 'Fehler beim Laden der Viewer-Daten');
            }
            
            processViewerData(data);
        }
        
        /**
         * Processes viewer data from API (Raumtyp values that match IfcSpace.LongName)
         */
        function processViewerData(data) {
            // Reset category data
            categoryData = {
                erfuellt: { rooms: [], objectIds: [], color: '#2E8540' },
                unterschritten: { rooms: [], objectIds: [], color: '#FFBF47' },
                ueberschritten: { rooms: [], objectIds: [], color: '#D64545' }
            };
            
            // Process viewer data (Raumtyp values that match IfcSpace.LongName)
            categoryData.erfuellt.rooms = data.Erfuellt || data.erfuellt || [];
            categoryData.unterschritten.rooms = data.Unterschritten || data.unterschritten || [];
            categoryData.ueberschritten.rooms = data.Ueberschritten || data.ueberschritten || [];
            
            // Update UI counts
            updateCategoryCounts();
            
            // Find matching object IDs
            findMatchingObjects();
        }
        
        /**
         * Processes zusammenfassung data to extract Raumtyp values by status
         */
        function processZusammenfassungData(zusammenfassung, toleranceMin, toleranceMax) {
            // Reset category data
            categoryData = {
                erfuellt: { rooms: [], objectIds: [], color: '#2E8540' },
                unterschritten: { rooms: [], objectIds: [], color: '#FFBF47' },
                ueberschritten: { rooms: [], objectIds: [], color: '#D64545' }
            };
            
            zusammenfassung.forEach(item => {
                const raumtyp = item.roomCategory || item.RoomCategory;
                const percentage = item.percentage || item.Percentage || 100;
                
                if (!raumtyp) return;
                
                const deviation = percentage - 100;
                
                if (deviation < toleranceMin) {
                    categoryData.unterschritten.rooms.push(raumtyp);
                } else if (deviation > toleranceMax) {
                    categoryData.ueberschritten.rooms.push(raumtyp);
                } else {
                    categoryData.erfuellt.rooms.push(raumtyp);
                }
            });
            
            // Update UI counts
            updateCategoryCounts();
            
            // Find matching object IDs
            findMatchingObjects();
            
            // Update KPI widget with zusammenfassung data
            if (currentConfig && currentConfig.zusammenfassung) {
                updateKPIWidget(currentConfig.zusammenfassung, toleranceMin, toleranceMax);
            }
        }
        
        /**
         * Updates KPI widget with summary data (row-based layout)
         */
        function updateKPIWidget(zusammenfassung, toleranceMin, toleranceMax) {
            if (!zusammenfassung || zusammenfassung.length === 0) return;

            let totalSoll = 0;
            let totalIst = 0;
            let okCount = 0;
            let underCount = 0;
            let overCount = 0;

            zusammenfassung.forEach(item => {
                const soll = item.sollArea || item.SollArea || 0;
                const ist = item.istArea || item.IstArea || 0;
                const percentage = item.percentage || item.Percentage || 100;
                
                totalSoll += soll;
                totalIst += ist;
                
                const deviation = percentage - 100;
                if (deviation < toleranceMin) underCount++;
                else if (deviation > toleranceMax) overCount++;
                else okCount++;
            });

            const deviation = totalSoll > 0 ? ((totalIst / totalSoll) * 100 - 100).toFixed(1) : 0;

            document.getElementById('kpiSollTotal').textContent = totalSoll.toFixed(2) + ' m¬≤';
            document.getElementById('kpiIstTotal').textContent = totalIst.toFixed(2) + ' m¬≤';
            document.getElementById('kpiDeviation').textContent = (deviation >= 0 ? '+' : '') + deviation + '%';
            document.getElementById('kpiOkCount').textContent = okCount;
            document.getElementById('kpiUnderCount').textContent = underCount;
            document.getElementById('kpiOverCount').textContent = overCount;

            // Color the deviation based on value
            const deviationEl = document.getElementById('kpiDeviation');
            if (deviation < toleranceMin) {
                deviationEl.style.color = '#ffcccc';
            } else if (deviation > toleranceMax) {
                deviationEl.style.color = '#ffffcc';
            } else {
                deviationEl.style.color = '#ccffcc';
            }
            
            // Show KPI section
            document.getElementById('kpiSection').style.display = 'block';
        }
        
        function updateCategoryCounts() {
            document.getElementById('countErfuellt').textContent = 
                `${categoryData.erfuellt.rooms.length} R√§ume`;
            document.getElementById('countUnterschritten').textContent = 
                `${categoryData.unterschritten.rooms.length} R√§ume`;
            document.getElementById('countUeberschritten').textContent = 
                `${categoryData.ueberschritten.rooms.length} R√§ume`;
            
            // Update room lists
            updateRoomList('erfuellt', categoryData.erfuellt.rooms);
            updateRoomList('unterschritten', categoryData.unterschritten.rooms);
            updateRoomList('ueberschritten', categoryData.ueberschritten.rooms);
        }
        
        function updateRoomList(category, rooms) {
            const listId = 'roomList' + category.charAt(0).toUpperCase() + category.slice(1);
            const listEl = document.getElementById(listId);
            
            if (rooms.length === 0) {
                listEl.innerHTML = '<div class="room-list-item">Keine R√§ume in dieser Kategorie</div>';
            } else {
                listEl.innerHTML = rooms.map(room => 
                    `<div class="room-list-item">‚Ä¢ ${escapeHtml(room)}</div>`
                ).join('');
            }
        }
        
        function toggleRoomList(category) {
            const listId = 'roomList' + category.charAt(0).toUpperCase() + category.slice(1);
            const listEl = document.getElementById(listId);
            const toggleEl = listEl.previousElementSibling;
            
            const isExpanded = !listEl.classList.contains('collapsed');
            
            if (isExpanded) {
                listEl.classList.add('collapsed');
                toggleEl.textContent = '‚ñ∂ R√§ume anzeigen';
                toggleEl.setAttribute('aria-expanded', 'false');
            } else {
                listEl.classList.remove('collapsed');
                toggleEl.textContent = '‚ñº R√§ume ausblenden';
                toggleEl.setAttribute('aria-expanded', 'true');
            }
        }
        
        // ====================================================================
        // OBJECT MATCHING
        // ====================================================================
        
        async function findMatchingObjects() {
            console.log("Finding matching objects...");
            console.log("Looking for Raumtypen:", {
                erfuellt: categoryData.erfuellt.rooms,
                unterschritten: categoryData.unterschritten.rooms,
                ueberschritten: categoryData.ueberschritten.rooms
            });
            
            // Reset object IDs
            categoryData.erfuellt.objectIds = [];
            categoryData.unterschritten.objectIds = [];
            categoryData.ueberschritten.objectIds = [];
            
            try {
                // Use API.viewer which has the correct methods
                if (!API || !API.viewer) {
                    console.warn("API.viewer not available");
                    return;
                }
                
                // Log available API.viewer methods for debugging
                console.log("Available API.viewer methods:", Object.keys(API.viewer).filter(k => typeof API.viewer[k] === 'function'));
                
                // Step 1: Get loaded models using getModels()
                const models = await API.viewer.getModels();
                console.log("Loaded models:", models);
                
                if (!models || models.length === 0) {
                    console.warn("No models loaded in viewer");
                    return;
                }
                
                // Step 2: For each model, get IfcSpace entities with filtering
                for (const model of models) {
                    const modelId = model.id || model.modelId || model;
                    console.log("Processing model:", modelId);
                    
                    // Try to get IfcSpace entities using EntityParameter filter
                    let ifcSpaceEntities = [];
                    try {
                        // Try filtering by class using EntityParameter
                        ifcSpaceEntities = await API.viewer.getEntities({ 
                            modelId: modelId,
                            class: 'IfcSpace' 
                        });
                        console.log(`Model ${modelId}: ${ifcSpaceEntities?.length || 0} IfcSpace entities (filtered)`);
                    } catch (e) {
                        console.log("getEntities with filter failed, trying alternative:", e.message);
                    }
                    
                    // If filtering didn't work, get all entities and filter manually
                    if (!ifcSpaceEntities || ifcSpaceEntities.length === 0) {
                        try {
                            const allEntities = await API.viewer.getEntities(modelId);
                            console.log(`Model ${modelId}: ${allEntities?.length || 0} total entities`);
                            
                            // Log structure of first entity for debugging (browser handles object inspection)
                            if (allEntities && allEntities.length > 0) {
                                console.log("Sample entity structure:", allEntities[0]);
                            }
                            
                            // Filter for IfcSpace
                            if (allEntities && Array.isArray(allEntities)) {
                                ifcSpaceEntities = allEntities.filter(entity => {
                                    const className = (entity.class || entity.type || entity.className || entity.ifcType || '').toLowerCase();
                                    return className.includes('ifcspace') || className === 'space';
                                });
                                console.log(`Filtered to ${ifcSpaceEntities.length} IfcSpace entities`);
                            }
                        } catch (e) {
                            console.warn("getEntities failed for model:", modelId, e);
                        }
                    }
                    
                    if (!ifcSpaceEntities || ifcSpaceEntities.length === 0) {
                        // No IfcSpace in this model, skip
                        continue;
                    }
                    
                    // Log IfcSpace entities for debugging
                    console.log(`Found ${ifcSpaceEntities.length} IfcSpace entities in model ${modelId}`);
                    if (ifcSpaceEntities.length > 0) {
                        console.log("Sample IfcSpace entity:", ifcSpaceEntities[0]);
                    }
                    
                    // Step 3: Get object IDs (runtime IDs) for IfcSpace entities
                    const objectRuntimeIds = ifcSpaceEntities.map(e => {
                        // Handle different ID formats
                        if (typeof e === 'number') return e;
                        return e.runtimeId || e.id || e.objectId || e.entityId;
                    }).filter(id => id !== undefined && id !== null);
                    
                    console.log(`Got ${objectRuntimeIds.length} IfcSpace object runtime IDs:`, objectRuntimeIds.slice(0, 10));
                    
                    if (objectRuntimeIds.length === 0) continue;
                    
                    // Step 4: Get properties for IfcSpace objects
                    // Try multiple API call formats to find one that works
                    let properties = null;
                    
                    // Approach 1: Try with ModelObjectIds format
                    try {
                        const propRequest = {
                            modelId: modelId,
                            objectRuntimeIds: objectRuntimeIds
                        };
                        console.log("Trying getObjectProperties with ModelObjectIds format:", propRequest);
                        properties = await API.viewer.getObjectProperties(propRequest);
                        console.log(`Approach 1: Got properties for ${properties?.length || 0} objects`);
                    } catch (e) {
                        console.log("Approach 1 (ModelObjectIds) failed:", e.message);
                    }
                    
                    // Approach 2: Try with two separate parameters (modelId, objectIds)
                    if (!properties || properties.length === 0) {
                        try {
                            console.log("Trying getObjectProperties with (modelId, objectIds) format");
                            properties = await API.viewer.getObjectProperties(modelId, objectRuntimeIds);
                            console.log(`Approach 2: Got properties for ${properties?.length || 0} objects`);
                        } catch (e) {
                            console.log("Approach 2 (two params) failed:", e.message);
                        }
                    }
                    
                    // Approach 3: Try getting properties one by one (fallback)
                    // Uses FALLBACK_BATCH_SIZE constant to limit requests for performance
                    if (!properties || properties.length === 0) {
                        console.log(`Trying to get properties one by one (limited to first ${FALLBACK_BATCH_SIZE})...`);
                        properties = [];
                        for (let i = 0; i < Math.min(objectRuntimeIds.length, FALLBACK_BATCH_SIZE); i++) {
                            try {
                                const objId = objectRuntimeIds[i];
                                const props = await API.viewer.getObjectProperties(modelId, objId);
                                if (props) {
                                    properties.push(Array.isArray(props) ? props[0] : props);
                                }
                            } catch (e) {
                                // Continue to next object
                            }
                        }
                        console.log(`Approach 3: Got properties for ${properties.length} objects (one by one)`);
                    }
                    
                    if (properties && properties.length > 0) {
                        // Log first property object structure for debugging (let browser handle object inspection)
                        console.log("Sample property object structure:", properties[0]);
                        
                        // Match objects by Long Name property
                        properties.forEach((obj, index) => {
                            const longName = extractLongName(obj);
                            const objId = obj.runtimeId || obj.id || obj.objectId || obj.entityId || objectRuntimeIds[index];
                            
                            if (longName) {
                                console.log(`IfcSpace ${objId}: Long Name = "${longName}"`);
                                
                                // Store modelId with objectId for setObjectState
                                const objectRef = { modelId: modelId, objectRuntimeId: objId };
                                
                                // Check each category
                                if (categoryData.erfuellt.rooms.includes(longName)) {
                                    categoryData.erfuellt.objectIds.push(objectRef);
                                }
                                if (categoryData.unterschritten.rooms.includes(longName)) {
                                    categoryData.unterschritten.objectIds.push(objectRef);
                                }
                                if (categoryData.ueberschritten.rooms.includes(longName)) {
                                    categoryData.ueberschritten.objectIds.push(objectRef);
                                }
                            }
                        });
                    } else {
                        console.log("No properties returned, trying to match using entity data directly");
                        
                        // Fallback: Try to match entities directly if they have properties
                        ifcSpaceEntities.forEach(entity => {
                            const longName = extractLongName(entity);
                            const objId = entity.runtimeId || entity.id || entity.objectId || entity.entityId;
                            
                            if (longName) {
                                console.log(`Entity ${objId}: Long Name = "${longName}" (from entity)`);
                                
                                const objectRef = { modelId: modelId, objectRuntimeId: objId };
                                
                                if (categoryData.erfuellt.rooms.includes(longName)) {
                                    categoryData.erfuellt.objectIds.push(objectRef);
                                }
                                if (categoryData.unterschritten.rooms.includes(longName)) {
                                    categoryData.unterschritten.objectIds.push(objectRef);
                                }
                                if (categoryData.ueberschritten.rooms.includes(longName)) {
                                    categoryData.ueberschritten.objectIds.push(objectRef);
                                }
                            }
                        });
                    }
                }
                
                console.log("Matched object IDs:", {
                    erfuellt: categoryData.erfuellt.objectIds.length,
                    unterschritten: categoryData.unterschritten.objectIds.length,
                    ueberschritten: categoryData.ueberschritten.objectIds.length
                });
                
            } catch (error) {
                console.error("Error finding matching objects:", error);
            }
        }
        
        function extractLongName(obj) {
            // Try different ways to extract LongName from object properties
            // Based on Trimble Connect API documentation, properties can be in various formats
            
            // Direct property (various casing)
            if (obj.longName) return obj.longName;
            if (obj.LongName) return obj.LongName;
            if (obj['Long Name']) return obj['Long Name'];
            
            // Standard IFC property format: IfcSpace.LongName
            if (obj['IfcSpace.LongName']) return obj['IfcSpace.LongName'];
            if (obj['Pset_SpaceCommon.LongName']) return obj['Pset_SpaceCommon.LongName'];
            
            // From properties array (PropertySet format from Trimble API)
            // Structure: obj.properties = [{name: "IFC Space", properties: [{name: "Long Name", value: "..."}]}]
            if (obj.properties && Array.isArray(obj.properties)) {
                // Helper function to find Long Name in a properties array
                const findLongNameInProps = (propsArray) => {
                    if (!propsArray || !Array.isArray(propsArray)) return null;
                    const longNameProp = propsArray.find(p => {
                        const propName = (p.name || p.Name || '').toLowerCase();
                        return propName === 'long name' || propName === 'longname' || propName === 'long_name';
                    });
                    return longNameProp ? (longNameProp.value || longNameProp.Value) : null;
                };
                
                // First, look for specific IFC Space property sets
                for (const pset of obj.properties) {
                    const psetName = (pset.name || pset.Name || '').toLowerCase();
                    
                    // Check in "IFC Space", "Ifc Space", "IfcSpace" or Pset_SpaceCommon
                    // These are the standard IFC property set names for space properties
                    if ((psetName.includes('ifc') && psetName.includes('space')) || 
                        psetName.includes('pset_spacecommon')) {
                        const value = findLongNameInProps(pset.properties);
                        if (value) return value;
                    }
                }
                
                // Also check any property set for Long Name (fallback)
                for (const pset of obj.properties) {
                    const value = findLongNameInProps(pset.properties);
                    if (value) return value;
                    
                    // Handle flat properties array format
                    if (typeof pset === 'object' && pset.name) {
                        const propName = (pset.name || '').toLowerCase();
                        if (propName === 'long name' || propName === 'longname' || propName === 'long_name') {
                            return pset.value || pset.Value;
                        }
                    }
                }
            }
            
            // From nested attributes
            if (obj.attributes) {
                if (obj.attributes.longName) return obj.attributes.longName;
                if (obj.attributes.LongName) return obj.attributes.LongName;
                if (obj.attributes['Long Name']) return obj.attributes['Long Name'];
            }
            
            // From name property (sometimes Long Name is stored as name)
            // Only use if it looks like a room type name (not a GUID or generic name)
            if (obj.name && typeof obj.name === 'string' && !UUID_PATTERN.test(obj.name)) {
                // Don't return generic names like "Space" or IFC class names
                const name = obj.name;
                if (!name.toLowerCase().startsWith('ifc') && name.length > 2) {
                    // This might be the Long Name
                    return name;
                }
            }
            
            return null;
        }
        
        // ====================================================================
        // COLOR MANAGEMENT
        // ====================================================================
        
        async function applyAllColors() {
            if (!viewerAPI) {
                console.warn("Viewer API not available for color application");
                return;
            }
            
            try {
                // Apply colors for each category if enabled
                const colorErfuellt = document.getElementById('colorErfuellt').checked;
                const colorUnterschritten = document.getElementById('colorUnterschritten').checked;
                const colorUeberschritten = document.getElementById('colorUeberschritten').checked;
                
                if (colorErfuellt) {
                    await applyColorToCategory('erfuellt');
                }
                if (colorUnterschritten) {
                    await applyColorToCategory('unterschritten');
                }
                if (colorUeberschritten) {
                    await applyColorToCategory('ueberschritten');
                }
                
                console.log("All colors applied");
                
            } catch (error) {
                console.error("Error applying colors:", error);
            }
        }
        
        async function applyColorToCategory(category) {
            const data = categoryData[category];
            
            if (!data.objectIds || data.objectIds.length === 0) {
                console.log(`No objects to color for category: ${category}`);
                return;
            }
            
            console.log(`Applying color ${data.color} to ${data.objectIds.length} objects in ${category}`);
            
            try {
                // Use API.viewer.setObjectState which is the documented Trimble Connect API method
                // Format: setObjectState(objects, state) where state includes {color: '#RRGGBB'}
                if (API && API.viewer && typeof API.viewer.setObjectState === 'function') {
                    // Object IDs are stored as {modelId, objectRuntimeId}
                    const objectStates = data.objectIds.map(objRef => ({
                        modelId: objRef.modelId,
                        objectRuntimeId: objRef.objectRuntimeId,
                        state: { color: data.color }
                    }));
                    
                    await API.viewer.setObjectState(objectStates);
                    console.log(`Applied color ${data.color} to ${data.objectIds.length} objects in ${category} using setObjectState`);
                } else if (typeof viewerAPI.setObjectsColor === 'function') {
                    // Fallback: Try direct setObjectsColor method
                    const ids = data.objectIds.map(ref => ref.objectRuntimeId || ref);
                    await viewerAPI.setObjectsColor(ids, data.color);
                    console.log(`Applied color ${data.color} to ${data.objectIds.length} objects in ${category} using setObjectsColor`);
                } else if (viewerAPI.objects && typeof viewerAPI.objects.setColor === 'function') {
                    // Fallback: Try objects.setColor
                    const ids = data.objectIds.map(ref => ref.objectRuntimeId || ref);
                    await viewerAPI.objects.setColor(ids, data.color);
                    console.log(`Applied color ${data.color} to ${data.objectIds.length} objects in ${category}`);
                } else {
                    console.warn("No color method available. Available API.viewer methods:", 
                        API && API.viewer ? Object.keys(API.viewer).filter(k => typeof API.viewer[k] === 'function') : 'none');
                }
            } catch (error) {
                console.error(`Error applying color to ${category}:`, error);
            }
        }
        
        async function removeColorFromCategory(category) {
            const data = categoryData[category];
            
            if (!data.objectIds || data.objectIds.length === 0) {
                return;
            }
            
            try {
                // Use setObjectState with color: 'reset' to remove colors
                if (API && API.viewer && typeof API.viewer.setObjectState === 'function') {
                    const objectStates = data.objectIds.map(objRef => ({
                        modelId: objRef.modelId,
                        objectRuntimeId: objRef.objectRuntimeId,
                        state: { color: 'reset' }
                    }));
                    
                    await API.viewer.setObjectState(objectStates);
                    console.log(`Reset colors for ${data.objectIds.length} objects in ${category} using setObjectState`);
                } else if (typeof viewerAPI.resetObjectsColor === 'function') {
                    const ids = data.objectIds.map(ref => ref.objectRuntimeId || ref);
                    await viewerAPI.resetObjectsColor(ids);
                    console.log(`Reset colors for ${data.objectIds.length} objects in ${category}`);
                } else if (viewerAPI.objects && typeof viewerAPI.objects.resetColor === 'function') {
                    const ids = data.objectIds.map(ref => ref.objectRuntimeId || ref);
                    await viewerAPI.objects.resetColor(ids);
                } else {
                    console.warn("No reset color method available");
                }
            } catch (error) {
                console.error(`Error resetting color for ${category}:`, error);
            }
        }
        
        async function toggleColor(category) {
            const checkboxId = 'color' + category.charAt(0).toUpperCase() + category.slice(1);
            const isEnabled = document.getElementById(checkboxId).checked;
            
            if (isEnabled) {
                await applyColorToCategory(category);
            } else {
                await removeColorFromCategory(category);
            }
        }
        
        async function resetAllColors() {
            if (!API || !API.viewer) {
                console.warn("API.viewer not available");
                return;
            }
            
            try {
                // Collect all object IDs
                const allObjectIds = [
                    ...categoryData.erfuellt.objectIds,
                    ...categoryData.unterschritten.objectIds,
                    ...categoryData.ueberschritten.objectIds
                ];
                
                if (allObjectIds.length > 0) {
                    // Use setObjectState with color: 'reset'
                    if (typeof API.viewer.setObjectState === 'function') {
                        const objectStates = allObjectIds.map(objRef => ({
                            modelId: objRef.modelId,
                            objectRuntimeId: objRef.objectRuntimeId,
                            state: { color: 'reset' }
                        }));
                        
                        await API.viewer.setObjectState(objectStates);
                        console.log(`Reset colors for ${allObjectIds.length} objects using setObjectState`);
                    } else if (typeof viewerAPI.resetObjectsColor === 'function') {
                        const ids = allObjectIds.map(ref => ref.objectRuntimeId || ref);
                        await viewerAPI.resetObjectsColor(ids);
                    } else if (typeof API.viewer.reset === 'function') {
                        await API.viewer.reset();
                    }
                }
                
                // Uncheck all color checkboxes
                document.getElementById('colorErfuellt').checked = false;
                document.getElementById('colorUnterschritten').checked = false;
                document.getElementById('colorUeberschritten').checked = false;
                
                console.log("All colors reset");
                
            } catch (error) {
                console.error("Error resetting colors:", error);
            }
        }
        
        // ====================================================================
        // VISIBILITY MANAGEMENT
        // ====================================================================
        
        async function toggleVisibility(category) {
            const checkboxId = 'visibility' + category.charAt(0).toUpperCase() + category.slice(1);
            const isVisible = document.getElementById(checkboxId).checked;
            const data = categoryData[category];
            
            if (!data.objectIds || data.objectIds.length === 0) {
                return;
            }
            
            try {
                // Use setObjectState with visible property
                if (API && API.viewer && typeof API.viewer.setObjectState === 'function') {
                    const objectStates = data.objectIds.map(objRef => ({
                        modelId: objRef.modelId,
                        objectRuntimeId: objRef.objectRuntimeId,
                        state: { visible: isVisible }
                    }));
                    
                    await API.viewer.setObjectState(objectStates);
                    console.log(`${isVisible ? 'Showing' : 'Hiding'} ${data.objectIds.length} objects in ${category} using setObjectState`);
                } else if (isVisible) {
                    // Fallback: Show objects
                    if (typeof viewerAPI.showObjects === 'function') {
                        const ids = data.objectIds.map(ref => ref.objectRuntimeId || ref);
                        await viewerAPI.showObjects(ids);
                        console.log(`Showing ${data.objectIds.length} objects in ${category}`);
                    } else if (viewerAPI.objects && typeof viewerAPI.objects.show === 'function') {
                        const ids = data.objectIds.map(ref => ref.objectRuntimeId || ref);
                        await viewerAPI.objects.show(ids);
                    }
                } else {
                    // Fallback: Hide objects
                    if (typeof viewerAPI.hideObjects === 'function') {
                        const ids = data.objectIds.map(ref => ref.objectRuntimeId || ref);
                        await viewerAPI.hideObjects(ids);
                        console.log(`Hiding ${data.objectIds.length} objects in ${category}`);
                    } else if (viewerAPI.objects && typeof viewerAPI.objects.hide === 'function') {
                        const ids = data.objectIds.map(ref => ref.objectRuntimeId || ref);
                        await viewerAPI.objects.hide(ids);
                    }
                }
            } catch (error) {
                console.error(`Error toggling visibility for ${category}:`, error);
            }
        }
        
        // ====================================================================
        // UTILITY FUNCTIONS
        // ====================================================================
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ====================================================================
        // INITIALIZE ON LOAD
        // ====================================================================
        
        init();
    </script>
</body>
</html>
