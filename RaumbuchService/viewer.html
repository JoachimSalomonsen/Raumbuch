<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Raumbuch 3D Viewer Extension</title>
    <link rel="stylesheet" href="Content/Site.css">
    <!-- Trimble Workspace API -->
    <script src="https://components.connect.trimble.com/trimble-connect-workspace-api/index.js"></script>
    <style>
        /* Additional styles for 3D Viewer extension */
        .viewer-container {
            padding: 15px;
        }
        
        .category-section {
            background: var(--tc-bg-card);
            border: 1px solid var(--tc-border);
            border-radius: 6px;
            padding: 16px;
            margin-bottom: 12px;
        }
        
        .category-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }
        
        .category-color {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        
        .color-green { background-color: #2E8540; }
        .color-yellow { background-color: #FFBF47; }
        .color-red { background-color: #D64545; }
        
        .category-title {
            font-weight: 600;
            color: var(--tc-text-primary);
            flex: 1;
        }
        
        .category-count {
            font-size: 0.85em;
            color: var(--tc-text-muted);
            padding: 2px 8px;
            background: var(--tc-bg-neutral);
            border-radius: 10px;
        }
        
        .toggle-controls {
            display: flex;
            gap: 16px;
            margin-top: 8px;
        }
        
        .toggle-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.9em;
            color: var(--tc-text-secondary);
        }
        
        .toggle-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            accent-color: var(--tc-primary-blue);
            cursor: pointer;
        }
        
        .toggle-item label {
            cursor: pointer;
            font-weight: 400;
            margin: 0;
        }
        
        .file-input-section {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .file-input-section .form-group {
            flex: 1;
            min-width: 200px;
        }
        
        #jsonFileInput {
            max-width: none;
            width: 100%;
        }
        
        .room-list {
            margin-top: 8px;
            max-height: 100px;
            overflow-y: auto;
            font-size: 0.85em;
            color: var(--tc-text-muted);
            padding: 8px;
            background: var(--tc-bg-neutral);
            border-radius: 4px;
        }
        
        .room-list-item {
            padding: 2px 0;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        
        .status-connected { background-color: #2E8540; }
        .status-disconnected { background-color: #D64545; }
        .status-connecting { background-color: #FFBF47; }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 16px;
            background: var(--tc-bg-neutral);
            border-radius: 4px;
            margin-bottom: 16px;
            font-size: 0.9em;
        }
        
        .btn-reset {
            background-color: var(--tc-text-muted);
            color: white;
        }
        
        .btn-reset:hover {
            background-color: #6a6e72;
        }
        
        .expand-toggle {
            cursor: pointer;
            font-size: 0.85em;
            color: var(--tc-primary-blue);
            display: inline-block;
            margin-top: 4px;
            background: none;
            border: none;
            padding: 4px 0;
            font-family: inherit;
        }
        
        .expand-toggle:hover {
            text-decoration: underline;
        }
        
        .expand-toggle:focus {
            outline: 2px solid var(--tc-primary-blue);
            outline-offset: 2px;
        }
        
        .room-list.collapsed {
            display: none;
        }
        
        /* KPI Overview - Row-based layout for narrow panel */
        .kpi-overview {
            background: linear-gradient(135deg, var(--tc-dark-blue) 0%, var(--tc-primary-blue) 100%);
            color: white;
        }
        
        .kpi-overview h2 {
            color: white;
            margin-bottom: 12px;
        }
        
        .kpi-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255,255,255,0.1);
            border-radius: 4px;
            margin-bottom: 6px;
        }
        
        .kpi-row:last-child {
            margin-bottom: 0;
        }
        
        .kpi-row-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
        
        .kpi-row-value {
            font-size: 1.1em;
            font-weight: bold;
        }
        
        .kpi-row-ok {
            border-left: 3px solid #2E8540;
        }
        
        .kpi-row-under {
            border-left: 3px solid #D64545;
        }
        
        .kpi-row-over {
            border-left: 3px solid #FFBF47;
        }
    </style>
</head>
<body>
    <div class="viewer-container">
        <!-- Connection Status -->
        <div class="connection-status" id="connectionStatus">
            <span class="status-indicator status-connecting" id="statusIndicator"></span>
            <span id="statusText">Verbinde mit 3D Viewer...</span>
        </div>

        <!-- Configuration Selection Section -->
        <section class="card">
            <h2>üìÅ Raumbuch Konfiguration laden</h2>
            <p>W√§hlen Sie eine gespeicherte Konfiguration aus Azure Storage.</p>
            
            <div class="file-input-section">
                <div class="form-group">
                    <label for="savedConfigs">Gespeicherte Konfigurationen:</label>
                    <select id="savedConfigs" class="form-control" style="max-width: none; width: 100%;">
                        <option value="">-- Verbinde mit Trimble Connect... --</option>
                    </select>
                </div>
                <button class="btn btn-primary" id="loadBtn" onclick="loadConfiguration()">üì• Laden</button>
                <button class="btn btn-secondary" id="refreshBtn" onclick="loadSavedConfigurations()">üîÑ Aktualisieren</button>
            </div>
            
            <div id="loadResult" class="result"></div>
        </section>

        <!-- KPI Overview Widget (row-based for narrow panel) -->
        <section class="card kpi-overview" id="kpiSection" style="display: none;">
            <h2>üìä √úbersicht</h2>
            <div class="kpi-row">
                <span class="kpi-row-label">SOLL Gesamt</span>
                <span class="kpi-row-value" id="kpiSollTotal">- m¬≤</span>
            </div>
            <div class="kpi-row">
                <span class="kpi-row-label">IST Gesamt</span>
                <span class="kpi-row-value" id="kpiIstTotal">- m¬≤</span>
            </div>
            <div class="kpi-row">
                <span class="kpi-row-label">Abweichung</span>
                <span class="kpi-row-value" id="kpiDeviation">- %</span>
            </div>
            <div class="kpi-row kpi-row-ok">
                <span class="kpi-row-label">‚úÖ Erf√ºllt</span>
                <span class="kpi-row-value" id="kpiOkCount">0</span>
            </div>
            <div class="kpi-row kpi-row-under">
                <span class="kpi-row-label">‚ö†Ô∏è Unterschritten</span>
                <span class="kpi-row-value" id="kpiUnderCount">0</span>
            </div>
            <div class="kpi-row kpi-row-over">
                <span class="kpi-row-label">üìä √úberschritten</span>
                <span class="kpi-row-value" id="kpiOverCount">0</span>
            </div>
        </section>

        <!-- Category Sections -->
        <section class="card" id="categoriesSection" style="display: none;">
            <h2>üé® Raumkategorien</h2>
            <p>Steuern Sie Farben und Sichtbarkeit der IfcSpace-Objekte nach Kategorie.</p>
            
            <!-- Erf√ºllt (Green) -->
            <div class="category-section" id="categoryErfuellt">
                <div class="category-header">
                    <div class="category-color color-green"></div>
                    <span class="category-title">‚úÖ Erf√ºllt</span>
                    <span class="category-count" id="countErfuellt">0 R√§ume</span>
                </div>
                <div class="toggle-controls">
                    <div class="toggle-item">
                        <input type="checkbox" id="colorErfuellt" checked onchange="toggleColor('erfuellt')">
                        <label for="colorErfuellt">Farbe anzeigen</label>
                    </div>
                    <div class="toggle-item">
                        <input type="checkbox" id="visibilityErfuellt" checked onchange="toggleVisibility('erfuellt')">
                        <label for="visibilityErfuellt">Sichtbar</label>
                    </div>
                </div>
                <button type="button" class="expand-toggle" aria-expanded="false" aria-controls="roomListErfuellt" onclick="toggleRoomList('erfuellt')">‚ñ∂ R√§ume anzeigen</button>
                <div class="room-list collapsed" id="roomListErfuellt" role="region">
                    <!-- Room list will be populated dynamically -->
                </div>
            </div>

            <!-- Unterschritten (Yellow) -->
            <div class="category-section" id="categoryUnterschritten">
                <div class="category-header">
                    <div class="category-color color-yellow"></div>
                    <span class="category-title">‚ö†Ô∏è Unterschritten</span>
                    <span class="category-count" id="countUnterschritten">0 R√§ume</span>
                </div>
                <div class="toggle-controls">
                    <div class="toggle-item">
                        <input type="checkbox" id="colorUnterschritten" checked onchange="toggleColor('unterschritten')">
                        <label for="colorUnterschritten">Farbe anzeigen</label>
                    </div>
                    <div class="toggle-item">
                        <input type="checkbox" id="visibilityUnterschritten" checked onchange="toggleVisibility('unterschritten')">
                        <label for="visibilityUnterschritten">Sichtbar</label>
                    </div>
                </div>
                <button type="button" class="expand-toggle" aria-expanded="false" aria-controls="roomListUnterschritten" onclick="toggleRoomList('unterschritten')">‚ñ∂ R√§ume anzeigen</button>
                <div class="room-list collapsed" id="roomListUnterschritten" role="region">
                    <!-- Room list will be populated dynamically -->
                </div>
            </div>

            <!-- √úberschritten (Red) -->
            <div class="category-section" id="categoryUeberschritten">
                <div class="category-header">
                    <div class="category-color color-red"></div>
                    <span class="category-title">üî¥ √úberschritten</span>
                    <span class="category-count" id="countUeberschritten">0 R√§ume</span>
                </div>
                <div class="toggle-controls">
                    <div class="toggle-item">
                        <input type="checkbox" id="colorUeberschritten" checked onchange="toggleColor('ueberschritten')">
                        <label for="colorUeberschritten">Farbe anzeigen</label>
                    </div>
                    <div class="toggle-item">
                        <input type="checkbox" id="visibilityUeberschritten" checked onchange="toggleVisibility('ueberschritten')">
                        <label for="visibilityUeberschritten">Sichtbar</label>
                    </div>
                </div>
                <button type="button" class="expand-toggle" aria-expanded="false" aria-controls="roomListUeberschritten" onclick="toggleRoomList('ueberschritten')">‚ñ∂ R√§ume anzeigen</button>
                <div class="room-list collapsed" id="roomListUeberschritten" role="region">
                    <!-- Room list will be populated dynamically -->
                </div>
            </div>

            <!-- Reset Button -->
            <div style="margin-top: 16px;">
                <button class="btn btn-reset" onclick="resetAllColors()">üîÑ Alle Farben zur√ºcksetzen</button>
            </div>
        </section>

        <footer>
            <p>Raumbuch 3D Viewer Extension v1.0 - Buildingpoint Schweiz AG</p>
        </footer>
    </div>

    <script>
        // ====================================================================
        // TRIMBLE CONNECT 3D VIEWER EXTENSION
        // ====================================================================
        
        // API endpoints
        const API_PROJECT = '/api/project';
        const API_RAUMBUCH = '/api/raumbuch';
        
        // Configuration constants
        // BATCH_SIZE: Number of object IDs to process per batch when calling getObjectProperties
        const BATCH_SIZE = 1000;
        // UUID_PATTERN: Matches standard UUIDs with or without hyphens
        const UUID_PATTERN = /^[0-9a-f]{8}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{4}-?[0-9a-f]{12}$/i;
        // TARGET_PSETS: Property set names to search for LongName (in order of priority)
        const TARGET_PSETS = ['pset_spacecommon', 'attributes', 'ifcspace', 'ifc space'];
        
        // API reference and state
        let API = null;
        let viewerAPI = null;
        let isConnected = false;
        let workspaceToken = null;
        let workspaceProjectId = null;
        let currentConfig = null;
        
        // Category data structure
        let categoryData = {
            erfuellt: { rooms: [], objectIds: [], color: '#2E8540' },
            unterschritten: { rooms: [], objectIds: [], color: '#FFBF47' },
            ueberschritten: { rooms: [], objectIds: [], color: '#D64545' }
        };
        
        // All IfcSpace objects from the model
        let allIfcSpaces = [];
        
        // ====================================================================
        // INITIALIZATION
        // ====================================================================
        
        /**
         * Helper function to set connected state and update UI
         */
        function setConnectedState(status, message) {
            isConnected = (status === 'connected');
            updateConnectionStatus(status, message);
        }
        
        async function init() {
            console.log("Initializing Raumbuch 3D Viewer Extension...");
            setConnectedState('connecting', 'Verbinde mit 3D Viewer...');
            
            try {
                // Connect to Trimble Workspace API
                API = await window.TrimbleConnectWorkspace.connect(
                    window.parent,
                    eventHandler,
                    30000
                );
                
                console.log("Connected to Workspace API:", API);
                
                // Get access token and project info
                try {
                    workspaceToken = await API.extension.requestPermission("accesstoken");
                    console.log("Access token received from Workspace API");
                    
                    const project = await API.project.getCurrentProject();
                    console.log("Current project:", project);
                    
                    if (project && project.id) {
                        workspaceProjectId = project.id;
                        console.log("Project ID from Workspace API:", workspaceProjectId);
                    }
                } catch (tokenError) {
                    console.warn("Could not get token/project:", tokenError);
                }
                
                // Initialize 3D Viewer
                if (API && API.embed && typeof API.embed.init3DViewer === 'function') {
                    viewerAPI = await API.embed.init3DViewer({});
                    console.log("3D Viewer initialized:", viewerAPI);
                    setConnectedState('connected', 'Verbunden mit 3D Viewer');
                    await loadIfcSpaces();
                } else if (API && API.viewer) {
                    // Alternative: viewer might be directly available
                    viewerAPI = API.viewer;
                    console.log("Viewer API obtained directly:", viewerAPI);
                    setConnectedState('connected', 'Verbunden mit 3D Viewer');
                    await loadIfcSpaces();
                } else {
                    console.warn("embed.init3DViewer not available, trying alternative methods...");
                    // Try to use the viewer API directly if available
                    viewerAPI = API;
                    setConnectedState('connected', 'Verbunden (eingeschr√§nkter Modus)');
                }
                
                // Load saved configurations from Azure
                if (workspaceProjectId) {
                    await loadSavedConfigurations();
                }
                
            } catch (error) {
                console.error("Error initializing extension:", error);
                setConnectedState('disconnected', 'Fehler: ' + error.message);
            }
        }
        
        function eventHandler(event, args) {
            console.log("Workspace event:", event, args);
            
            if (event === "extension.command") {
                handleCommand(args.data);
            }
            if (event === "extension.accessToken") {
                console.log("Access token event received");
                workspaceToken = args.data;
            }
            if (event === "viewer.selectionChanged") {
                console.log("Selection changed:", args);
            }
        }
        
        function handleCommand(command) {
            console.log("Command received:", command);
        }
        
        // ====================================================================
        // CONNECTION STATUS
        // ====================================================================
        
        function updateConnectionStatus(status, message) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            indicator.className = 'status-indicator';
            
            switch(status) {
                case 'connected':
                    indicator.classList.add('status-connected');
                    break;
                case 'disconnected':
                    indicator.classList.add('status-disconnected');
                    break;
                case 'connecting':
                    indicator.classList.add('status-connecting');
                    break;
            }
            
            text.textContent = message;
        }
        
        // ====================================================================
        // LOAD IFC SPACES
        // ====================================================================
        
        async function loadIfcSpaces() {
            try {
                console.log("Loading IfcSpace objects...");
                
                // Get all objects from the viewer
                if (viewerAPI && typeof viewerAPI.getObjects === 'function') {
                    const allObjects = await viewerAPI.getObjects();
                    console.log("All objects loaded:", allObjects?.length || 0);
                    
                    // Filter for IfcSpace objects
                    if (allObjects && Array.isArray(allObjects)) {
                        allIfcSpaces = allObjects.filter(obj => 
                            obj.class === 'IfcSpace' || 
                            obj.type === 'IfcSpace' ||
                            (obj.className && obj.className.includes('IfcSpace'))
                        );
                        console.log("IfcSpace objects found:", allIfcSpaces.length);
                    }
                } else if (viewerAPI && typeof viewerAPI.objects === 'object') {
                    // Alternative method using objects property
                    const objectsResult = await viewerAPI.objects.getAll();
                    if (objectsResult && Array.isArray(objectsResult)) {
                        allIfcSpaces = objectsResult.filter(obj => 
                            obj.class === 'IfcSpace' || obj.type === 'IfcSpace'
                        );
                    }
                }
                
                console.log("IfcSpace objects loaded:", allIfcSpaces.length);
                
            } catch (error) {
                console.error("Error loading IfcSpace objects:", error);
            }
        }
        
        // ====================================================================
        // AZURE CONFIGURATION LOADING
        // ====================================================================
        
        function showResult(elementId, type, message) {
            const el = document.getElementById(elementId);
            el.className = `result ${type}`;
            el.innerHTML = message;
        }
        
        /**
         * Loads saved configurations from Azure Storage
         */
        async function loadSavedConfigurations() {
            try {
                console.log('Loading saved configurations for project:', workspaceProjectId);
                
                const response = await fetch(`${API_PROJECT}/config/list`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ projectId: workspaceProjectId })
                });

                if (!response.ok) {
                    console.warn('Failed to load configurations:', response.status);
                    return;
                }

                const data = await response.json();
                const configSelect = document.getElementById('savedConfigs');
                configSelect.innerHTML = '<option value="">-- Konfiguration ausw√§hlen --</option>';

                if (data.success && data.configurations && data.configurations.length > 0) {
                    data.configurations.forEach(config => {
                        const option = document.createElement('option');
                        option.value = config.name;
                        const dateStr = config.lastModified ? new Date(config.lastModified).toLocaleDateString('de-DE') : '';
                        option.textContent = `${config.name} ${dateStr ? '(' + dateStr + ')' : ''}`;
                        configSelect.appendChild(option);
                    });
                    console.log(`Loaded ${data.configurations.length} saved configurations`);
                } else {
                    configSelect.innerHTML = '<option value="">-- Keine gespeicherten Konfigurationen --</option>';
                }
            } catch (error) {
                console.error('Error loading saved configurations:', error);
                const configSelect = document.getElementById('savedConfigs');
                configSelect.innerHTML = '<option value="">-- Fehler beim Laden --</option>';
            }
        }
        
        /**
         * Loads configuration from Azure and applies viewer data
         */
        async function loadConfiguration() {
            const configName = document.getElementById('savedConfigs').value;
            
            if (!configName) {
                showResult('loadResult', 'error', '‚ö†Ô∏è Bitte w√§hlen Sie eine Konfiguration aus.');
                return;
            }
            
            if (!workspaceProjectId) {
                showResult('loadResult', 'error', '‚ö†Ô∏è Project ID nicht gefunden. Bitte Seite neu laden.');
                return;
            }
            
            showResult('loadResult', 'loading', '‚è≥ Lade Konfiguration aus Azure...');
            
            try {
                // Load configuration from Azure
                const response = await fetch(`${API_PROJECT}/config/load`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        projectId: workspaceProjectId,
                        configName: configName
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText || 'Verbindungsfehler'}`);
                }

                const data = await response.json();

                if (!data.success || !data.configuration) {
                    throw new Error(data.message || 'Fehler beim Laden');
                }
                
                currentConfig = data.configuration;
                console.log("Loaded configuration:", currentConfig);
                
                // Check if we have viewer data in the config
                if (currentConfig.viewerData) {
                    // Use pre-saved viewer data
                    processViewerData(currentConfig.viewerData);
                } else if (currentConfig.files && currentConfig.files.raumbuch && (currentConfig.files.raumbuch.id || currentConfig.files.raumbuch) && workspaceToken) {
                    // Load viewer data from Raumbuch file
                    await loadViewerDataFromRaumbuch(currentConfig);
                } else {
                    // Try to use zusammenfassung data if available
                    if (currentConfig.zusammenfassung && currentConfig.zusammenfassung.length > 0) {
                        processZusammenfassungData(currentConfig.zusammenfassung, currentConfig.toleranceMin || -10, currentConfig.toleranceMax || 10);
                    } else {
                        showResult('loadResult', 'error', '‚ö†Ô∏è Keine Raumbuch-Daten in der Konfiguration gefunden.');
                        return;
                    }
                }
                
                // Update KPI widget with zusammenfassung data
                if (currentConfig.zusammenfassung && currentConfig.zusammenfassung.length > 0) {
                    updateKPIWidget(currentConfig.zusammenfassung, currentConfig.toleranceMin || -10, currentConfig.toleranceMax || 10);
                }
                
                // Show categories section
                document.getElementById('categoriesSection').style.display = 'block';
                
                // Apply colors to 3D viewer
                await applyAllColors();
                
                showResult('loadResult', 'success', 
                    `‚úÖ Konfiguration geladen!<br>` +
                    `Erf√ºllt: ${categoryData.erfuellt.rooms.length} Raumtypen<br>` +
                    `Unterschritten: ${categoryData.unterschritten.rooms.length} Raumtypen<br>` +
                    `√úberschritten: ${categoryData.ueberschritten.rooms.length} Raumtypen`
                );
                
            } catch (error) {
                console.error("Error loading configuration:", error);
                showResult('loadResult', 'error', '‚ùå Fehler beim Laden: ' + error.message);
            }
        }
        
        /**
         * Loads viewer data from Raumbuch file via API
         */
        async function loadViewerDataFromRaumbuch(config) {
            // config.files.raumbuch is an object with id and name properties
            const raumbuchFile = config.files?.raumbuch;
            const raumbuchFileId = raumbuchFile?.id || raumbuchFile;
            
            // Refresh token before making API call to avoid INVALID_SESSION errors
            try {
                if (API && API.extension && typeof API.extension.requestPermission === 'function') {
                    console.log('Refreshing access token...');
                    workspaceToken = await API.extension.requestPermission("accesstoken");
                    console.log('Access token refreshed');
                }
            } catch (tokenError) {
                console.warn('Could not refresh token:', tokenError);
            }
            
            if (!raumbuchFileId || !workspaceToken) {
                throw new Error('Raumbuch-Datei ID oder Token fehlt');
            }
            
            console.log('Loading viewer data for Raumbuch file:', raumbuchFileId);
            
            const response = await fetch(`${API_RAUMBUCH}/get-viewer-data`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    accessToken: workspaceToken,
                    raumbuchFileId: raumbuchFileId,
                    toleranceMin: config.toleranceMin || -10,
                    toleranceMax: config.toleranceMax || 10
                })
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('API error response:', errorText);
                throw new Error(`Fehler beim Laden der Viewer-Daten: HTTP ${response.status} ${response.statusText || ''}`);
            }
            
            const data = await response.json();
            
            if (!data.success) {
                throw new Error(data.message || 'Fehler beim Laden der Viewer-Daten');
            }
            
            processViewerData(data);
        }
        
        /**
         * Processes viewer data from API (Raumtyp values that match IfcSpace.LongName)
         */
        function processViewerData(data) {
            // Reset category data
            categoryData = {
                erfuellt: { rooms: [], objectIds: [], color: '#2E8540' },
                unterschritten: { rooms: [], objectIds: [], color: '#FFBF47' },
                ueberschritten: { rooms: [], objectIds: [], color: '#D64545' }
            };
            
            // Process viewer data (Raumtyp values that match IfcSpace.LongName)
            categoryData.erfuellt.rooms = data.Erfuellt || data.erfuellt || [];
            categoryData.unterschritten.rooms = data.Unterschritten || data.unterschritten || [];
            categoryData.ueberschritten.rooms = data.Ueberschritten || data.ueberschritten || [];
            
            // Update UI counts
            updateCategoryCounts();
            
            // Find matching object IDs
            findMatchingObjects();
        }
        
        /**
         * Processes zusammenfassung data to extract Raumtyp values by status
         */
        function processZusammenfassungData(zusammenfassung, toleranceMin, toleranceMax) {
            // Reset category data
            categoryData = {
                erfuellt: { rooms: [], objectIds: [], color: '#2E8540' },
                unterschritten: { rooms: [], objectIds: [], color: '#FFBF47' },
                ueberschritten: { rooms: [], objectIds: [], color: '#D64545' }
            };
            
            zusammenfassung.forEach(item => {
                const raumtyp = item.roomCategory || item.RoomCategory;
                const percentage = item.percentage || item.Percentage || 100;
                
                if (!raumtyp) return;
                
                const deviation = percentage - 100;
                
                if (deviation < toleranceMin) {
                    categoryData.unterschritten.rooms.push(raumtyp);
                } else if (deviation > toleranceMax) {
                    categoryData.ueberschritten.rooms.push(raumtyp);
                } else {
                    categoryData.erfuellt.rooms.push(raumtyp);
                }
            });
            
            // Update UI counts
            updateCategoryCounts();
            
            // Find matching object IDs
            findMatchingObjects();
            
            // Update KPI widget with zusammenfassung data
            if (currentConfig && currentConfig.zusammenfassung) {
                updateKPIWidget(currentConfig.zusammenfassung, toleranceMin, toleranceMax);
            }
        }
        
        /**
         * Updates KPI widget with summary data (row-based layout)
         */
        function updateKPIWidget(zusammenfassung, toleranceMin, toleranceMax) {
            if (!zusammenfassung || zusammenfassung.length === 0) return;

            let totalSoll = 0;
            let totalIst = 0;
            let okCount = 0;
            let underCount = 0;
            let overCount = 0;

            zusammenfassung.forEach(item => {
                const soll = item.sollArea || item.SollArea || 0;
                const ist = item.istArea || item.IstArea || 0;
                const percentage = item.percentage || item.Percentage || 100;
                
                totalSoll += soll;
                totalIst += ist;
                
                const deviation = percentage - 100;
                if (deviation < toleranceMin) underCount++;
                else if (deviation > toleranceMax) overCount++;
                else okCount++;
            });

            const deviation = totalSoll > 0 ? ((totalIst / totalSoll) * 100 - 100).toFixed(1) : 0;

            document.getElementById('kpiSollTotal').textContent = totalSoll.toFixed(2) + ' m¬≤';
            document.getElementById('kpiIstTotal').textContent = totalIst.toFixed(2) + ' m¬≤';
            document.getElementById('kpiDeviation').textContent = (deviation >= 0 ? '+' : '') + deviation + '%';
            document.getElementById('kpiOkCount').textContent = okCount;
            document.getElementById('kpiUnderCount').textContent = underCount;
            document.getElementById('kpiOverCount').textContent = overCount;

            // Color the deviation based on value
            const deviationEl = document.getElementById('kpiDeviation');
            if (deviation < toleranceMin) {
                deviationEl.style.color = '#ffcccc';
            } else if (deviation > toleranceMax) {
                deviationEl.style.color = '#ffffcc';
            } else {
                deviationEl.style.color = '#ccffcc';
            }
            
            // Show KPI section
            document.getElementById('kpiSection').style.display = 'block';
        }
        
        function updateCategoryCounts() {
            document.getElementById('countErfuellt').textContent = 
                `${categoryData.erfuellt.rooms.length} R√§ume`;
            document.getElementById('countUnterschritten').textContent = 
                `${categoryData.unterschritten.rooms.length} R√§ume`;
            document.getElementById('countUeberschritten').textContent = 
                `${categoryData.ueberschritten.rooms.length} R√§ume`;
            
            // Update room lists
            updateRoomList('erfuellt', categoryData.erfuellt.rooms);
            updateRoomList('unterschritten', categoryData.unterschritten.rooms);
            updateRoomList('ueberschritten', categoryData.ueberschritten.rooms);
        }
        
        function updateRoomList(category, rooms) {
            const listId = 'roomList' + category.charAt(0).toUpperCase() + category.slice(1);
            const listEl = document.getElementById(listId);
            
            if (rooms.length === 0) {
                listEl.innerHTML = '<div class="room-list-item">Keine R√§ume in dieser Kategorie</div>';
            } else {
                listEl.innerHTML = rooms.map(room => 
                    `<div class="room-list-item">‚Ä¢ ${escapeHtml(room)}</div>`
                ).join('');
            }
        }
        
        function toggleRoomList(category) {
            const listId = 'roomList' + category.charAt(0).toUpperCase() + category.slice(1);
            const listEl = document.getElementById(listId);
            const toggleEl = listEl.previousElementSibling;
            
            const isExpanded = !listEl.classList.contains('collapsed');
            
            if (isExpanded) {
                listEl.classList.add('collapsed');
                toggleEl.textContent = '‚ñ∂ R√§ume anzeigen';
                toggleEl.setAttribute('aria-expanded', 'false');
            } else {
                listEl.classList.remove('collapsed');
                toggleEl.textContent = '‚ñº R√§ume ausblenden';
                toggleEl.setAttribute('aria-expanded', 'true');
            }
        }
        
        // ====================================================================
        // OBJECT MATCHING (OPPDATERT MED TRIMBLE API STRUKTUR)
        // ====================================================================

        /**
         * Finner og matcher IfcSpace-objekter basert p√• deres LongName-egenskap.
         * Bruker getEntities for √• finne IfcSpace-objekter og den bekreftede
         * {modelId: X, objectRuntimeIds: [Y]} strukturen for √• hente egenskaper i batches.
         * * Merk: BATCH_SIZE, TARGET_PSETS, categoryData, updateCategoryCounts, 
         * applyAllColors, og extractLongNameFromProperties antas √• v√¶re definert andre steder.
         */
        async function findMatchingObjects() {
            console.log("Finding matching objects...");

            // Reset object IDs
            categoryData.erfuellt.objectIds = [];
            categoryData.unterschritten.objectIds = [];
            categoryData.ueberschritten.objectIds = [];

            // Variabler for √• lagre den definitive konteksten for eiendomshenting
            let definitiveModelId = null;
            let definitiveVersionId = null;

            try {
                if (!viewerAPI) {
                    console.warn("viewerAPI not available");
                    return;
                }

                // --- Step 1: Get loaded models ---
                console.log("Getting loaded models...");
                const models = await viewerAPI.getModels();

                if (!models || models.length === 0) {
                    console.warn("No models loaded in viewer");
                    return;
                }

                // --- Step 2: Get IfcSpace entities and IDs ---
                const spaceIds = [];

                for (const model of models) {
                    const modelId = model.id || model.modelId || model;
                    console.log(`Getting IfcSpace entities from model: ${modelId}`);

                    try {
                        const entities = await viewerAPI.getEntities({
                            modelId: modelId,
                            class: "IfcSpace"
                        });

                        if (entities && entities.length > 0) {

                            // Extract IDs from entities - handle wrapper objects with entityForModel
                            for (const entity of entities) {
                                if (entity.entityForModel && Array.isArray(entity.entityForModel)) {
                                    console.log(`Entity has entityForModel with ${entity.entityForModel.length} items. Extracting IDs...`);

                                    // Capture the Model ID and Version ID from the entity wrapper
                                    if (!definitiveModelId) {
                                        definitiveModelId = entity.modelId || modelId;
                                        definitiveVersionId = entity.versionId || definitiveModelId;
                                        console.log(`Captured definitiveModelId: ${definitiveModelId}, definitiveVersionId: ${definitiveVersionId}`);
                                    }

                                    // Extract the primitive ID (objectRuntimeIds)
                                    for (const idObject of entity.entityForModel) {
                                        // Bruker den mest sannsynlige ID-n√∏kkelen basert p√• din onSelectionChanged logg
                                        const actualId = idObject.id || idObject.runtimeId || idObject.objectRuntimeId || idObject.objectId;

                                        if (actualId !== undefined && actualId !== null) {
                                            spaceIds.push(actualId);
                                        }
                                    }
                                } else {
                                    // Fallback for direkte ID
                                    const entityId = entity.id || entity.runtimeId || entity.objectId;
                                    if (entityId !== undefined && entityId !== null) {
                                        spaceIds.push(entityId);
                                    }
                                }
                            }
                        }
                    } catch (entityError) {
                        console.warn(`Error getting entities from model ${modelId}:`, entityError);
                    }
                }

                // Deduplicate and filter IDs
                const uniqueSpaceIds = [...new Set(spaceIds)].filter(id => id !== undefined && id !== null);
                console.log(`Total unique IfcSpace IDs found: ${uniqueSpaceIds.length}`);

                if (uniqueSpaceIds.length === 0) {
                    console.warn("No IfcSpace IDs found in any model");
                    updateCategoryCounts();
                    return;
                }

                if (!definitiveModelId) {
                    console.warn("Could not determine definitive Model ID for property fetching. Cannot proceed.");
                    updateCategoryCounts();
                    return;
                }

                // --- Step 3: Process IfcSpace IDs in batches to get properties ---
                for (let i = 0; i < uniqueSpaceIds.length; i += BATCH_SIZE) {
                    const batchIds = uniqueSpaceIds.slice(i, i + BATCH_SIZE);
                    const batchNumber = Math.floor(i / BATCH_SIZE) + 1;
                    const totalBatches = Math.ceil(uniqueSpaceIds.length / BATCH_SIZE);

                    console.log(`Processing batch ${batchNumber}/${totalBatches} (${batchIds.length} IfcSpace objects)`);

                    let propertiesResult = null;

                    // APPROACH 1: Bruk den bekreftede strukturen: {modelId: X, objectRuntimeIds: [Y]}
                    try {
                        console.log("Trying getObjectProperties with the confirmed structure {modelId: X, objectRuntimeIds: [Y]}...");

                        // Denne strukturen matcher utdata fra viewer.onSelectionChanged eventet.
                        const requestObject = [{
                            modelId: definitiveModelId,
                            objectRuntimeIds: batchIds // Arrayen med numeriske ID-er
                        }];

                        propertiesResult = await viewerAPI.getObjectProperties(requestObject);
                        console.log(`Approach 1 result: Returned ${propertiesResult ? propertiesResult.length : 0} objects`);
                    } catch (err) {
                        console.warn("Approach 1 (Confirmed Structure) failed:", err);
                    }

                    // FALLBACK 2: Pr√∏v den tidligere strukturen med ID/Model/Version hints (mindre sannsynlig √• lykkes)
                    if (!propertiesResult || propertiesResult.length === 0) {
                        console.log("Approach 1 failed. Trying fallback with explicit ID/Model/Version hints...");
                        try {
                            const fallbackRequestObjects = batchIds.map(id => ({
                                id: id,
                                modelId: definitiveModelId,
                                versionId: definitiveVersionId,
                                propertyNames: ["LongName", "IfcSpace.LongName"]
                            }));

                            propertiesResult = await viewerAPI.getObjectProperties(fallbackRequestObjects);
                            console.log(`Fallback 2 result: Returned ${propertiesResult ? propertiesResult.length : 0} objects`);
                        } catch (err) {
                            console.warn("Fallback 2 failed:", err);
                        }
                    }

                    if (!propertiesResult || propertiesResult.length === 0) {
                        console.log(`Batch ${batchNumber}: No properties returned from any approach`);
                        continue;
                    }

                    console.log(`Batch ${batchNumber}: Got properties for ${propertiesResult.length} objects`);

                    // Log first object structure for debugging
                    if (i === 0 && propertiesResult.length > 0) {
                        console.log("Sample IfcSpace properties structure (SUCCESS expected here):", propertiesResult[0]);
                    }

                    // --- Step 4 & 5: Process properties and match objects ---
                    for (const objProps of propertiesResult) {
                        const longName = extractLongNameFromProperties(objProps);

                        if (longName) {
                            const objectId = objProps.id || objProps.runtimeId || objProps.objectRuntimeId || objProps.objectId;

                            if (objectId === undefined || objectId === null) {
                                console.warn(`Found LongName "${longName}" but could not determine object ID`);
                                continue;
                            }

                            // Match against category data arrays
                            if (categoryData.erfuellt.rooms.includes(longName)) {
                                categoryData.erfuellt.objectIds.push(objectId);
                            }
                            if (categoryData.unterschritten.rooms.includes(longName)) {
                                categoryData.unterschritten.objectIds.push(objectId);
                            }
                            if (categoryData.ueberschritten.rooms.includes(longName)) {
                                categoryData.ueberschritten.objectIds.push(objectId);
                            }
                        }
                    }
                }

                console.log("Matching complete. Results:", {
                    erfuellt: categoryData.erfuellt.objectIds.length,
                    unterschritten: categoryData.unterschritten.objectIds.length,
                    ueberschritten: categoryData.ueberschritten.objectIds.length
                });

                // --- Step 6: Update UI counts and apply colors ---
                updateCategoryCounts();
                await applyAllColors();

            } catch (error) {
                console.error("Error finding matching objects:", error);
            }
        }

        /**
         * Extracts the LongName property from an object's properties.
         * (Antas √• v√¶re definert n√∏yaktig som i forrige svar)
         */
        function extractLongNameFromProperties(objProps) {
            if (!objProps || !objProps.properties || !Array.isArray(objProps.properties)) {
                return null;
            }

            // Antar at TARGET_PSETS er definert (f.eks. ['pset_spacecommon', 'attributes'])
            const targetPsetNames = Array.isArray(TARGET_PSETS) ? TARGET_PSETS.map(n => n.toLowerCase()) : [];

            // 1. Search in target property sets
            for (const pset of objProps.properties) {
                const psetName = (pset.name || pset.Name || '').toLowerCase();

                if (targetPsetNames.some(target => psetName.includes(target)) && pset.properties && Array.isArray(pset.properties)) {
                    const longNameProp = pset.properties.find(prop => {
                        const propName = (prop.name || prop.Name || '').toLowerCase();
                        return propName === 'longname' || propName === 'long name' || propName === 'long_name';
                    });

                    if (longNameProp) {
                        return longNameProp.value || longNameProp.Value || null;
                    }
                }
            }

            // 2. Fallback: Search all property sets for LongName
            for (const pset of objProps.properties) {
                if (pset.properties && Array.isArray(pset.properties)) {
                    const longNameProp = pset.properties.find(prop => {
                        const propName = (prop.name || prop.Name || '').toLowerCase();
                        return propName === 'longname' || propName === 'long name' || propName === 'long_name';
                    });

                    if (longNameProp) {
                        return longNameProp.value || longNameProp.Value || null;
                    }
                }
            }

            return null;
        }
        
        // ====================================================================
        // COLOR MANAGEMENT
        // ====================================================================
        
        async function applyAllColors() {
            if (!viewerAPI) {
                console.warn("Viewer API not available for color application");
                return;
            }
            
            try {
                // Apply colors for each category if enabled
                const colorErfuellt = document.getElementById('colorErfuellt').checked;
                const colorUnterschritten = document.getElementById('colorUnterschritten').checked;
                const colorUeberschritten = document.getElementById('colorUeberschritten').checked;
                
                if (colorErfuellt) {
                    await applyColorToCategory('erfuellt');
                }
                if (colorUnterschritten) {
                    await applyColorToCategory('unterschritten');
                }
                if (colorUeberschritten) {
                    await applyColorToCategory('ueberschritten');
                }
                
                console.log("All colors applied");
                
            } catch (error) {
                console.error("Error applying colors:", error);
            }
        }
        
        async function applyColorToCategory(category) {
            const data = categoryData[category];
            
            if (!data.objectIds || data.objectIds.length === 0) {
                console.log(`No objects to color for category: ${category}`);
                return;
            }
            
            console.log(`Applying color ${data.color} to ${data.objectIds.length} objects in ${category}`);
            
            try {
                // Use viewerAPI.setObjectState with array of object IDs and state
                // Format: setObjectState(objectIds, state) where state includes {color: '#RRGGBB'}
                if (viewerAPI && typeof viewerAPI.setObjectState === 'function') {
                    await viewerAPI.setObjectState(data.objectIds, { color: data.color });
                    console.log(`Applied color ${data.color} to ${data.objectIds.length} objects in ${category} using setObjectState`);
                } else if (API && API.viewer && typeof API.viewer.setObjectState === 'function') {
                    // Fallback: Try API.viewer.setObjectState
                    await API.viewer.setObjectState(data.objectIds, { color: data.color });
                    console.log(`Applied color ${data.color} to ${data.objectIds.length} objects in ${category} using API.viewer.setObjectState`);
                } else {
                    console.warn("setObjectState method not available");
                    console.log("Available viewerAPI methods:", viewerAPI ? Object.keys(viewerAPI).filter(k => typeof viewerAPI[k] === 'function') : 'none');
                }
            } catch (error) {
                console.error(`Error applying color to ${category}:`, error);
            }
        }
        
        async function removeColorFromCategory(category) {
            const data = categoryData[category];
            
            if (!data.objectIds || data.objectIds.length === 0) {
                return;
            }
            
            try {
                // Use setObjectState with color: 'reset' to remove colors
                if (viewerAPI && typeof viewerAPI.setObjectState === 'function') {
                    await viewerAPI.setObjectState(data.objectIds, { color: 'reset' });
                    console.log(`Reset colors for ${data.objectIds.length} objects in ${category} using setObjectState`);
                } else if (API && API.viewer && typeof API.viewer.setObjectState === 'function') {
                    await API.viewer.setObjectState(data.objectIds, { color: 'reset' });
                    console.log(`Reset colors for ${data.objectIds.length} objects in ${category} using API.viewer.setObjectState`);
                } else {
                    console.warn("setObjectState method not available for resetting colors");
                }
            } catch (error) {
                console.error(`Error resetting color for ${category}:`, error);
            }
        }
        
        async function toggleColor(category) {
            const checkboxId = 'color' + category.charAt(0).toUpperCase() + category.slice(1);
            const isEnabled = document.getElementById(checkboxId).checked;
            
            if (isEnabled) {
                await applyColorToCategory(category);
            } else {
                await removeColorFromCategory(category);
            }
        }
        
        async function resetAllColors() {
            if (!viewerAPI) {
                console.warn("viewerAPI not available");
                return;
            }
            
            try {
                // Collect all object IDs
                const allObjectIds = [
                    ...categoryData.erfuellt.objectIds,
                    ...categoryData.unterschritten.objectIds,
                    ...categoryData.ueberschritten.objectIds
                ];
                
                if (allObjectIds.length > 0) {
                    // Use setObjectState with color: 'reset'
                    if (typeof viewerAPI.setObjectState === 'function') {
                        await viewerAPI.setObjectState(allObjectIds, { color: 'reset' });
                        console.log(`Reset colors for ${allObjectIds.length} objects using setObjectState`);
                    } else if (API && API.viewer && typeof API.viewer.setObjectState === 'function') {
                        await API.viewer.setObjectState(allObjectIds, { color: 'reset' });
                        console.log(`Reset colors for ${allObjectIds.length} objects using API.viewer.setObjectState`);
                    } else {
                        console.warn("setObjectState method not available for resetting all colors");
                    }
                }
                
                // Uncheck all color checkboxes
                document.getElementById('colorErfuellt').checked = false;
                document.getElementById('colorUnterschritten').checked = false;
                document.getElementById('colorUeberschritten').checked = false;
                
                console.log("All colors reset");
                
            } catch (error) {
                console.error("Error resetting colors:", error);
            }
        }
        
        // ====================================================================
        // VISIBILITY MANAGEMENT
        // ====================================================================
        
        async function toggleVisibility(category) {
            const checkboxId = 'visibility' + category.charAt(0).toUpperCase() + category.slice(1);
            const isVisible = document.getElementById(checkboxId).checked;
            const data = categoryData[category];
            
            if (!data.objectIds || data.objectIds.length === 0) {
                return;
            }
            
            try {
                // Use setObjectState with visible property
                if (viewerAPI && typeof viewerAPI.setObjectState === 'function') {
                    await viewerAPI.setObjectState(data.objectIds, { visible: isVisible });
                    console.log(`${isVisible ? 'Showing' : 'Hiding'} ${data.objectIds.length} objects in ${category} using setObjectState`);
                } else if (API && API.viewer && typeof API.viewer.setObjectState === 'function') {
                    await API.viewer.setObjectState(data.objectIds, { visible: isVisible });
                    console.log(`${isVisible ? 'Showing' : 'Hiding'} ${data.objectIds.length} objects in ${category} using API.viewer.setObjectState`);
                } else {
                    console.warn("setObjectState method not available for visibility toggle");
                }
            } catch (error) {
                console.error(`Error toggling visibility for ${category}:`, error);
            }
        }
        
        // ====================================================================
        // UTILITY FUNCTIONS
        // ====================================================================
        
        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // ====================================================================
        // INITIALIZE ON LOAD
        // ====================================================================
        
        init();
    </script>
</body>
</html>
